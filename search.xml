<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[支付宝小程序之ctx绘制密码卡片并保存]]></title>
    <url>%2F3325869383%2F</url>
    <content type="text"><![CDATA[# 前言本篇记录一下之前在支付宝小程序上实现的6字明文密码生成图片后保存到图库功能。图库内保存的密码图片样式如下所示： 技术点实现上图功能主要使用了： my.createCanvasContext CanvasContext.toTempFilePath my.saveImage 其中和绘制相关的是my.createCanvasContext，该方法创建返回了CanvasContext 绘图上下文。CanvasContext如同Android中的Canvas画布，提供了一系列关于绘制的方法，比如： fillText：在画布上绘制被填充的文本 setFillStyle：设置 Canvas 填充色 setFontSize：设置 Canvas 字体大小 lineTo：使用直线连接子路径的终点到某个坐标的方法 arc：在 Canvas 上绘制圆弧路径 save：保存 canvas 全部状态的方法 restore：将 canvas 恢复到最近的保存状态的方法 beginPath：在 Canvas 上开始一个新路径 closePath：将笔点返回到当前子路径起始点的方法 fill：根据当前的填充样式填充当前或已存在的路径的方法 translate：对当前网格添加平移变换的方法 stroke：用于画出当前路径的边框 draw：提交 Canvas 绘制指令 上述列出的CanvasContext的方法为本次绘制卡片效果所调用的绘制接口，CanvasContext提供的其余方法可至官方文档查看：CanvasContext 概览 CanvasContext无法直接将绘制的内容保存到图库，但是官方文档「 canvas组件如何实现生成图片保存 」内提供了实现方式，即：使用CanvasContext.toTempFilePath 把当前画布的内容导出生成图片，获取图片路径（临时路径），再 通过 my.saveImage 保存图片到相册。 所以整个实现的伪代码如下： 1234567891011//1.绘制画布内容 CanvasContext.drawCanvas()//2.导出生成图片，获取图片路径（临时路径）CanvasContext.toTempFilePath(&#123; success: (res) =&gt; &#123; //3.保存图片到相册 my.saveImage(&#123; url: res.apFilePath, &#125;); &#125;&#125;) 细节如同上述伪代码，主要是canvas内容绘制和保存。 Canvas绘制通过my.createCanvasContext，创建获取CanvasContext 绘图上下文，其中入参canvasId为&lt;canvas&gt; 组件的 id 属性，如下，为once-key： 其中css样式为： 123456.canvas_pwd &#123; width: 335px; height: 235px; position: absolute; top:-235px;&#125; 所以创建为：this._ctx = my.createCanvasContext(&#39;once-key&#39;) 其中_ctx就是 CanvasContext 对象，通过它来绘制各种所需的内容。 本次功能需求主要分为： 绘制圆角矩形背景 绘制顶部标题 绘制分割线 绘制密码区域 绘制底部提示文本 归纳后其实主要分为两种：绘制圆角矩形、绘制文本。 绘制圆角矩形小程序的坐标系同Android上的一样，x轴为水平向右➡️，y轴为竖直向下⬇️。 如下roundRect方法所示，分别绘制了左上、右上、右下、左下角上的1/4的圆，以及各边。 其中使用arc在 Canvas 上绘制圆弧路径，其中 startAngle： 起始弧度，单位弧度（在 3 点钟方向）。具体定义如下： 12345678910111213/** * 在 Canvas 上绘制圆弧路径 * @description 圆弧路径的圆心在 (x, y) 位置，半径为 r ，根据anticlockwise （默认为顺时针，anticlockwise：false）指定的方向从 startAngle 开始绘制，到 endAngle 结束。 * @see https://opendocs.alipay.com/mini/api/lut4uo */ arc( x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean ): void; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*** 绘制圆角矩形* @param &#123;Object&#125; ctx - canvas组件的绘图上下文* @param &#123;Number&#125; x - 矩形的x坐标* @param &#123;Number&#125; y - 矩形的y坐标* @param &#123;Number&#125; w - 矩形的宽度* @param &#123;Number&#125; h - 矩形的高度* @param &#123;Number&#125; r - 矩形的圆角半径* @param &#123;String&#125; [c = 'transparent'] - 矩形的填充色*/roundRect(ctx, x, y, w, h, r, c = '#fff') &#123; if (w &lt; 2 * r) &#123; r = w / 2; &#125; if (h &lt; 2 * r) &#123; r = h / 2; &#125; ctx.save()//保存 canvas 全部状态 ctx.beginPath();//在 Canvas 上开始一个新路径 ctx.fillStyle = c;//设置填充色 //绘制左上圆角及边线 ctx.arc(x + r, y + r, r, Math.PI, Math.PI * 1.5); ctx.moveTo(x + r, y); ctx.lineTo(x + w - r, y); ctx.lineTo(x + w, y + r); //绘制右上圆角及边线 ctx.arc(x + w - r, y + r, r, Math.PI * 1.5, Math.PI * 2); ctx.lineTo(x + w, y + h - r); ctx.lineTo(x + w - r, y + h); //绘制右下圆角及边线 ctx.arc(x + w - r, y + h - r, r, 0, Math.PI * 0.5); ctx.lineTo(x + r, y + h); ctx.lineTo(x, y + h - r); //绘制左下圆角及边线 ctx.arc(x + r, y + h - r, r, Math.PI * 0.5, Math.PI); ctx.lineTo(x, y + r); ctx.lineTo(x + r, y); ctx.closePath();//将笔点返回到当前子路径起始点，即闭合路径 ctx.fill();//根据当前的填充样式填充当前或已存在的路径 ctx.restore()//将 canvas 恢复到最近的保存状态&#125; 绘制文本1234567891011121314151617181920212223/** * 绘制文本 * * @param &#123;*&#125; ctx - canvas组件的绘图上下文 * @param &#123;*&#125; text - 绘制的文本 * @param &#123;*&#125; fontSize - 字体大小 * @param &#123;*&#125; fontColor - 字体颜色 * @param &#123;*&#125; y - 绘制文本起点的 y 轴位置 * @param &#123;*&#125; viewWidth - 卡片宽度 */drawText(ctx, text, fontSize, fontColor, y, viewWidth) &#123; ctx.save() ctx.setFillStyle(fontColor) ctx.setFontSize(fontSize) let &#123; width &#125; = ctx.measureText(text + "") if (width === undefined) [ width = measureText(text, fontSize, ctx) ] var x = (viewWidth - width) / 2 // console.log(`drawCanvas-drawText:$&#123;text&#125;,has measureText:$&#123;ctx.measureText !== undefined&#125;, measureText:$&#123;width&#125;,x:$&#123;x&#125;`) ctx.fillText(text, x, y) ctx.restore()&#125; 绘制密码区域密码区域拆分开来，每个密码显示UI就是圆角矩形的背景和居中的数字文本，并且每个密码UI平分卡片UI总宽度（减去设置的边距）。 根据密码长度、卡片总宽度、margin等值计算出密码块的宽高、数字密码的y轴坐标，再配合translate、roundRect、drawText方法遍历绘制各个密码块。 其中便利数组使用of。 123456789101112131415161718192021222324252627282930313233/** * 绘制密码区域 * * @param &#123;*&#125; pwdDigitList - 需要绘制的数字密码列表 * @param &#123;*&#125; ctx - canvas组件的绘图上下文 * @param &#123;*&#125; viewWidth - 卡片视图总宽度 * @param &#123;*&#125; y - 密码区域绘制的y坐标 * @param &#123;*&#125; margin - 密码区域距卡片左右边距 * @param &#123;*&#125; itemMargin - 密码UI item之间的距离 */drawPwdArea(pwdDigitList, ctx, viewWidth, y, margin, itemMargin) &#123; if (pwdDigitList == null || pwdDigitList.length == 0) &#123; return &#125; var itemCount = pwdDigitList.length, itemWidth = (viewWidth - margin * 2 - itemMargin * (itemCount - 1)) / itemCount, itemHeight = 112, translateX = margin, digitPointY = y + itemHeight / 2 + 16 console.log(`drawPwdArea,itemCount:$&#123;itemCount&#125;,itemWidth:$&#123;itemWidth&#125;,translateX:$&#123;translateX&#125;,digitPointY:$&#123;digitPointY&#125;`) ctx.save() ctx.translate(translateX, 0) for (const digit of pwdDigitList) &#123; this.roundRect(ctx, 0, y, itemWidth, itemHeight, 16, '#F0F2F7') this.drawText(ctx, digit, 50, ' #2B3852', digitPointY, itemWidth) translateX = itemWidth + itemMargin ctx.translate(translateX, 0) &#125; ctx.restore()&#125; 完整代码save-key-card.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172import &#123; measureText &#125; from "./utils";class KeyCrad &#123; _ctx _type constructor(canvasId, type) &#123; this._ctx = my.createCanvasContext(canvasId) this._type = type &#125; saveToGalary(deviceName = '可视门锁', pwdDigitList, callback = &#123; success: () =&gt; &#123; &#125;, fail: () =&gt; &#123; &#125; &#125;) &#123; this.drawCanvas(deviceName, pwdDigitList) this._ctx.toTempFilePath(&#123; success: (res) =&gt; &#123; my.saveImage(&#123; url: res.apFilePath, showActionSheet: false, success: () =&gt; &#123; callback.success() &#125;, fail: () =&gt; &#123; callback.fail() &#125;, complete: () =&gt; &#123; &#125; &#125;); &#125;, fail: (error) =&gt; &#123; console.log('toTempFilePath, fail ', error) &#125; &#125;) &#125; /* ----------------------------- 画布相关 START ----------------------------- */ drawCanvas(deviceName, pwdDigitList) &#123; let ctx = this._ctx, type = this._type, typeName = type === 0 ? '随机' : '一次性', viewWidth = 670, viewHeight = 470 this.roundRect(ctx, 0, 0, viewWidth, viewHeight, 24) this.drawText(ctx, `$&#123;deviceName&#125;$&#123;typeName&#125;密码`, 34, '#333333', 60, viewWidth) this.drawDivider(ctx, viewWidth, 100) this.drawPwdArea(pwdDigitList, ctx, viewWidth, 180, 54, 32) this.drawText(ctx, `$&#123;typeName&#125;密码只能使用一次，用完作废，`, 24, 'silver', viewHeight / 5 * 4, viewWidth) this.drawText(ctx, '不要泄露给他人。', 24, 'silver', viewHeight / 5 * 4 + 40, viewWidth) ctx.draw() console.log(`drawCanvas-finish`) &#125; /** * 绘制文本 * * @param &#123;*&#125; ctx - canvas组件的绘图上下文 * @param &#123;*&#125; text - 绘制的文本 * @param &#123;*&#125; fontSize - 字体大小 * @param &#123;*&#125; fontColor - 字体颜色 * @param &#123;*&#125; y - 绘制文本起点的 y 轴位置 * @param &#123;*&#125; viewWidth - 卡片宽度 */ drawText(ctx, text, fontSize, fontColor, y, viewWidth) &#123; ctx.save() ctx.setFillStyle(fontColor) ctx.setFontSize(fontSize) let &#123; width &#125; = ctx.measureText(text + "") if (width === undefined) [ width = measureText(text, fontSize, ctx) ] var x = (viewWidth - width) / 2 // console.log(`drawCanvas-drawText:$&#123;text&#125;,has measureText:$&#123;ctx.measureText !== undefined&#125;, measureText:$&#123;width&#125;,x:$&#123;x&#125;`) ctx.fillText(text, x, y) ctx.restore() &#125; drawDivider(ctx, x, y) &#123; ctx.save() ctx.beginPath() ctx.setStrokeStyle('#F5F5F5') ctx.setLineWidth(2) ctx.moveTo(0, y) ctx.lineTo(x, y) ctx.stroke() ctx.restore() &#125; /** * 绘制密码区域 * * @param &#123;*&#125; pwdDigitList - 需要绘制的数字密码列表 * @param &#123;*&#125; ctx - canvas组件的绘图上下文 * @param &#123;*&#125; viewWidth - 卡片视图总宽度 * @param &#123;*&#125; y - 密码区域绘制的y坐标 * @param &#123;*&#125; margin - 密码区域距卡片左右边距 * @param &#123;*&#125; itemMargin - 密码UI item之间的距离 */ drawPwdArea(pwdDigitList, ctx, viewWidth, y, margin, itemMargin) &#123; if (pwdDigitList == null || pwdDigitList.length == 0) &#123; return &#125; var itemCount = pwdDigitList.length, itemWidth = (viewWidth - margin * 2 - itemMargin * (itemCount - 1)) / itemCount, itemHeight = 112, translateX = margin, digitPointY = y + itemHeight / 2 + 16 console.log(`drawPwdArea,itemCount:$&#123;itemCount&#125;,itemWidth:$&#123;itemWidth&#125;,translateX:$&#123;translateX&#125;,digitPointY:$&#123;digitPointY&#125;`) ctx.save() ctx.translate(translateX, 0) for (const digit of pwdDigitList) &#123; this.roundRect(ctx, 0, y, itemWidth, itemHeight, 16, '#F0F2F7') this.drawText(ctx, digit, 50, ' #2B3852', digitPointY, itemWidth) translateX = itemWidth + itemMargin ctx.translate(translateX, 0) &#125; ctx.restore() &#125; /** * 绘制圆角矩形 * @param &#123;Object&#125; ctx - canvas组件的绘图上下文 * @param &#123;Number&#125; x - 矩形的x坐标 * @param &#123;Number&#125; y - 矩形的y坐标 * @param &#123;Number&#125; w - 矩形的宽度 * @param &#123;Number&#125; h - 矩形的高度 * @param &#123;Number&#125; r - 矩形的圆角半径 * @param &#123;String&#125; [c = 'transparent'] - 矩形的填充色 */ roundRect(ctx, x, y, w, h, r, c = '#fff') &#123; if (w &lt; 2 * r) &#123; r = w / 2; &#125; if (h &lt; 2 * r) &#123; r = h / 2; &#125; ctx.save() ctx.beginPath(); ctx.fillStyle = c; ctx.arc(x + r, y + r, r, Math.PI, Math.PI * 1.5); ctx.moveTo(x + r, y); ctx.lineTo(x + w - r, y); ctx.lineTo(x + w, y + r); ctx.arc(x + w - r, y + r, r, Math.PI * 1.5, Math.PI * 2); ctx.lineTo(x + w, y + h - r); ctx.lineTo(x + w - r, y + h); ctx.arc(x + w - r, y + h - r, r, 0, Math.PI * 0.5); ctx.lineTo(x + r, y + h); ctx.lineTo(x, y + h - r); ctx.arc(x + r, y + h - r, r, Math.PI * 0.5, Math.PI); ctx.lineTo(x, y + r); ctx.lineTo(x + r, y); ctx.closePath(); ctx.fill(); ctx.restore() &#125;&#125;export default KeyCrad utils.js1234567891011121314151617181920212223242526272829303132333435/** * 由于在iOS上CanvasContext.measureText返回API不存在，所以得自己计算文本text宽度 * * @param &#123;string&#125; text * @param &#123;number&#125; fontSize */export const measureText = function (text, fontSize) &#123; text = String(text); var text = text.split(''); var width = 0; for (let i = 0; i &lt; text.length; i++) &#123; let item = text[i]; if (/[a-zA-Z]/.test(item)) &#123; width += 7; &#125; else if (/[0-9]/.test(item)) &#123; width += 5.5; &#125; else if (/\./.test(item)) &#123; width += 2.7; &#125; else if (/-/.test(item)) &#123; width += 3.25; &#125; else if (/[\u4e00-\u9fa5]/.test(item)) &#123; width += 10; &#125; else if (/\(|\)/.test(item)) &#123; width += 3.73; &#125; else if (/\s/.test(item)) &#123; width += 2.5; &#125; else if (/%/.test(item)) &#123; width += 8; &#125; else &#123; width += 10; &#125; &#125; return width * fontSize / 10;&#125; 使用示例js 123456789101112131415161718import KeyCard from './save-key-card';Page(&#123; onLoad(params) &#123; this.keyCard = new KeyCard('once-key', 1) &#125;, saveCanvasToGalary(deviceName) &#123; this.keyCard.saveToGalary(deviceName, this.data.pwdDigitList, &#123; success: () =&gt; &#123; showToast('已保存到手机相册'); &#125;, fail: () =&gt; &#123; showToast('保存失败'); &#125;, &#125;) &#125;,&#125;) axml 1&lt;canvas id="once-key" class="canvas_pwd" width="670" height="470"&gt;&lt;/canvas&gt;]]></content>
      <categories>
        <category>支付宝小程序</category>
      </categories>
      <tags>
        <tag>支付宝小程序</tag>
        <tag>CanvasContext</tag>
        <tag>保存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从ViewRootImpl开始分析事件分发过程]]></title>
    <url>%2F4080158305%2F</url>
    <content type="text"><![CDATA[前言上篇“Android事件分发机制源码解析”分析了从Activity获取到触摸事件之后开始的分发流程，本篇就承接该篇介绍在触摸事件到达Activity之前的一些流程。 当点击屏幕产生一个触摸行为时，这个触摸行为则是通过底层硬件捕获传递到ViewRootImpl内的。由于底层相关的涉及到native相关的知识，这里就简单摘取传到Java层的主要部分，详细的过程感兴趣的同学可以查看这篇文章“Input系统—事件处理全过程”，而本篇就直接从ViewRootImpl接受到事件处开始展开。 时序图分发流程的主题部分如下时序图所示： 下面将详细介绍其中的每个步骤。 Native frameworks/base/core/jni/android_view_InputEventReceiver.cpp （点击查看完整源码） 12345678910111213141516171819202122232425262728293031323334353637status_t NativeInputEventReceiver::consumeEvents(JNIEnv* env, bool consumeBatches, nsecs_t frameTime, bool* outConsumedBatch) &#123; ... ScopedLocalRef&lt;jobject&gt; receiverObj(env, NULL); bool skipCallbacks = false; for (;;) &#123; uint32_t seq; InputEvent* inputEvent; // 读取InputEvent status_t status = mInputConsumer.consume(&amp;mInputEventFactory, consumeBatches, frameTime, &amp;seq, &amp;inputEvent); ... switch (inputEvent-&gt;getType()) &#123; case AINPUT_EVENT_TYPE_KEY: //由Native的inputEvent来生成Java层的事件 inputEventObj = android_view_KeyEvent_fromNative(env, static_cast&lt;KeyEvent*&gt;(inputEvent)); break; ... &#125; if (inputEventObj) &#123; //执行Java层的InputEventReceiver.dispachInputEvent env-&gt;CallVoidMethod(receiverObj.get(), gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj); ... &#125; &#125; ... &#125;&#125; 可以看到最后是调用到了Java层的InputEventReceiver.dispachInputEvent()方法 InputEventReceiver frameworks/base/core/java/android/view/InputEventReceiver.java（点击查看完整源码） 12345678910/** * Provides a low-level mechanism for an application to receive input events. * @hide */public abstract class InputEventReceiver &#123; private void dispatchInputEvent(int seq, InputEvent event) &#123; mSeqMap.put(event.getSequenceNumber(), seq); onInputEvent(event); &#125;&#125; dispatchInputEvent()方法内部主要是调用了onInputEvent(event)方法。 而这里InputEventReceiver的实现类就是ViewRootImpl的内部类WindowInputEventReceiver。 ViewRootImpl从这里开始开始的流程就都是在Java层了。 WindowInputEventReceiver frameworks/base/core/java/android/view/ViewRootImpl.java （点击查看完整源码） 12345678final class WindowInputEventReceiver extends InputEventReceiver &#123; @Override public void onInputEvent(InputEvent event) &#123; ... enqueueInputEvent(event, this, 0, true); &#125;&#125; 在子类WindowInputEventReceiver.onInputEvent()方法内调用了ViewRootImpl.enqueueInputEvent() 123456789101112131415161718192021222324252627void enqueueInputEvent(InputEvent event, InputEventReceiver receiver, int flags, boolean processImmediately) &#123; adjustInputEventForCompatibility(event); //构建一个QueuedInputEvent QueuedInputEvent q = obtainQueuedInputEvent(event, receiver, flags); //将构建的QueuedInputEvent添加到pending队列末尾 QueuedInputEvent last = mPendingInputEventTail; if (last == null) &#123; mPendingInputEventHead = q; mPendingInputEventTail = q; &#125; else &#123; last.mNext = q; mPendingInputEventTail = q; &#125; //队列计数 mPendingInputEventCount += 1; Trace.traceCounter(Trace.TRACE_TAG_INPUT, mPendingInputEventQueueLengthCounterName, mPendingInputEventCount); //处理pending队列内的事件 if (processImmediately) &#123; doProcessInputEvents(); // 立即同步执行 &#125; else &#123; scheduleProcessInputEvents();//通过handler分发执行 &#125;&#125; enqueueInputEvent()方法内将输入事件封装成QueuedInputEvent后加入队列末尾，之后再进行事件处理。 QueuedInputEvent回收池其中QueuedInputEvent也是ViewRootImpl的内部类，成员变量mNext是用来链接下一个成员，从而组成一个单向链表。 其中mFlag是一个int型的标志位，在下方InputStage分发逻辑中有重要作用。可以看到WindowInputEventReceiver.onInputEvent()方法内调用enqueueInputEvent()方法时传入的flags行参值为0。 123456789 private static final class QueuedInputEvent &#123; public QueuedInputEvent mNext; public InputEvent mEvent; public InputEventReceiver mReceiver; public int mFlags; ...&#125; obtainQueuedInputEvent()和recycleQueuedInputEvent()方法则是配合ViewRootImpl的成员变量mQueuedInputEventPoolSize、mQueuedInputEventPool设计成了一个输入事件包装类QueuedInputEvent的回收池，便于QueuedInputEvent的重复使用。 1234567891011121314151617181920212223242526272829303132333435363738/** * 1. 判断mQueuedInputEventPool回收池内是否有缓存的对象，若有则取出一个 * 2. 若第一步内没有取到，则直接新建一个QueuedInputEvent对象 * 3. 将入参保存到QueuedInputEvent对象内 */private QueuedInputEvent obtainQueuedInputEvent(InputEvent event, InputEventReceiver receiver, int flags) &#123; QueuedInputEvent q = mQueuedInputEventPool; if (q != null) &#123; mQueuedInputEventPoolSize -= 1;//QueuedInputEvent回收池由于取出一个后数量减1 mQueuedInputEventPool = q.mNext; q.mNext = null; &#125; else &#123; q = new QueuedInputEvent(); &#125; q.mEvent = event; q.mReceiver = receiver; q.mFlags = flags; return q;&#125;/** * 若当前回收池内的数量没有超过MAX_QUEUED_INPUT_EVENT_POOL_SIZE = 10，则将其放入回收池内 */private void recycleQueuedInputEvent(QueuedInputEvent q) &#123; q.mEvent = null; q.mReceiver = null; if (mQueuedInputEventPoolSize &lt; MAX_QUEUED_INPUT_EVENT_POOL_SIZE) &#123; mQueuedInputEventPoolSize += 1;//QueuedInputEvent回收池由于放入一个后数量加1 q.mNext = mQueuedInputEventPool; mQueuedInputEventPool = q; &#125;&#125;// Pool of queued input events.private static final int MAX_QUEUED_INPUT_EVENT_POOL_SIZE = 10; doProcessInputEvents再回到enqueueInputEvent()方法内，分析最后几行 123456//处理pending队列内的事件if (processImmediately) &#123; doProcessInputEvents(); // 立即同步执行&#125; else &#123; scheduleProcessInputEvents();//通过handler分发执行&#125; processImmediately表示是否立即同步执行，在WindowInputEventReceiver回调内传入的是true，执行doProcessInputEvents()。而当false异步时，则调用到scheduleProcessInputEvents() 1234567891011121314151617181920212223242526private void scheduleProcessInputEvents() &#123; if (!mProcessInputEventsScheduled) &#123; mProcessInputEventsScheduled = true; Message msg = mHandler.obtainMessage(MSG_PROCESS_INPUT_EVENTS); msg.setAsynchronous(true); mHandler.sendMessage(msg); &#125;&#125;final ViewRootHandler mHandler = new ViewRootHandler();final class ViewRootHandler extends Handler &#123; ... @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; ... case MSG_PROCESS_INPUT_EVENTS: mProcessInputEventsScheduled = false; doProcessInputEvents(); break; ... &#125; &#125; 可以看到最后还是调用到了doProcessInputEvents()方法。 12345678910111213141516171819202122void doProcessInputEvents() &#123; // Deliver all pending input events in the queue. while (mPendingInputEventHead != null) &#123; QueuedInputEvent q = mPendingInputEventHead; mPendingInputEventHead = q.mNext; if (mPendingInputEventHead == null) &#123; mPendingInputEventTail = null; &#125; q.mNext = null; mPendingInputEventCount -= 1; ... deliverInputEvent(q); &#125; // 处理完所有输入事件后，清除标志位 if (mProcessInputEventsScheduled) &#123; mProcessInputEventsScheduled = false; mHandler.removeMessages(MSG_PROCESS_INPUT_EVENTS); &#125;&#125; doProcessInputEvents()方法内就是通过一个while循环遍历链表中的输入事件，调用deliverInputEvent()进行事件分发处理。 这里的mPendingInputEventHead链表就是上面的enqueueInputEvent()方法将内输入事件包装类插入的链表。 最后处理完所有输入事件后，清除标志位。 12345678910111213141516171819private void deliverInputEvent(QueuedInputEvent q) &#123; Trace.asyncTraceBegin(Trace.TRACE_TAG_VIEW, "deliverInputEvent", q.mEvent.getSequenceNumber()); ... InputStage stage; if (q.shouldSendToSynthesizer()) &#123; stage = mSyntheticInputStage; &#125; else &#123; stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage; &#125; if (stage != null) &#123; handleWindowFocusChanged(); stage.deliver(q); &#125; else &#123; finishInputEvent(q); //结束事件分发 &#125;&#125; deliverInputEventdeliverInputEvent()方法从方法名就可以知道它的作用是分发事件。 方法内最主要的就是InputStage，最终要么是调用了stage.deliver(q)，要么就是stage为空直接结束事件分发。 而stage赋值处的几个InputStage子类是在ViewRootImpl.setView()方法内实例化的，这个方法在窗口管理和view绘制方面起到非常重要的作用，这部分之后会抽空再单独详细讲解。所以在View绘制之后所触发的事件，这里的7个InputStage子类都是不为空的。 而从这7个InputStage子类的构造器来看，就是典型的责任链模式，即自己能处理就自己处理，若不能处理则交给下一个处理，从下面InputStage的源码也能证实责任链模式。 123456789101112131415161718public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView, int userId) &#123; ... mSyntheticInputStage = new SyntheticInputStage(); InputStage viewPostImeStage = new ViewPostImeInputStage(mSyntheticInputStage); InputStage nativePostImeStage = new NativePostImeInputStage(viewPostImeStage, "aq:native-post-ime:" + counterSuffix); InputStage earlyPostImeStage = new EarlyPostImeInputStage(nativePostImeStage); InputStage imeStage = new ImeInputStage(earlyPostImeStage, "aq:ime:" + counterSuffix); InputStage viewPreImeStage = new ViewPreImeInputStage(imeStage); InputStage nativePreImeStage = new NativePreImeInputStage(viewPreImeStage, "aq:native-pre-ime:" + counterSuffix); mFirstInputStage = nativePreImeStage; mFirstPostImeInputStage = earlyPostImeStage; ... &#125; NativePreImeInputStage: 主要是为了将消息放到NativeActivity中去处理, NativeActivity和普通Acitivty的功能区别不大,只是很多代码都在native层去实现,这样执行效率更高,并且NativeActivity在游戏开发中很实用。 ViewPreImeInputStage: 从名字中就可得知,最后会调用Acitivity的所有view的onkeyPreIme方法,这样就给View在输入法处理key事件之前先得到消息并处理的机会。 ImeInputStage: ImeInputStage的onProcess方法会调用InputMethodManager的dispatchInputEvent方法处理消息。 EarlyPostImeInputStage: 屏幕上有焦点的View会高亮显示,用来提示用户焦点所在。 NativePostImeInputStage: 为了让IME处理完消息后能先于普通的Activity处理消息。 ViewPostImeInputStage: Acitivity和view处理各种消息。 SyntheticInputStage: 流水线的最后一级,经过层层过滤之后,到达这里的消息已经不多了,例如手机上的虚拟按键消息。 那么Activity和View的事件处理主要对应的InputStage是ViewPostImeInputStage。 类图: InputStage详解源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174/** * Base class for implementing a stage in the chain of responsibility * for processing input events. * &lt;p&gt; * Events are delivered to the stage by the &#123;@link #deliver&#125; method. The stage * then has the choice of finishing the event or forwarding it to the next stage. * &lt;/p&gt; */abstract class InputStage &#123; private final InputStage mNext;//持有的下一个stage对象 //3种状态 protected static final int FORWARD = 0;//当前stage不处理，会将事件传递给下个stage处理 protected static final int FINISH_HANDLED = 1;//当前stage已处理，会调用finish，stage链上剩余的都不会处理该事件 protected static final int FINISH_NOT_HANDLED = 2;//当前stage未处理，会调用finish，stage链上剩余的都不会处理该事件 private String mTracePrefix; /** * Creates an input stage. * @param next The next stage to which events should be forwarded. */ public InputStage(InputStage next) &#123; mNext = next; &#125; /** * Delivers an event to be processed. * 分发事件 */ public final void deliver(QueuedInputEvent q) &#123; if ((q.mFlags &amp; QueuedInputEvent.FLAG_FINISHED) != 0) &#123; forward(q);//当前stage不处理，直接传给下一个（即：mNext） &#125; else if (shouldDropInputEvent(q)) &#123;//判断事件是否需要丢弃 finish(q, false);//结束调用，stage链上的各个stage都不会处理这个事件 &#125; else &#123; traceEvent(q, Trace.TRACE_TAG_VIEW); final int result; try &#123; result = onProcess(q);//在onProcess()内处理具体的操作 &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; apply(q, result);//根据onProcess()返回的状态值result判断是传递给下个stage处理还是结束 &#125; &#125; /** * Marks the the input event as finished then forwards it to the next stage. * finish方法主要是给QueuedInputEvent的mFlags标志位设置FLAG_FINISHED状态，且当handled = true时，设 * 置FLAG_FINISHED_HANDLED标志，以表示事件已被处理。 * 当事件在stage内传递完毕后会调用finishInputEvent()，该方法内就会取出FLAG_FINISHED_HANDLED标志状态回调给mReciver */ protected void finish(QueuedInputEvent q, boolean handled) &#123; q.mFlags |= QueuedInputEvent.FLAG_FINISHED; if (handled) &#123; q.mFlags |= QueuedInputEvent.FLAG_FINISHED_HANDLED; &#125; forward(q); &#125; /** * Forwards the event to the next stage. * 将事件分发给下个stage */ protected void forward(QueuedInputEvent q) &#123; onDeliverToNext(q); &#125; /** * Applies a result code from &#123;@link #onProcess&#125; to the specified event. * 根据onProcess()返回的状态值result判断是传递给下个stage处理还是结束 */ protected void apply(QueuedInputEvent q, int result) &#123; if (result == FORWARD) &#123; forward(q); &#125; else if (result == FINISH_HANDLED) &#123; finish(q, true); &#125; else if (result == FINISH_NOT_HANDLED) &#123; finish(q, false); &#125; else &#123; throw new IllegalArgumentException("Invalid result: " + result); &#125; &#125; /** * Called when an event is ready to be processed. * @return A result code indicating how the event was handled. * 具体处理逻辑处，默认是无实现，直接返回FORWARD值，交给下个stage处理 */ protected int onProcess(QueuedInputEvent q) &#123; return FORWARD; &#125; /** * Called when an event is being delivered to the next stage. * 若stage未分发完毕，则继续分发处理； * 否则调用finishInputEvent方法结束stage的链式调用 */ protected void onDeliverToNext(QueuedInputEvent q) &#123; if (DEBUG_INPUT_STAGES) &#123; Log.v(mTag, "Done with " + getClass().getSimpleName() + ". " + q); &#125; if (mNext != null) &#123; mNext.deliver(q); &#125; else &#123; finishInputEvent(q); &#125; &#125; protected void onWindowFocusChanged(boolean hasWindowFocus) &#123; if (mNext != null) &#123; mNext.onWindowFocusChanged(hasWindowFocus); &#125; &#125; protected void onDetachedFromWindow() &#123; if (mNext != null) &#123; mNext.onDetachedFromWindow(); &#125; &#125; protected boolean shouldDropInputEvent(QueuedInputEvent q) &#123; if (mView == null || !mAdded) &#123; Slog.w(mTag, "Dropping event due to root view being removed: " + q.mEvent); return true; &#125; else if ((!mAttachInfo.mHasWindowFocus &amp;&amp; !q.mEvent.isFromSource(InputDevice.SOURCE_CLASS_POINTER) &amp;&amp; !isAutofillUiShowing()) || mStopped || (mIsAmbientMode &amp;&amp; !q.mEvent.isFromSource(InputDevice.SOURCE_CLASS_BUTTON)) || (mPausedForTransition &amp;&amp; !isBack(q.mEvent))) &#123; // This is a focus event and the window doesn't currently have input focus or // has stopped. This could be an event that came back from the previous stage // but the window has lost focus or stopped in the meantime. if (isTerminalInputEvent(q.mEvent)) &#123; // Don't drop terminal input events, however mark them as canceled. q.mEvent.cancel(); Slog.w(mTag, "Cancelling event due to no window focus: " + q.mEvent); return false; &#125; // Drop non-terminal input events. Slog.w(mTag, "Dropping event due to no window focus: " + q.mEvent); return true; &#125; return false; &#125; void dump(String prefix, PrintWriter writer) &#123; if (mNext != null) &#123; mNext.dump(prefix, writer); &#125; &#125; private boolean isBack(InputEvent event) &#123; if (event instanceof KeyEvent) &#123; return ((KeyEvent) event).getKeyCode() == KeyEvent.KEYCODE_BACK; &#125; else &#123; return false; &#125; &#125; private void traceEvent(QueuedInputEvent q, long traceTag) &#123; if (!Trace.isTagEnabled(traceTag)) &#123; return; &#125; if (mTracePrefix == null) &#123; mTracePrefix = getClass().getSimpleName(); &#125; Trace.traceBegin(traceTag, mTracePrefix + " id=0x" + Integer.toHexString(q.mEvent.getId())); &#125;&#125; 流程图 说明InputStage主要方法有这几个： void deliver(QueuedInputEvent q)：这是deliverInputEvent()方法内的satge直接调用的入口。 void forward(QueuedInputEvent q)、onDeliverToNext(QueuedInputEvent q)：forword内直接调用了onDeliverToNext。后者方法内判断当前stage是否为stage链上的最后一项（即：mNext == null）。若是，则调用finishInputEvent(q)将处理结果返回给mReceiver，否则就继续传递给下一个stage判断处理（mNext.deliver(q)） boolean shouldDropInputEvent(QueuedInputEvent q): 判断事件是否需要丢弃 int onProcess(QueuedInputEvent q) ：具体处理逻辑处，默认是无实现，直接返回FORWARD值，交给下个stage处理 void apply(QueuedInputEvent q, int result) ：根据onProcess()返回的状态值result判断是传递给下个stage处理还是结束，这里的结束并不是直接跳出stage链内的调用，而是在链内逐个stage遍历时每个stage都不处理，直到责任链尾时（mNext == null）调用finishInputEvent方法返回本次执行结果。 void finish(QueuedInputEvent q, boolean handled) ：给QueuedInputEvent的mFlags标志位设置FLAG_FINISHED状态，且当handled = true时，设置FLAG_FINISHED_HANDLED标志，以表示事件已被处理。当事件在stage内传递完毕后会调用finishInputEvent()，该方法内就会取出FLAG_FINISHED_HANDLED标志状态并回调给mReceiver onProcess()返回的三种类型： FORWARD = 0 ：当前stage不处理，会将事件传递给下个stage处理 FINISH_HANDLED = 1 ： 当前stage已处理，会调用finish，stage链上剩余的都不会处理该事件 FINISH_NOT_HANDLED = 2 ： 当前stage未处理，会调用finish，stage链上剩余的都不会处理该事件 其中FINISH_HANDLED 和FINISH_NOT_HANDLED在stage责任链模式上传递时的表现行为是完全一致的，即之后的stage都不会处理。只是在finishInputEvent内会将该值取出（表示该事件是否已被消费）回调给mReceiver 12345678910111213private void finishInputEvent(QueuedInputEvent q) &#123; if (q.mReceiver != null) &#123; boolean handled = (q.mFlags &amp; QueuedInputEvent.FLAG_FINISHED_HANDLED) != 0; ... q.mReceiver.finishInputEvent(q.mEvent, handled); &#125; else &#123; q.mEvent.recycleIfNeededAfterDispatch(); &#125; recycleQueuedInputEvent(q);&#125; finishInputEvent方法就是将执行结果handled返回给mReceiver，最后调用recycleQueuedInputEvent(q)将QueuedInputEvent对象回收。 ViewPostImeInputStage#onProcess()InputStage内的具体执行流程分析完了，接下来就可以去看看ViewPostImeInputStage.onProcess()具体执行了什么。 123456789101112131415161718192021final class ViewPostImeInputStage extends InputStage &#123; public ViewPostImeInputStage(InputStage next) &#123; super(next); &#125; @Override protected int onProcess(QueuedInputEvent q) &#123; if (q.mEvent instanceof KeyEvent) &#123; return processKeyEvent(q);//处理键盘事件 &#125; else &#123; final int source = q.mEvent.getSource(); if ((source &amp; InputDevice.SOURCE_CLASS_POINTER) != 0) &#123; return processPointerEvent(q);//处理触摸事件 &#125; else if ((source &amp; InputDevice.SOURCE_CLASS_TRACKBALL) != 0) &#123; return processTrackballEvent(q);//处理轨迹球事件 &#125; else &#123; return processGenericMotionEvent(q); &#125; &#125; &#125; &#125; ViewPostImeInputStage.onProcess()内有判断当前事件类型，我们这边分析触摸事件，所以直接看processPointerEvent(q)。对其他事件感兴趣的可以自行查看源码分析。 1234567private int processPointerEvent(QueuedInputEvent q) &#123; final MotionEvent event = (MotionEvent)q.mEvent; ... boolean handled = mView.dispatchPointerEvent(event); ... return handled ? FINISH_HANDLED : FORWARD;&#125; 这里就可以看到ViewPostImeInputStage.onProgress()返回的具体值handled ? FINISH_HANDLED : FORWARD， FINISH_HANDLED：当前触摸事件由ViewPostImeInputStage处理；FORWARD：ViewPostImeInputStage未处理，继续传给SyntheticInputStage处理。 当然，processPointerEvent内的主角是mView.dispatchPointerEvent(event)。mView是ViewRootImpl的成员变量，该变量是在ViewRootImpl.setView()内赋值的。ViewRootImpl.setView()方法在上面介绍deliverInputEvent()方法内的InputStage初始化实例时就提到过。 ViewRootImpl#setView行参view具体类型确定 frameworks/base/core/java/android/view/ViewRootImpl.java （点击查看源码） 12345678public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView, int userId) &#123; synchronized (this) &#123; if (mView == null) &#123; mView = view; ... &#125; &#125; 这里view的入参类型是View，所以还得看看ViewRootImpl.setView()方法具体是哪里调用的，且view的具体类型是什么。 这里就直接给出结论：DecorView 调用过程：ActivityThread.handleResumeActivity() -&gt; WindowManagerImpl.addView() -&gt; WindowManagerGlobal.addView() -&gt; ViewRootImpl.setView() 这里的涉及到的具体细节将在下篇介绍Window相关知识的时候再详细展开说明。 frameworks/base/core/java/android/app/ActivityThread.java（点击查看源码） 123456789101112131415161718192021public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward, String reason) &#123; ... final Activity a = r.activity; ... r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; ... if (a.mVisibleFromClient) &#123; if (!a.mWindowAdded) &#123; a.mWindowAdded = true; wm.addView(decor, l);//这里的wm的具体实现类是WindowManagerImpl &#125; &#125; ...&#125; frameworks/base/core/java/android/view/WindowManagerImpl.java（点击查看源码）1234567private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.addView(view, params, mContext.getDisplayNoVerify(), mParentWindow, mContext.getUserId());&#125; frameworks/base/core/java/android/view/WindowManagerGlobal.java（点击查看源码） 1234567891011121314151617181920212223public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow, int userId) &#123; ... root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); // do this last because it fires off messages to start doing things try &#123; root.setView(view, wparams, panelParentView, userId); &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; throw e; &#125; &#125;&#125; View#dispatchPointerEvent、DecorView#dispatchTouchEvent()在确认了view的类型是DecorView后，在DecorView源码内搜索时确没有找到dispatchPointerEvent方法，那就从父类中查找（DecorView -&gt; FrameLayout -&gt; ViewGroup -&gt; View），直到在View内才找到该方法。 frameworks/base/core/java/android/view/View.java（点击查看源码） 1234567public final boolean dispatchPointerEvent(MotionEvent event) &#123; if (event.isTouchEvent()) &#123; return dispatchTouchEvent(event); &#125; else &#123; return dispatchGenericMotionEvent(event); &#125;&#125; 可以看到，这里会判断当前是否为触摸事件，如果是则调用dispatchTouchEvent(event)。 frameworks/base/core/java/com/android/internal/policy/DecorView.java（点击查看源码） 12345public boolean dispatchTouchEvent(MotionEvent ev) &#123; final Window.Callback cb = mWindow.getCallback(); return cb != null &amp;&amp; !mWindow.isDestroyed() &amp;&amp; mFeatureId &lt; 0 ? cb.dispatchTouchEvent(ev) : super.dispatchTouchEvent(ev);&#125; 回到DecorView.dispatchTouchEvent()，这里会调用cb.dispatchTouchEvent(ev)，cb为Window.Callback类型。 frameworks/base/core/java/android/view/Window.java（点击查看源码） 123456789101112131415161718192021222324252627public interface Callback &#123; /** * Called to process key events. At the very least your * implementation must call * &#123;@link android.view.Window#superDispatchKeyEvent&#125; to do the * standard key processing. * * @param event The key event. * * @return boolean Return true if this event was consumed. */ public boolean dispatchKeyEvent(KeyEvent event); /** * Called to process touch screen events. At the very least your * implementation must call * &#123;@link android.view.Window#superDispatchTouchEvent&#125; to do the * standard touch screen processing. * * @param event The touch screen event. * * @return boolean Return true if this event was consumed. */ public boolean dispatchTouchEvent(MotionEvent event); ...&#125; 而Activity类实现了这个回调，并且在Activity.attach()方法内给PhoneWindow设置CallBack回调。 frameworks/base/core/java/android/app/Activity.java（点击查看源码） 123456public class Activity extends ContextThemeWrapper implements LayoutInflater.Factory2, Window.Callback, KeyEvent.Callback, OnCreateContextMenuListener, ComponentCallbacks2, Window.OnWindowDismissedCallback, AutofillManager.AutofillClient, ContentCaptureManager.ContentCaptureClient &#123; 123456789101112131415161718final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken) &#123; attachBaseContext(context); mFragments.attachHost(null /*parent*/); mWindow = new PhoneWindow(this, window, activityConfigCallback); mWindow.setWindowControllerCallback(mWindowControllerCallback); mWindow.setCallback(this);//设置回调 mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); ...&#125; 123456789public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev);&#125; 分析到这里就回到平时从Activity开始分析的事件分发流程的起点了。从Activity.dispatchTouchEvent()开始分析事件分发的过程就可以看小编之前的文章“Android事件分发机制源码解析”了。 参考Android Input（六）-ViewRootImpl接收事件 Input系统—事件处理全过程 Android Code Search]]></content>
      <categories>
        <category>android</category>
        <category>事件分发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从源码及字节码角度分析For-Each删除问题]]></title>
    <url>%2F2571175809%2F</url>
    <content type="text"><![CDATA[前言印象中list在循环中删除成员时是会抛出异常的，结果最近无意中看到了关于该操作的相关文章，就将循环删除的几种方式均试了一下，实际结果却大相径庭。 今天就借此将结果和原因好好梳理分析一下。 这里重点介绍ArrayList这个类型的数据结构。 示例代码说明本篇使用到的示例代码如下，使用 ArrayList，并放入“1”、“2”、“3”这三个字符串。 在注释处替换为下方各方式内的示例代码 1234567891011121314151617import java.util.ArrayList;public class TestForEach &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("1"); list.add("2"); list.add("3");//此处替换为下方各种方式内的遍历代码 System.out.println(list); &#125;&#125; Iterable.forEach(Consumer&lt;? super E&gt; action)集合类均实现了 Iterable接口 1234567891011121314151617181920package java.util /** * @see Set * @see List * @see Map * @see SortedSet * @see SortedMap * @see HashSet * @see TreeSet * @see ArrayList * @see LinkedList * @see Vector * @see Collections * @see Arrays * @see AbstractCollection * @since 1.2 */public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123; ··· 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package java.lang;/** * Implementing this interface allows an object to be the target of * the "for-each loop" statement. See * &lt;strong&gt; * &lt;a href="&#123;@docRoot&#125;/../technotes/guides/language/foreach.html"&gt;For-each Loop&lt;/a&gt; * &lt;/strong&gt; * * @param &lt;T&gt; the type of elements returned by the iterator * * @since 1.5 * @jls 14.14.2 The enhanced for statement */public interface Iterable&lt;T&gt; &#123; ··· /** * Performs the given action for each element of the &#123;@code Iterable&#125; * until all elements have been processed or the action throws an * exception. Unless otherwise specified by the implementing class, * actions are performed in the order of iteration (if an iteration order * is specified). Exceptions thrown by the action are relayed to the * caller. * * @implSpec * &lt;p&gt;The default implementation behaves as if: * &lt;pre&gt;&#123;@code * for (T t : this) * action.accept(t); * &#125;&lt;/pre&gt; * * @param action The action to be performed for each element * @throws NullPointerException if the specified action is null * @since 1.8 */ default void forEach(Consumer&lt;? super T&gt; action) &#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125; &#125; ··· &#125; 示例12345list.forEach(number -&gt; &#123; if ("2".equals(number)) &#123; list.remove(number); &#125;&#125;); 运行结果123Exception in thread "main" java.util.ConcurrentModificationException at java.util.ArrayList.forEach(ArrayList.java:1260) at TestForEach.main(TestForEach.java:10) 分析可以看到，报了 java.util.ConcurrentModificationException错误，并提示了出错位置在 java.util.ArrayList.forEach(ArrayList.java:1260) 这是因为ArrayList重写了forEach方法： 1234567891011121314@Overridepublic void forEach(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); final int expectedModCount = modCount; @SuppressWarnings("unchecked") final E[] elementData = (E[]) this.elementData; final int size = this.size; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; action.accept(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125; 其中最主要的一个就是modCount，这个是ArrayList父类AbstractList的成员变量，默认值为0，表示list成员结构性修改的次数（add、remove、clear、sort等操作会使modCount值+1）。 而我们回调内调用remove()方法，该方法内部又调用了fastRemove()，从而使得modCount++，导致modCount != expectedModCount成立后抛出异常。 1234567891011/** * The number of times this list has been &lt;i&gt;structurally modified&lt;/i&gt;. * Structural modifications are those that change the size of the * list, or otherwise perturb it in such a fashion that iterations in * progress may yield incorrect results. * ··· */ protected transient int modCount = 0; 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Removes the first occurrence of the specified element from this list, * if it is present. If the list does not contain the element, it is * unchanged. More formally, removes the element with the lowest index * &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt; * (if such an element exists). Returns &lt;tt&gt;true&lt;/tt&gt; if this list * contained the specified element (or equivalently, if this list * changed as a result of the call). * * @param o element to be removed from this list, if present * @return &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element */public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125;/* * Private remove method that skips bounds checking and does not * return the value removed. */private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125; 所以Arraylist在forEach回调内不能执行删除等会导致modCount值变化的操作。 而LinkedList等则没有重写forEach方法对modCount变量进行判断，所以这类在forEach回调内进行删除等操作是正常的。 for(int i =0; i &lt; list.size(); i ++)示例123456for (int i = 0; i &lt; list.size(); i++) &#123; String number = list.get(i); if ("1".equals(number)) &#123; list.remove(number); &#125;&#125; 结果1[2, 3] 能正常运行完毕，并输出当前list内的数据，可以看到字符串“1”已经被删除了。 字节码分析这里字节码相对比较简单，就直接带过，详细的字节码分析放在For-Each小节内。 这里字节码所表示的意思就是和Java源码所直接表示的意思一样，仅仅是循环执行for循环方法体内的代码逻辑，字符串常量“1”与列表内取出的元素做比较，一致则将其从列表中移除。 1javap -c TestForEach &gt; TestForEach.c 得到文件： TestForEach.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Compiled from "TestForEach.java"public class TestForEach &#123; public TestForEach(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return public static void main(java.lang.String[]); Code: 0: new #2 // class java/util/ArrayList 3: dup 4: invokespecial #3 // Method java/util/ArrayList."&lt;init&gt;":()V 7: astore_1 8: aload_1 9: ldc #4 // String 1 11: invokevirtual #5 // Method java/util/ArrayList.add:(Ljava/lang/Object;)Z 14: pop 15: aload_1 16: ldc #6 // String 2 18: invokevirtual #5 // Method java/util/ArrayList.add:(Ljava/lang/Object;)Z 21: pop 22: aload_1 23: ldc #7 // String 3 25: invokevirtual #5 // Method java/util/ArrayList.add:(Ljava/lang/Object;)Z 28: pop 29: iconst_0 30: istore_2 31: iload_2 32: aload_1 33: invokevirtual #8 // Method java/util/ArrayList.size:()I 36: if_icmpge 69 39: aload_1 40: iload_2 41: invokevirtual #9 // Method java/util/ArrayList.get:(I)Ljava/lang/Object; 44: checkcast #10 // class java/lang/String 47: astore_3 48: ldc #4 // String 1 50: aload_3 51: invokevirtual #11 // Method java/lang/String.equals:(Ljava/lang/Object;)Z 54: ifeq 63 57: aload_1 58: aload_3 59: invokevirtual #12 // Method java/util/ArrayList.remove:(Ljava/lang/Object;)Z 62: pop 63: iinc 2, 1 66: goto 31 69: getstatic #13 // Field java/lang/System.out:Ljava/io/PrintStream; 72: aload_1 73: invokevirtual #14 // Method java/io/PrintStream.println:(Ljava/lang/Object;)V 76: return&#125; for( T : Iterable)这个就是增强for循环的写法，除了可以遍历数组，还可以用于遍历所有实现了Iterable 接口的对象。 示例12345for (String number : list) &#123; if ("1".equals(number)) &#123; list.remove(number); &#125;&#125; 结果1234Exception in thread "main" java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909) at java.util.ArrayList$Itr.next(ArrayList.java:859) at TestForEach.main(TestForEach.java:10) 分析可以看到，程序又报了 java.util.ConcurrentModificationException错误。 但是这次提示的错误信息与 Iterable.forEach(Consumer&lt;? super E&gt; action)内的不一样。 从这错误信息来分析，出错的地方是在ArrayList的内部类Itr内的一个方法。但是明明写的代码里面没有用到这个类啊，而且remove()方法内也是没有调用该类，那推测是这增强for循环在遍历时调用的。等同于入下代码： 123456for (Iterator&lt;String&gt; iterator = list.iterator();iterator.hasNext();)&#123; String number = iterator.next(); if ("1".equals(number)) &#123; list.remove(number); &#125; &#125; 通过iterator.hasNext()判断是否还有下个元素，通过iterator.next()取出元素。 而ArrayList#iterator()返回的就是Itr对象。 12345678910/** * Returns an iterator over the elements in this list in proper sequence. * * &lt;p&gt;The returned iterator is &lt;a href="#fail-fast"&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;. * * @return an iterator over the elements in this list in proper sequence */public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125; java.util.ArrayList.Itr 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * An optimized version of AbstractList.Itr */ private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; Itr() &#123;&#125; public boolean hasNext() &#123; return cursor != size; // size是ArrayList的成员变量，用于记录当前列表内存放的元素数量 &#125; @SuppressWarnings("unchecked") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings("unchecked") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; Itr类的逻辑比较简单，变量也有注释进行说明。 其中 cursor：下个元素下标 lastRet：上个返回元素的下标，-1表示没有这个元素 expectedModCount：记录ArrayList内modCount值，用于next()、remove()、forEachRemaining()内做检验 其中next()、remove()方法在执行时，会先调用checkForComodification()进行判断modCount在此遍历期间是否有过改动，改动过（及ArrayList数据源有过结构性改动，比如增加、删除、元素排序等）就会抛出ConcurrentModificationException异常。 因为在for循环体内调用了了remove()方法，所以在next() -&gt; checkForComodification()时会抛出ConcurrentModificationException异常。 字节码分析反编译字节码文件Java内置了一个javap工具，通过该工具就能将 .class文件进行反汇编，得到具体的字节码指令。 通过javap -help就能看到javap工具的所有使用方式。 1234567891011121314151617181920➜ ～ javap -help用法: javap &lt;options&gt; &lt;classes&gt;其中, 可能的选项包括: -help --help -? 输出此用法消息 -version 版本信息 -v -verbose 输出附加信息 -l 输出行号和本地变量表 -public 仅显示公共类和成员 -protected 显示受保护的/公共类和成员 -package 显示程序包/受保护的/公共类 和成员 (默认) -p -private 显示所有类和成员 -c 对代码进行反汇编 -s 输出内部类型签名 -sysinfo 显示正在处理的类的 系统信息 (路径, 大小, 日期, MD5 散列) -constants 显示最终常量 -classpath &lt;path&gt; 指定查找用户类文件的位置 -cp &lt;path&gt; 指定查找用户类文件的位置 -bootclasspath &lt;path&gt; 覆盖引导类文件的位置 其中 `-v参数能导出了整个class文件的详情； -c参数，得到代码相关的JVM指令操作码。 1javap -v TestForEach &gt; TestForEach.v 得到TestForEach.v文件，其中.v后缀是为了和-v参数对应，方便辨别。文件内保存的是文本内容，文件后缀可以随意取。 TestForEach.v 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171Classfile /Users/nht/WorkSpace/java/bytecode/TestForEach.class Last modified 2021-6-10; size 1119 bytes MD5 checksum 3fb9f68c6d74f1a5bf9591aa607bf002 Compiled from "TestForEach.java"public class TestForEach minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #17.#40 // java/lang/Object."&lt;init&gt;":()V #2 = Class #41 // java/util/ArrayList #3 = Methodref #2.#40 // java/util/ArrayList."&lt;init&gt;":()V #4 = String #42 // 1 #5 = Methodref #2.#43 // java/util/ArrayList.add:(Ljava/lang/Object;)Z #6 = String #44 // 2 #7 = String #45 // 3 #8 = Methodref #2.#46 // java/util/ArrayList.iterator:()Ljava/util/Iterator; #9 = InterfaceMethodref #47.#48 // java/util/Iterator.hasNext:()Z #10 = InterfaceMethodref #47.#49 // java/util/Iterator.next:()Ljava/lang/Object; #11 = Class #50 // java/lang/String #12 = Methodref #11.#51 // java/lang/String.equals:(Ljava/lang/Object;)Z #13 = Methodref #2.#52 // java/util/ArrayList.remove:(Ljava/lang/Object;)Z #14 = Fieldref #53.#54 // java/lang/System.out:Ljava/io/PrintStream; #15 = Methodref #55.#56 // java/io/PrintStream.println:(Ljava/lang/Object;)V #16 = Class #57 // TestForEach #17 = Class #58 // java/lang/Object #18 = Utf8 &lt;init&gt; #19 = Utf8 ()V #20 = Utf8 Code #21 = Utf8 LineNumberTable #22 = Utf8 LocalVariableTable #23 = Utf8 this #24 = Utf8 LTestForEach; #25 = Utf8 main #26 = Utf8 ([Ljava/lang/String;)V #27 = Utf8 number #28 = Utf8 Ljava/lang/String; #29 = Utf8 args #30 = Utf8 [Ljava/lang/String; #31 = Utf8 list #32 = Utf8 Ljava/util/ArrayList; #33 = Utf8 LocalVariableTypeTable #34 = Utf8 Ljava/util/ArrayList&lt;Ljava/lang/String;&gt;; #35 = Utf8 StackMapTable #36 = Class #41 // java/util/ArrayList #37 = Class #59 // java/util/Iterator #38 = Utf8 SourceFile #39 = Utf8 TestForEach.java #40 = NameAndType #18:#19 // "&lt;init&gt;":()V #41 = Utf8 java/util/ArrayList #42 = Utf8 1 #43 = NameAndType #60:#61 // add:(Ljava/lang/Object;)Z #44 = Utf8 2 #45 = Utf8 3 #46 = NameAndType #62:#63 // iterator:()Ljava/util/Iterator; #47 = Class #59 // java/util/Iterator #48 = NameAndType #64:#65 // hasNext:()Z #49 = NameAndType #66:#67 // next:()Ljava/lang/Object; #50 = Utf8 java/lang/String #51 = NameAndType #68:#61 // equals:(Ljava/lang/Object;)Z #52 = NameAndType #69:#61 // remove:(Ljava/lang/Object;)Z #53 = Class #70 // java/lang/System #54 = NameAndType #71:#72 // out:Ljava/io/PrintStream; #55 = Class #73 // java/io/PrintStream #56 = NameAndType #74:#75 // println:(Ljava/lang/Object;)V #57 = Utf8 TestForEach #58 = Utf8 java/lang/Object #59 = Utf8 java/util/Iterator #60 = Utf8 add #61 = Utf8 (Ljava/lang/Object;)Z #62 = Utf8 iterator #63 = Utf8 ()Ljava/util/Iterator; #64 = Utf8 hasNext #65 = Utf8 ()Z #66 = Utf8 next #67 = Utf8 ()Ljava/lang/Object; #68 = Utf8 equals #69 = Utf8 remove #70 = Utf8 java/lang/System #71 = Utf8 out #72 = Utf8 Ljava/io/PrintStream; #73 = Utf8 java/io/PrintStream #74 = Utf8 println #75 = Utf8 (Ljava/lang/Object;)V&#123; public TestForEach(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 4: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this LTestForEach; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=4, args_size=1 0: new #2 // class java/util/ArrayList 3: dup 4: invokespecial #3 // Method java/util/ArrayList."&lt;init&gt;":()V 7: astore_1 8: aload_1 9: ldc #4 // String 1 11: invokevirtual #5 // Method java/util/ArrayList.add:(Ljava/lang/Object;)Z 14: pop 15: aload_1 16: ldc #6 // String 2 18: invokevirtual #5 // Method java/util/ArrayList.add:(Ljava/lang/Object;)Z 21: pop 22: aload_1 23: ldc #7 // String 3 25: invokevirtual #5 // Method java/util/ArrayList.add:(Ljava/lang/Object;)Z 28: pop 29: aload_1 30: invokevirtual #8 // Method java/util/ArrayList.iterator:()Ljava/util/Iterator; 33: astore_2 34: aload_2 35: invokeinterface #9, 1 // InterfaceMethod java/util/Iterator.hasNext:()Z 40: ifeq 71 43: aload_2 44: invokeinterface #10, 1 // InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object; 49: checkcast #11 // class java/lang/String 52: astore_3 53: ldc #4 // String 1 55: aload_3 56: invokevirtual #12 // Method java/lang/String.equals:(Ljava/lang/Object;)Z 59: ifeq 68 62: aload_1 63: aload_3 64: invokevirtual #13 // Method java/util/ArrayList.remove:(Ljava/lang/Object;)Z 67: pop 68: goto 34 71: getstatic #14 // Field java/lang/System.out:Ljava/io/PrintStream; 74: aload_1 75: invokevirtual #15 // Method java/io/PrintStream.println:(Ljava/lang/Object;)V 78: return LineNumberTable: line 6: 0 line 7: 8 line 8: 15 line 9: 22 line 18: 29 line 19: 53 line 20: 62 line 22: 68 line 56: 71 line 58: 78 LocalVariableTable: Start Length Slot Name Signature 53 15 3 number Ljava/lang/String; 0 79 0 args [Ljava/lang/String; 8 71 1 list Ljava/util/ArrayList; LocalVariableTypeTable: Start Length Slot Name Signature 8 71 1 list Ljava/util/ArrayList&lt;Ljava/lang/String;&gt;; StackMapTable: number_of_entries = 3 frame_type = 253 /* append */ offset_delta = 34 locals = [ class java/util/ArrayList, class java/util/Iterator ] frame_type = 33 /* same */ frame_type = 250 /* chop */ offset_delta = 2&#125;SourceFile: "TestForEach.java" 其中重点是Constant pool及其下方打括号{}内的方法表集合。 Constant poolConstant pool意为常量池。主要存放的是两大类常量：字面量(Literal)和符号引用(Symbolic References)。字面量类似于java中的常量概念，如文本字符串，final常量等，而符号引用则属于编译原理方面的概念，包括以下三种: 类和接口的全限定名(Fully Qualified Name) 字段的名称和描述符号(Descriptor) 方法的名称和描述符 查看第一个常量池数据： 12345#1 = Methodref #17.#40 // #17 = Class #58 // java/lang/Object#18 = Utf8 &lt;init&gt;#19 = Utf8 ()V#40 = NameAndType #18:#19 // "&lt;init&gt;":()V 这是一个方法定义，指向了第17和第40个常量，以此类推，最终组成了右边注释的内容 1java/lang/Object.&quot;&lt;init&gt;&quot;:()V 表示的是实例构造器。 ()内部是入参，这里为空，表示没有入参。 V表示void，代表没有返回类型。 关于字节码的类型对应如下： 标识字符 含义 B 基本类型byte C 基本类型char D 基本类型double F 基本类型float I 基本类型int J 基本类型long S 基本类型short Z 基本类型boolean V 特殊类型void L 对象类型，以分号结尾，如Ljava/lang/Object; 对于数组类型，每一位使用一个前置的”[“字符来描述，如定义一个java.lang.String[][]类型的维数组，将被记录为”[[Ljava/lang/String;” 方法表集合分析在常量池之后打括号{}内的是对类内部的方法描述。 12340: new #2 // class java/util/ArrayList3: dup4: invokespecial #3 // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V7: astore_1 其中0、3、4表示 new ArrayList(); new: 创建ArrayList对象，并将其引用引用值压入栈顶（栈内：ref） dup：复制栈顶数值并将复制值压入栈顶（栈内：ref ref） invokespecial：调用了构造方法初始化实例并使用了一个引用（栈内：ref） astore_1：弹出栈顶数据，并保存到局部变量表1处。 7：存储到局部变量表1处。 1234 8: aload_1 9: ldc #4 // String 111: invokevirtual #5 // Method java/util/ArrayList.add:(Ljava/lang/Object;)Z14: pop 本组指令表示将字符串“1”添加到列表内。 8:将局部变量表1处的列表压入栈内 9:将字符串“1”压入栈内 11:调用add方法，此时会消耗掉栈内的两个值（将栈顶字符串通过add方法添加到列表内），并压入add方法的Boolean类型的返回结果 14:出栈，将栈顶由11操作压入的值出栈（丢弃） 15～28操作与此一致： 15～21：将字符串“2”加入列表内； 22～28：将字符串“3”加入列表内； 12329: aload_130: invokevirtual #8 // Method java/util/ArrayList.iterator:()Ljava/util/Iterator;33: astore_2 本组表示 Iterator iterator = list.iterator(); aload_1：将局部变量表1处的列表压入栈内 invokevirtual：调用ArrayList.iterator方法获取Iterator对象并压入栈内（ArrayList内获取到的是Itr对象） astore_2：将栈顶的Itr对象保存到局部变量表2处 1234: aload_235: invokeinterface #9, 1 // InterfaceMethod java/util/Iterator.hasNext:()Z 本组表示 ：iterator.hasNext() aload_2:将局部变量表2处的Itr对象压入栈顶 invokeinterface：调用hasNext接口，并将boolean结果压入栈顶 1234540: ifeq 7143: aload_244: invokeinterface #10, 1 // InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object;49: checkcast #11 // class java/lang/String52: astore_3 ifeq：if语句，栈顶内为true这执行下条指令（这里是43）；反之，执行71处指令 43～52:表示调用iterator.next()，并将取到的结果强转成String类型后保存到局部变量表3处 12345678953: ldc #4 // String 155: aload_356: invokevirtual #12 // Method java/lang/String.equals:(Ljava/lang/Object;)Z59: ifeq 6862: aload_163: aload_364: invokevirtual #13 // Method java/util/ArrayList.remove:(Ljava/lang/Object;)Z67: pop68: goto 34 字符串“1”和局部变量表3处的值入栈，调用equals方法后判断栈顶值，true则执行下条指令（这里是62）；反之，执行68处指令，goto 34，跳到34指令处执行，即再次开始判断hasNext。 62～67:将局部变量表3的值从列表内移除。 再执行68处goto指令。 而前面提到的71处指令如下： 123471: getstatic #14 // Field java/lang/System.out:Ljava/io/PrintStream;74: aload_175: invokevirtual #15 // Method java/io/PrintStream.println:(Ljava/lang/Object;)V78: return 表示调用System.out.println将列表数据打印。 return:结束程序。 综上分析，上面的分析过程是正确的。 12345for (String number : list) &#123; if ("1".equals(number)) &#123; list.remove(number); &#125;&#125; 等同于 123456for (Iterator&lt;String&gt; iterator = list.iterator();iterator.hasNext();)&#123; String number = iterator.next(); if ("1".equals(number)) &#123; list.remove(number); &#125; &#125; 特例12345for (String number : list) &#123; if (&quot;2&quot;.equals(number)) &#123; list.remove(number); &#125;&#125; 在使用for( T : Iterable)方式时，有一种特殊用例，会使得遍历时能正常删除，就是删除的是list倒数第二项时。 经过上面的分析，我们只需回看下ArrayList.Itr的其中两个成员方法：ArrayList.Itr.hasNext()和ArrayList.Itr.remove() 以及ArrayList.remove()就可以知道原因了。 ArrayList.Itr 12345678910111213141516public boolean hasNext() &#123; return cursor != size; // size是ArrayList的成员变量，用于记录当前列表内存放的元素数量&#125;public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i];&#125; ArrayList 12345678910111213141516171819202122232425public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; 当Itr.next()取出的是list最后第二项后，成员变量cursor+1后的值等于size-1。 而调用list.remove()（remove() -&gt; fastRemove()）方法后，可以看到–size。 所以此时Itr.cursor == size，Itr.hasNext()返回的是false，直接退出了循环，没有对list的最后一项进行判断。 但是不推荐怎么使用。 其他正确的删除方式除了上面删除几种方式外，还有如下几种正确的方式： 显示使用迭代器12345678910111213141516String number; for (Iterator&lt;String&gt; iterator = list.iterator();iterator.hasNext();)&#123; number = iterator.next(); if ("1".equals(number)) &#123; iterator.remove(); &#125; &#125;或Iterator&lt;String&gt; iterator = list.iterator();while(iterator.hasNext())&#123; number = iterator.next(); if ("1".equals(number)) &#123; iterator.remove(); &#125;&#125; Collection.removeIf(Predicate&lt;? super E&gt; filter)1list.removeIf(number -&gt; number.equals("1")); Collection接口内给出了默认实现： 12345678910111213141516171819202122232425262728293031323334/** * Removes all of the elements of this collection that satisfy the given * predicate. Errors or runtime exceptions thrown during iteration or by * the predicate are relayed to the caller. * * @implSpec * The default implementation traverses all elements of the collection using * its &#123;@link #iterator&#125;. Each matching element is removed using * &#123;@link Iterator#remove()&#125;. If the collection's iterator does not * support removal then an &#123;@code UnsupportedOperationException&#125; will be * thrown on the first matching element. * * @param filter a predicate which returns &#123;@code true&#125; for elements to be * removed * @return &#123;@code true&#125; if any elements were removed * @throws NullPointerException if the specified filter is null * @throws UnsupportedOperationException if elements cannot be removed * from this collection. Implementations may throw this exception if a * matching element cannot be removed or if, in general, removal is not * supported. * @since 1.8 */default boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; Objects.requireNonNull(filter); boolean removed = false; final Iterator&lt;E&gt; each = iterator(); while (each.hasNext()) &#123; if (filter.test(each.next())) &#123; each.remove(); removed = true; &#125; &#125; return removed;&#125; 也是使用迭代器进行删除。 但是Arraylist类重写了该实现，提高了删除效率： 12345678910111213141516171819202122232425262728293031323334353637383940414243@Overridepublic boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; Objects.requireNonNull(filter); // figure out which elements are to be removed // any exception thrown from the filter predicate at this stage // will leave the collection unmodified int removeCount = 0; final BitSet removeSet = new BitSet(size); final int expectedModCount = modCount; final int size = this.size; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; @SuppressWarnings("unchecked") final E element = (E) elementData[i]; if (filter.test(element)) &#123; removeSet.set(i); removeCount++; &#125; &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; // shift surviving elements left over the spaces left by removed elements final boolean anyToRemove = removeCount &gt; 0; if (anyToRemove) &#123; final int newSize = size - removeCount; for (int i=0, j=0; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123; i = removeSet.nextClearBit(i); elementData[j] = elementData[i]; &#125; for (int k=newSize; k &lt; size; k++) &#123; elementData[k] = null; // Let gc do its work &#125; this.size = newSize; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++; &#125; return anyToRemove;&#125; 总结 for( T : Iterable) 完全等同于 1234for (Iterator&lt;T&gt; iterator = list.iterator();iterator.hasNext();)&#123; T number = iterator.next(); //这里执行具体操作 &#125; 能够正常遍历时删除的方式有 for(int i =0; i &lt; list.size(); i ++) 迭代器方式 Collection.removeIf(Predicate&lt;? super E&gt; filter) for( T : Iterable) 或 迭代器内使用List.remove()时，若仅删除最后第二项时，不会抛出异常 参考轻松看懂Java字节码 字节码增强技术探索]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>forEach</tag>
        <tag>for</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黄山攻略]]></title>
    <url>%2F4187858666%2F</url>
    <content type="text"><![CDATA[黄山风景区2020年最新手绘导游地图高清版]]></content>
      <categories>
        <category>旅游</category>
      </categories>
      <tags>
        <tag>旅游</tag>
        <tag>安徽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unlock Music 付费音乐下载格式解锁]]></title>
    <url>%2F2292689392%2F</url>
    <content type="text"><![CDATA[疫情概要1月23日0—24时，31个省（自治区、直辖市）和新疆生产建设兵团报告新增确诊病例80例，其中境外输入病例15例（广东5例，上海3例，山西2例，天津1例，辽宁1例，江苏1例，陕西1例，甘肃1例），本土病例65例（黑龙江29例，河北19例，吉林12例，上海3例，北京2例）；无新增死亡病例；新增疑似病例1例，为境外输入病例（在上海）。 春节将至，疫情反复，大家注意日常防疫，减少不必要外出，外出佩戴口罩。预祝大家过个愉快的春节！ 前言如今因为音乐版权的问题，各大音乐播放平台之间竞争激烈，各家都推出了自己的音乐加密方式，导致付费音乐下载后不能用其他的音乐播放器播放，并且过了会员期后下载的文件在自家的播放器上也是不能播放的（需单曲购买后才支持解锁，支持其他播放器播放）。 车上U盘内的歌曲呢已经快1年没有更新了，趁着现在有QQ音乐会员打算更新一波曲目（感谢京东218会员赠送的1年QQ音乐绿钻豪华会员，鄙人裤腰带都快勒断了是不可能专门买的啦）。结果通过客户端下载下来的文件有部分是被加密过的，仅有少数歌曲是不加密的。这我明显是不能答应的啊。 经过不懈的努力后，终于找到一个开源的解码神奇啊。 开源项目地址：https://github.com/ix64/unlock-music 本篇主要讲述亮点： Unlock Music的使用 站点部署流程整理（太久没弄了，忘了，借这次机会操作一遍） 部署后的地址： 演示地址：https://unlock.nhtzj.com 设备 Mac pro 阿里云服务器(Centos7+Nginx) Mac版QQ音乐下载路径 加密歌曲是放在： /Users/当前登录用户名/Library/Containers/com.tencent.QQMusicMac/Data/Library/Application\ Support/QQMusicMac/iQmc/ 也可通过 下载歌曲 -&gt; 已下载 -&gt; 在下载的歌曲上右键-&gt; 点击 查看本地文件 直接跳转到该目录下。 未加密文件是放在： /Users/当前登录用户名/Music/QQ音乐 也可通过定位到加密文件的方式直接打开这个目录。 Unlock Music 音乐解锁本小节直接从开源项目内的说明文档内抄录而来 若Github下载慢，可点击下方链接下载，从Github下载而来，未做修改。 版本：1.7.2 legacy版本： legacy-1.7.2.tar.gz legacy-1.7.2.zip modern版本: modern-1.7.2.tar.gz modern-1.7.2.zip 源码：unlock-music-1.7.2.zip legacy版本和modern版本为已构建的版本，构建版本和源码的使用可以查看章节 使用方法 功能介绍 在浏览器中解锁加密的音乐文件。 Unlock encrypted music file in the browser. unlock-music项目是以学习和技术研究的初衷创建的，修改、再分发时请遵循License Unlock Music的CLI版本正在开发中。 我们新建了Telegram群组，欢迎加入！https://t.me/unlock_music_chat CLI版本 Alpha 大批量转换建议使用CLI版本 相关的其他项目 特性支持的格式 QQ音乐 (.qmc0/.qmc2/.qmc3/.qmcflac/.qmcogg/.tkm) 。其中.qmc0：标准；.qmc3：HQ高品质；.qmcflac：SQ高品质 写入封面图片 Moo音乐格式 (.bkcmp3/.bkcflac) QQ音乐Tm格式 (.tm0/.tm2/.tm3/.tm6) QQ音乐新格式 (实验性支持) .mflac .mgg 网易云音乐格式 (.ncm) 补全ncm的ID3/FlacMeta信息 虾米音乐格式 (.xm) (测试阶段) 酷我音乐格式 (.kwm) (测试阶段) 酷狗音乐格式 (.kgm) (CLI版本) 其他特性 在浏览器中解锁 拖放文件 在线播放 批量解锁 渐进式Web应用 多线程 使用方法使用已构建版本 从GitHub Release下载已构建的版本 本地使用请下载legacy版本（modern版本只能通过http/https协议访问） 解压缩后即可部署或本地使用（请勿直接运行源代码） 自行构建 环境要求 nodejs npm 获取项目源代码后执行 npm install 安装相关依赖 执行 npm run build 即可进行构建，构建输出为 dist 目录 npm run serve 可用于开发 部署新站点小编这边将解码的站点配置为二级域名：unlock.nhtzj.com 设备 Mac pro 阿里云服务器(Centos7+Nginx) 添加二级域名解析在阿里云域名解析网站添加二级解析域名：unlock.nhtzj.com 添加站点文件 下载modern版本 解压 将文件夹名称modern 改为 unlock，并对内部文件进行了微调 将unlock文件夹上传到服务器根目录/var/www下 ，上传使用scp命令： 1scp -r 本地文件夹路径 服务器登录用户名@服务器IP地址:/var/www 其中-r用于上传/下载文件夹。 如果本地路径和服务器路径交换下，就是从服务器下载 1scp -r 服务器登录用户名@服务器IP地址:/var/www/unlock 本地文件夹路径 授予权限现在我们已经添加的文件，但这些目录结构都为 root 用户所有。如果希望服务器上的普通用户也能够修改 web 目录下的文件，我们可以使用 chown 命令转移目录的所有者： 1sudo chown –R $USER:$USER /var/www/ 当你提交上述 chown 命令时，$USER 变量将会取值为当前登录服务器的用户。这样，我们的普通用户就取得了 www 子目录的所有权。 此外，我们还需要对这里的目录权限做一点修改，确保对一般的 web 目录及其内部的子目录和文件的读取都是被允许的，这样，网页才能正常地为访问者提供服务： 1sudo chmod –R 755 /var/www 现在你的服务器应该已经取得了为向 web 站点访问者提供内容所需的权限，并且服务器上的用户现在应该能够在恰当的文件夹下创建内容 添加新站点配置文件nginx的配置路径是在：/etc/nginx/ 进入后，目录如下： 1234567891011121314151617181920# cd /etc/nginx/# lltotal 68drwxr-xr-x 2 root root 4096 Jan 23 20:10 conf.ddrwxr-xr-x 2 root root 4096 Mar 6 2018 default.d-rw-r--r-- 1 root root 1077 Mar 6 2018 fastcgi.conf-rw-r--r-- 1 root root 1077 Mar 6 2018 fastcgi.conf.default-rw-r--r-- 1 root root 1007 Mar 6 2018 fastcgi_params-rw-r--r-- 1 root root 1007 Mar 6 2018 fastcgi_params.default-rw-r--r-- 1 root root 2837 Mar 6 2018 koi-utf-rw-r--r-- 1 root root 2223 Mar 6 2018 koi-win-rw-r--r-- 1 root root 3957 Mar 6 2018 mime.types-rw-r--r-- 1 root root 3957 Mar 6 2018 mime.types.default-rw-r--r-- 1 root root 2588 Oct 17 2018 nginx.conf-rw-r--r-- 1 root root 2656 Mar 6 2018 nginx.conf.default-rw-r--r-- 1 root root 636 Mar 6 2018 scgi_params-rw-r--r-- 1 root root 636 Mar 6 2018 scgi_params.default-rw-r--r-- 1 root root 664 Mar 6 2018 uwsgi_params-rw-r--r-- 1 root root 664 Mar 6 2018 uwsgi_params.default-rw-r--r-- 1 root root 3610 Mar 6 2018 win-utf 其中目录conf.d就是添加新站点配置的地方。 而nginx.conf为nginx的总配置文件，文件打开后可以看到如下，将conf.d目录下所有conf格式的文件都加载进来 1include /etc/nginx/conf.d/*.conf; 所以在conf.d内创建文件 unlock.conf 12345678910111213141516server &#123; #listen 80; root /var/www/unlock; # change to your dir server_name unlock.nhtzj.com; # change to your service name(domain) index index.html index.htm; location / &#123; # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; &#125; error_log /var/log/nginx/unlock.nhtzj.com_error.log; error_page 404 /404.html; location = /40x.html &#123; &#125;&#125; 重启nginx1systemctl restart nginx 现在可以在浏览器输入自己的域名查看效果了 http://unlock.nhtzj.com 添加ssl证书给新加的二级域名添加ssl证书。 由于小编之前已经创建过证书了所以这里就是给证书添加新域名的操作 由于新增时需要将证书内原有的域名信息也要加上，所以 查询原有证书信息 1certbot certificates 将查询到的Domains信息取出，并用逗号分隔 1sudo certbot --expand -d blog.nhtzj.com,www.nhtzj.com,unlock.nhtzj.com 具体示例可查看文章 Centos7使用certbot获取ssl证书#常用命令 现在可以在浏览器输入自己的域名查看效果了 https://unlock.nhtzj.com 参考CentOS 7 Apache 多端口部署 Web Apps 指南 unlock-music]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>音乐解锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 横竖屏（手动+自动）]]></title>
    <url>%2F2134946563%2F</url>
    <content type="text"><![CDATA[疫情概要8月1日0—24时，31个省（自治区、直辖市）和新疆生产建设兵团报告新增确诊病例49例，其中境外输入病例16例（四川4例，山东3例，湖北3例，广东2例，陕西2例，上海1例，福建1例），本土病例33例（新疆30例，辽宁3例）；无新增死亡病例；无新增疑似病例。 前言新的效果涂上，手机在竖屏界面上没有点击触发App切换到横屏的功能按钮，但是却又有横屏的效果图，并且可以通过返回按钮退出横屏。经过一番思考后有了可行的方案。本篇记录该需求的具体实现过程。如要查看关于横竖屏的详细设置介绍，请查看文章 Android 动态切换全屏横屏 思路使用手机传感器检测设备方向 + 手动/自动设置屏幕方向 关于设备方向的监听，一般想到的是SensorManager，但系统在SDK3内就添加了OrientationEventListener抽象类来帮助监听设备方向。 再通过setRequestedOrientation (int requestedOrientation)来强制指定方向。 详细过程OrientationEventListenerpublic abstract class OrientationEventListenerextends Object java.lang.Object ↳ android.view.OrientationEventListener Helper class for receiving notifications from the SensorManager when the orientation of the device has changed. 即：监听设备方向的帮助类。 虽然是以 Listener结尾，但它不是接口类型，是抽象类，内部封装了 SensorManager相关的逻辑，用于监听设备当前角度，通过onOrientationChanged(int orientation)方法返回。 注：记得调用OrientationEventListener.disable()取消监听（注册），避免内存泄露。若需反复监听、取消操作，可通过OrientationEventListener.enable()、OrientationEventListener.disable()使监听有效/无效。 OrientationEventListener相关实现类如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * 自定义工具类 * &lt;p&gt; * 实时的检测用户屏幕的位置改变，做到 重力感应 与 全屏/半屏按钮 逻辑的互容 */public class OrientationDetector extends OrientationEventListener &#123; private WeakReference&lt;Activity&gt; mWeakReferenceActivity; /** * 实时记录用户手机屏幕的位置 */ private int mOrientation = -1; public OrientationDetector(Activity activity) &#123; super(activity); mWeakReferenceActivity = new WeakReference&lt;&gt;(activity); &#125; @Override public void onOrientationChanged(int orientation) &#123; //判null if (mWeakReferenceActivity.get() == null || mWeakReferenceActivity.get().isFinishing()) &#123; return; &#125; //记录用户手机上一次放置的位置 int mLastOrientation = mOrientation; if (orientation == OrientationEventListener.ORIENTATION_UNKNOWN) &#123; //手机平放时，检测不到有效的角度 //重置为原始位置 -1 mOrientation = -1; return; &#125; /** * 只检测是否有四个角度的改变 */ if (orientation &gt; 350 || orientation &lt; 10) &#123; //0度，用户竖直拿着手机 mOrientation = 0; &#125; else if (orientation &gt; 80 &amp;&amp; orientation &lt; 100) &#123; //90度，用户右侧横屏拿着手机 mOrientation = 90; &#125; else if (orientation &gt; 170 &amp;&amp; orientation &lt; 190) &#123; //180度，用户反向竖直拿着手机 mOrientation = 180; &#125; else if (orientation &gt; 260 &amp;&amp; orientation &lt; 280) &#123; //270度，用户左侧横屏拿着手机 mOrientation = 270; &#125; //如果用户关闭了手机的屏幕旋转功能，不再开启代码自动旋转了，直接return try &#123; /** * 1 手机已开启屏幕旋转功能 * 0 手机未开启屏幕旋转功能 */ if (Settings.System.getInt(mWeakReferenceActivity.get().getContentResolver(), Settings.System.ACCELEROMETER_ROTATION) == 0) &#123; return; &#125; &#125; catch (Settings.SettingNotFoundException e) &#123; e.printStackTrace(); &#125; //当检测到用户手机位置距离上一次记录的手机位置发生了改变，开启屏幕自动旋转 if (mLastOrientation != mOrientation) &#123; mWeakReferenceActivity.get().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED); &#125; &#125;&#125; setRequestedOrientationChange the desired orientation of this activity. If the activity is currently in the foreground or otherwise impacting the screen orientation, the screen will immediately be changed (possibly causing the activity to be restarted). Otherwise, this will be used the next time the activity is visible. Parameters requestedOrientation int: An orientation constant as used in ActivityInfo#screenOrientation. Value is android.content.pm.ActivityInfo.SCREEN_ORIENTATION_UNSET, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED, ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE, ActivityInfo.SCREEN_ORIENTATION_PORTRAIT, ActivityInfo.SCREEN_ORIENTATION_USER, ActivityInfo.SCREEN_ORIENTATION_BEHIND, ActivityInfo.SCREEN_ORIENTATION_SENSOR, ActivityInfo.SCREEN_ORIENTATION_NOSENSOR, ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE, ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT, ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE, ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT, ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR, ActivityInfo.SCREEN_ORIENTATION_USER_LANDSCAPE, ActivityInfo.SCREEN_ORIENTATION_USER_PORTRAIT, ActivityInfo.SCREEN_ORIENTATION_FULL_USER, or ActivityInfo.SCREEN_ORIENTATION_LOCKED 即：改变活动方向。 另外配合使用setRequestedOrientation(int requestedOrientation)进行强制横竖屏切换 完整示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class SimpleActivity extends AppCompatActivity &#123; private static final String TAG = "SimpleActivity"; private OrientationDetector orientationDetector; private TextView tv; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.w(TAG, "onCreate: "); setContentView(R.layout.activity_simple); tv = findViewById(R.id.tv); tv.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.w(TAG, "onClick: " + getResources().getConfiguration().orientation); if (getResources().getConfiguration().orientation == ActivityInfo.SCREEN_ORIENTATION_USER) &#123; tv.setText("我是竖屏"); //切竖屏 setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); &#125; else &#123; tv.setText("我是横屏"); //切横屏 setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE); &#125; &#125; &#125;); orientationDetector = new OrientationDetector(this); &#125; @Override protected void onResume() &#123; super.onResume(); orientationDetector.enable(); &#125; @Override protected void onPause() &#123; super.onPause(); orientationDetector.disable(); &#125; @Override public void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig); Log.w(TAG, "onConfigurationChanged: " + newConfig); if (newConfig.orientation == ActivityInfo.SCREEN_ORIENTATION_USER) &#123; tv.setText("我是横屏"); &#125; else &#123; tv.setText("我是竖屏"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>android</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>横竖屏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础不学好，加班跑不了（一）之ImageView]]></title>
    <url>%2F496990873%2F</url>
    <content type="text"><![CDATA[题外话今天看到一篇文章，提到美国现总统唐纳德·特朗普和前总统贝拉克·侯赛因·奥巴马在任职期间对中国的影响，提到特朗普政府对中国是烫水煮青蛙，而奥巴马政府是温水煮青蛙。烫水虽然暂时是痛苦的，但能让我们立马清醒过来。美国政府自然是为美国人民考虑的。郑强教授也提到过，中国是个神奇的国家，越是对其搞封锁，反倒是越能干出花样来。 前言本篇主要记录在开发过程中由于部分基础不扎实导致的一些“加班”情况（浪费了太多时间啦）。 关于ImageView组件方面的一些细节就记录在本篇内。 setColorFilterImageView#setColorFilter(int color, PorterDuff.Mode mode)) setColorFilter()用于给ImageView内容进行着色（tint），即改变原有内容的颜色。 错误而小编一开始写的代码如下： 123456ImageView iv;...iv.setBackgroundResource(R.drawable.ic_setting);iv.setColorFilter(ContextCompat.getColor(this, R.color.colorPrimary), PorterDuff.Mode.SRC_IN); 结果没有setColorFilter()没有起到效果。 原因查看源码得知： ImageView.setColorFilter()方法是作用在成员变量mDrawable上的，即xml内ImageView标签的android:src属性 setBackgroundResource()方法是设置背景的，作用在ImageView的父类View的成员变量mBackground上的。 所以总结下来就是上述无效果的代码是因为设置到了两个对象上，才会导致最终没有效果。 修改综上所述，修改方式有两种： 图片资源和着色都设置到ImageView背景上 12345Drawable drawable = ContextCompat.getDrawable(this, R.drawable.ic_setting);if (drawable != null) &#123; drawable.setColorFilter(ContextCompat.getColor(this, R.color.colorPrimary), PorterDuff.Mode.SRC_IN); iv.setBackgroundDrawable(drawable);&#125; 图片资源和着色都设置到ImageView内容上 12iv.setImageResource(R.drawable.ic_setting);iv.setColorFilter(ContextCompat.getColor(this, R.color.colorPrimary), PorterDuff.Mode.SRC_IN); 源码分析setColorFilter()有3个重载方法，具体如下源码： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Sets a tinting option for the image. * * @param color Color tint to apply. * @param mode How to apply the color. The standard mode is * &#123;@link PorterDuff.Mode#SRC_ATOP&#125; * * @attr ref android.R.styleable#ImageView_tint */public final void setColorFilter(int color, PorterDuff.Mode mode) &#123; setColorFilter(new PorterDuffColorFilter(color, mode));&#125;/** * Set a tinting option for the image. Assumes * &#123;@link PorterDuff.Mode#SRC_ATOP&#125; blending mode. * * @param color Color tint to apply. * @attr ref android.R.styleable#ImageView_tint */@RemotableViewMethodpublic final void setColorFilter(int color) &#123; setColorFilter(color, PorterDuff.Mode.SRC_ATOP);&#125;/** * Apply an arbitrary colorfilter to the image. * * @param cf the colorfilter to apply (may be null) * * @see #getColorFilter() */public void setColorFilter(ColorFilter cf) &#123; if (mColorFilter != cf) &#123; mColorFilter = cf; mHasColorFilter = true; mColorMod = true; applyColorMod(); invalidate(); &#125;&#125; 可以看到最终都调用到了 setColorFilter(ColorFilter cf)方法上。setColorFilter(ColorFilter cf)内部又会调用applyColorMod()。其代码如下，可以看到最总是调用到了mDrawable.setColorFilter(mColorFilter)上。 12345678910111213private void applyColorMod() &#123; // Only mutate and apply when modifications have occurred. This should // not reset the mColorMod flag, since these filters need to be // re-applied if the Drawable is changed. if (mDrawable != null &amp;&amp; mColorMod) &#123; mDrawable = mDrawable.mutate(); if (mHasColorFilter) &#123; mDrawable.setColorFilter(mColorFilter); &#125; mDrawable.setXfermode(mXfermode); mDrawable.setAlpha(mAlpha * mViewAlphaScale &gt;&gt; 8); &#125;&#125; 而mDrawable通过查看源码内赋值的地方，可以确定为ImageView显示的内容（非背景）。因为源码内setImageBitmap、setImageDrawable、setImageResource、setImageURI、setImageIcon都是直接或间接调用了updateDrawable方法，其内部会将显示内容赋值给mDrawable。 123456789101112131415161718192021222324252627282930313233343536373839404142private void updateDrawable(Drawable d) &#123; if (d != mRecycleableBitmapDrawable &amp;&amp; mRecycleableBitmapDrawable != null) &#123; mRecycleableBitmapDrawable.setBitmap(null); &#125; boolean sameDrawable = false; if (mDrawable != null) &#123; sameDrawable = mDrawable == d; mDrawable.setCallback(null); unscheduleDrawable(mDrawable); if (!sCompatDrawableVisibilityDispatch &amp;&amp; !sameDrawable &amp;&amp; isAttachedToWindow()) &#123; mDrawable.setVisible(false, false); &#125; &#125; //看这里哦 mDrawable = d; if (d != null) &#123; d.setCallback(this); d.setLayoutDirection(getLayoutDirection()); if (d.isStateful()) &#123; d.setState(getDrawableState()); &#125; if (!sameDrawable || sCompatDrawableVisibilityDispatch) &#123; final boolean visible = sCompatDrawableVisibilityDispatch ? getVisibility() == VISIBLE : isAttachedToWindow() &amp;&amp; getWindowVisibility() == VISIBLE &amp;&amp; isShown(); d.setVisible(visible, true); &#125; d.setLevel(mLevel); mDrawableWidth = d.getIntrinsicWidth(); mDrawableHeight = d.getIntrinsicHeight(); applyImageTint(); applyColorMod(); configureBounds(); &#125; else &#123; mDrawableWidth = mDrawableHeight = -1; &#125;&#125;]]></content>
      <categories>
        <category>android</category>
        <category>系统组件</category>
      </categories>
      <tags>
        <tag>系统组件</tag>
        <tag>ImageView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发8年，阿里、百度一面惨被吊打！我是否应该转行了？]]></title>
    <url>%2F536712598%2F</url>
    <content type="text"><![CDATA[转自：https://yq.aliyun.com/articles/754207 背景 2020年1月5号，朋友辞去了北京一家小创公司Android开发的工作，准备春节过后寻找新的工作的时候，突然遇到了新冠疫情的爆发，至今赋闲在家。昨天接到同行好友的电话，要和我聊聊天。告诉我再找不到工作就考虑转行了！ 话语间无不感叹安卓有点强弩之末的味道！聊天过程中，朋友也顺带分享了一波阿里饿了么、百度Android岗的面经。我也帮他内推了几份工作岗位，却因为技术欠缺和经验不足等问题被友好的回绝了！ 饿了么Android岗一面1：双亲委托机制？2：插件化原理？3：垃圾回收机制及其优缺点？4：PathClassLoader和DexClassLoader区别？5：说下Binder？6：Android旋转屏幕后Activity生命周期，Bundle是存储在哪儿的？7：事件分发机制？8：Handler实现？9：Java内存？10：OkHttp设计模式？11：算法。 Http和Https的区别HashMap的具体实施原理，HashMap和Hashset的区别Java的垃圾回收机制JVM的原理及线上调优string,stringbulider,stringbuffer的区别Java的设计模式在白纸上手写二分法排序算法，这道题我在lintcode上面做过原题有哪些可以保持进程同步的方法如何避免死锁常见的数据结构有哪些leetcode 原题：查找单链表中倒数第K个节点的算法，面试官要求手写 百度Android岗一面1：算法：寻找出现超过一半的数字？2：HashMap原理？3：热更新原理？4：AstncTask+HttpClient 与 AsyncHttpClient有什么区别？5：Https握手过程？6：RecycleView原理？7：RecycleView的使用？8：Hybrid通信原理是什么，有做研究吗？9：ListView图片加载错乱的原理和解决方案？10：对称加密与非对称加密？11：TCP、UDP差别？12：TCP保证可靠的手段？ 初级、中级 Android 工程师可能因离职而失业吗？针对朋友找工作难的问题，我特意咨询了我在腾讯负责面试的朋友，为何Android开发普遍感觉找工作难。最后我们得出的结论基本一致：供需极度的不平衡。 这段时间他都在帮部门招人，在拉钩上也挂了JD，一个多月的时间收到的简历估计有几百份，他发起了面试的不超过5个，最后硬着头皮递上去1个还被刷了。 可问题就在这里，据他反馈大公司都在招Android开发，很多部门还非常着急，但就是招不到合适的人。别跟他说现在做Android的人很多，质量是关键，数量一点意义都没有。每年池子里的人就那么多，一份好的简历出来不止公司之间，部门之间甚至是部门内都在抢，但这批人之外，绝大部分人的简历能占用的时间不会超过5秒。 以前我们沟通时他就提到过这个问题，在现在这个阶段，公司之间的技术鸿沟已经非常明显，开发者身在其中，也因为自身学习能力，环境，项目等等的差别，技术上的差距越拉越大，造成了工作几年之后的两级分化，并且这种差距的拉开不是靠自己的努力就能弥补的。 我这个Android开发八年的朋友，离职后缺乏大型项目经验，至今未找到合适的工作！属于一个典型温水煮青蛙的案例！ Android学习路线指南那面对这种情况，作为开发者，我们能做的是什么？最基本的，脱离舒适区，不停磨练自己的技术。 工作前三年是职业生涯中成长最快的几年，在这段时间里你会充满激情，做事专注，也容易养成良好的习惯。在大公司有些同学在前三年中就快速成为某一个领域的技术专家，有些同学也可能止步不前。接下来和大家一起探讨下如何在三年内快速成长为一名技术专家。 目录学习方法1：掌握良好的学习心态2：掌握系统化的学习方法3：知识如何内化成能力4：广度和深度的选择 1.掌握良好的学习心态 空杯心态首先要有空杯的学习心态，而不是傲娇自满，故步自封，空杯子才可以装下更多的东西。首先要学会取百家之长，带着欣赏的眼光看团队的同事或学校的同学，欣赏每位同事或同学的优点，然后吸取他们的优点，每个同事都有其擅长的能力，比如有的同事技术能力强，那么可以观察下他如何学习的（或者找他请教学习方法），有的同学擅长解决线上问题，那么观察他是如何解决线上问题的，解决思路是什么？如果他解决不了时，他是如何寻求帮助。有的同学擅长使用IDE或MAC的快捷键，那么可以向他学习提高工作效率。有的同学能快速理解业务知识，观察他是如何做到的，自己如何达到他的程度。沟通能力，解决问题能力以及规划能力都可以向同事学习。 坚持学习有的同学可能工作了五年，但是学习的时间可能一年都不到。学技术不能急于求成，只要学习方法正确，量变一定会引起质变。 2.掌握系统化的学习方法如果学习到的知识不成体系，那么遇到问题时就会非常难解决。有些同学会出现这些情况，比如编码时遇到问题百度搜索，如果百度上找不到答案，这个问题就解决不了。再比如，在开发中要用到某个技术点，就学习下API，程序调通后就不再深入研究，浅尝辄止，如果程序遇到其他问题也不知道如何解决。 以上情况我认为叫点状学习。遇到一个问题，解决一个问题，需要一项技术，学习一项技术。那么如何由点到面，由面到体，形成系统化学习呢。 首先要确定学习的知识领域，需要达成的学习目标，针对目标制定学习计划，就像你要写一本书一样，先把目录写出来，然后根据目录上的知识点逐步去学习，最后把这些知识点关联起来，形成一个系统化的知识体系。学习的时候，可以制定一个计划，以周为单位，比如第一周学什么，第二周学什么。 比如我们Android开发，学习进阶路线是： 3.知识如何内化成能力成长必须经历一个步骤，就是把知识内化成能力。知识是用脑记住的，能力是用手练习出来的。在工作的几年里，我们可能看过很多书，听过很多技术讲座和视频，但是通过听和看只是让你能记住这些知识，这些知识还不能转换成你的能力。 听和看只是第一步，更重要的是实践，通过刻意练习把听到和看到的知识内化成你的能力。 刻意练习，就是有目的的练习，先规划好，再去练习。 4.广度和深度的选择技术人员的学习路径有两个维度，深度和广度。很多程序员都有这个疑问，是先深后广，还是先广后深呢？ 通过这么多年的学习和思考，我的建议先深后广，因为当技术学到一定深度后，就会有触类旁通的能力，自己掌握的广度也自然有了深度。但是在实际学习过程中，深度和广度相互穿插着学习，比如学习并发编程时，首先学习JDK源码，然后学进去之后，开始看JVM源码，最后看CPU架构，在技术点逐渐深度研究的过程中，广度也得到了完善。 所以无论哪种学习方式，学习态度才是最重要的，在广度学习的时候有深入研究的态度就能达到一定的深度，在深度学习的时候，主动学习相关的技术点，广度也得到拓宽。]]></content>
      <categories>
        <category>android</category>
        <category>转行</category>
      </categories>
      <tags>
        <tag>转行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020大厂最新常见面试题-Java]]></title>
    <url>%2F1230782228%2F</url>
    <content type="text"><![CDATA[转自JavaGuide读者圈 Java Java 基础这部分一些简单的问题就直接没有放上来。 基础： Java 反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？ 谈谈对 Java 注解的理解，解决了什么问题？ 内部类了解吗？匿名内部类了解吗？ BIO和NIO区别,4核cpu，100个http连接，用BIO和NIO分别需要多少个线程 假如我们需要存500个数需要多大的HashMap？ HashMap的负载因子。 jvm: jvm 内存结构 jvm 调优参数 什么是类加载？ 何时类加载？ java的类加载流程？ 知道哪些类加载器。类加载器之间的关系？ 类加载器之间的关系？ 类加载器的双亲委派 （结合tomcat说一下双亲委派） 为什么需要双亲委派 Java内存模型 栈中存放什么数据，堆中呢？ 大对象放在哪个内存区域 堆区如何分类 垃圾回收有哪些算法 GC的全流程 GC中老年代用什么回收方法？ 多线程： Java线程池有哪些参数？阻塞队列有几种？拒绝策略有几种？ 死锁 设计模式： 阅读Spring源码的时候什么设计模式最让你影响深刻？如何使用？ 单例模式，单例模式的使用场景 观察者模式，观察者模式的使用场景 Spring spring boot和spring的区别 ioc 和 aop(ioc流程、aop实现原理)、spring aop异常处理、当一段代码被try catch后再发生异常时，aop的异常通知是否执行，为什么？ spring bean的生命周期说一下 spring data jpa底层是什么？ hibernate和mybatis区别 spring boot 过滤器 spring boot 拦截器 Spring动态代理默认用哪一种 写出spring jdk动态代理的实现。 画出spring boot处理一个http请求的全过程 推荐 手写实现Spring核心功能： https://github.com/jinzzzzz/spring-demo 权限认证 认证 (Authentication) 和授权 (Authorization)的区别是什么？ 什么是Cookie ? Cookie的作用是什么?如何在服务端使用 Cookie ? Cookie 和 Session 有什么区别？如何使用Session进行身份验证？ 如果没有Cookie的话Session还能用吗？ 为什么Cookie 无法防止CSRF攻击，而token可以？ 什么是 Token?什么是 JWT?如何基于Token进行身份验证？ 什么是OAuth 2.0？ 什么是SSO(单点登录) 这部分问题答案整理在了这里：https://snailclimb.gitee.io/javaguide/#/docs/system-design/authority-certification/basis-of-authority-certification 微服务/分布式 为什么要网关？ 限流的算法有哪些？ 为什么要分布式 id ？分布式 id 生成策略有哪些？ 了解RPC吗？有哪些常见的 RPC 框架？ 如果让你自己设计 RPC 框架你会如何设计？ Dubbo 了解吗？Spring Cloud 了解吗？ 数据库 非关系型数据库和关系型数据库的区别？ 事务的四大特性 MySQL 事务隔离级别？默认是什么级别？ 乐观锁与悲观锁的区别 数据库两种存储引擎的区别 最左前缀匹配原则及它的原因 大表优化的思路 where和having的区别 分库分表 explain 命令 索引 如何加快数据库查询速度 聚集索引和非聚集索引的区别 什么时候不该使用索引？ 索引底层的数据结构？ B+树做索引比红黑树好在哪里？ 6. Redis: 项目中 redis 是怎么用的？解决了什么问题？ 说一下有缓存情况下查询的流程以及有缓存情况下修改的流程。 redis有哪些数据结构 redis内存满了怎么办 redis内存淘汰算法除了lru还有哪些 分布式缓存可能出现的问题 缓存穿透问题 网络 计算机网络的一些常见状态码 ping 所使用的协议 TCP的三次握手与四次挥手的内容 TCP为什么连接是三次握手而断开是四次握手 TCP与UDP的区别及使用场景 一次完整的HTTP请求所经的步骤 http 如何保存登录信息(没太搞懂意思) Cookie 和 Session的关系 算法和数据结构算法 LRU 算法了解吗？你能实现一个吗？ 写排序算法（快排、堆排） 数据结构 布隆过滤器了解吗？ 设计题 假如有10亿个数，只有一个重复，内存只能放下5亿个数，怎么找到这个重复的数字？ 如何设计一个秒杀系统（服务端、数据库、分布式）？分布式系统的设计？ 有一个服务器专门接收大量请求，怎么设计？ 如果让你自己设计 RPC 框架你会如何设计？ 怎么快速出现一个stackoverflow错误？ 其他问题 自我介绍。 说说你的项目中的亮点有哪些。 画一下你的项目的架构图。 Restful 了解吗？简单说一下自己对它的认识，如果我要返回一个 boolean 类型的数据怎么办？ 经验总结 多面试，不要害怕失败，多总结经验。 尽早准备，不论是找工作前、面试前还是面试后。 熟悉自己的简历。 电话和视频面试很平常，面试前提前准备一下。 坚持！offer 虽然可能会迟到，但是只要不放弃，就一定不会缺席。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 优秀内容收集]]></title>
    <url>%2F622731706%2F</url>
    <content type="text"><![CDATA[前言本篇章主要记录从各方收集来的优秀篇章， 主要来源： JavaGuide读者圈 面试字节跳动 抖音后端 一二三面面经（已意向书） 何人听我楚狂声 2020大厂最新常见面试题 项目相关： 1、你觉得项目里给里最大的挑战是什么？遇到了什么问题？如何解决的？从中学到了什么？ 2、项目的架构图能画一下不？ 数据库: 3、讲一下乐观锁和悲观锁; 4、说一下MVCC 5、说一聚簇索引和非聚簇索引的有什么不同 6、关于索引的各种轰炸 JVM： 7、 讲一下JVM的内存结构（还问了每个区域的调优配置参数，我蒙了~~~） ~~ 8、Minor gc 和 Full gc 的区别，详细介绍 9、各种垃圾回收算法和回收器，说出自己的理解 10、zgc ？？？zgc vs g1？？? 我懵逼了~~~ 多线程： ~~ 11、ReetrantLock和synchronized的区别 12、AQS 除了这些还问了 Spring AOP和IOC的底层实现、HashMap的底层实现等非常常见的问题，这里就不多提了~~ Java学习路线零基础如何系统学习Java Web？ 算法类开源项目 CS-Notes：这个开源项目不是单一关注算法的仓库，它是一个大的集合，包括了技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计等知识。GitHub - CyC2018/CS-Notes: 技术面试必备基础知识、Leetcode、计算机… LeetCodeAnimation]:边看动画变学算法的话。GitHub - MisterBooo/LeetCodeAnimation: Demonstrate… leetcode：多种编程语言实现 LeetCode、《剑指 Offer（第 2 版）》、《程序员面试金典（第 6 版）》题解。GitHub - doocs/leetcode: 😏 LeetCode solutions in a… LeetCode-Solution-in-Good-Style:: https://github.com/liweiwei1419/LeetCode-Solution-… GitHub - wolverinn/Waking-Up: 计算机基础（计算机网络/操作系统/数据库/Git…）面试问题全面总结，包含详细的follow-up question以及答案；全部采用【问题 追问 答案】的形式，即拿即用，直击互联网大厂面试 ；可用于模拟面试、面试前复习、短期内快速备战面试…（计算机基础（计算机网络/操作系统/数据库/Git…）面试问题全面总结，包含详细的follow-up question以及答案；全部采用【问题+追问+答案】的形式，即拿即用，直击互联网大厂面试🚀；可用于模拟面试、面试前复习、短期内快速备战面试…） 应届生后端(偏Java)学习指南 GitHub - kamranahmedse/developer-roadmap: Roadmap … (Github上很火的web开发人员学习路线，有中文翻译的版本) GitHub - xingshaocheng/architect-awesome: 后端架构师技术图… (后端架构师技术图谱！对于后端的知识体系涵盖的很全，非常适合作为整个后端学习可以参考的路线) GitHub - hollischuang/toBeTopJavaer: To Be Top Jav… (Java工程师成神之路！阿里巴巴技术专家开源的 Java 学习知识体系，内容巨多，需要筛选出比较重要的部分) GitHub - Snailclimb/JavaGuide: 【Java学习 面试指南】 一份涵盖大… (【Java学习+面试指南】 一份涵盖大部分Java程序员所需要掌握的核心知识。) 爬虫集合GitHub - facert/awesome-spider: 爬虫集合 美团点评技术年货【后台篇】：http://dpurl.cn/DPm3hdo 【算法篇】：http://dpurl.cn/gIIjhRw 【大数据篇】：http://dpurl.cn/Lb7j5xA 【前端篇】：http://dpurl.cn/Xy6IOU4 【学术论文篇】：http://dpurl.cn/4KE72hn 【2019美团点评技术文章合辑】：http://dpurl.cn/9zvkFYe 美团技术团队的博客在这里：美团技术团队 docsify搭建文档类型网站视频教程地址：https://www.bilibili.com/video/BV1xz4y1X7Xo/。 docsify的官网教程的也很详细了，地址在这里：docsify 。 演示内容的素材在这里：GitHub - Snailclimb/docsify-demo: 手把手教你搭建一个文档类型的网站… 最终效果展示地址：docsify-demo 权限管理框架艿艿的 《Spring Boot 安全框架 Spring Security 入门》：芋道 Spring Boot 安全框架 Spring Security 入门 | 芋道源码 —— 纯源码解析博客 Guide的《从零入门 ！Spring Security With JWT（含权限验证）后端部分代码。》：GitHub - Snailclimb/spring-security-jwt-guide: 从零入门 ！Spring Security With JWT（含权限验证）后端部分代码。 江南一点雨的Spring Security 系列教也很不错： https://www.javaboy.org/categories/Spring-Security/ 线程不聊原理，拿来即用的线程池最佳实践 Redis相关优质学习资源推荐书籍/专栏： 《Redis 实战》：如果你想了解 Redis 的一些概念性知识的话，这本书真的非常不错。 《Redis 设计与实现》：深入学习 Redis 必看。 《Redis 深度历险：核心原理与应用实践》 ：通俗的语言带你学会Redis。 文章： 缓存那些事-美团技术团队：缓存那些事 - 美团技术团队 JavaGuide-redis专栏：GitHub - Snailclimb/JavaGuide: 「Java学习 面试指南」一份涵盖大部分Java程序员所需要掌握的核心知识。 大厂面试！我和面试官之间关于Redis的一场对弈！：https://sourl.cn/j4Hbr9 【面试】吃透了这些Redis知识点，面试官一定觉得你很NB（干货 | 建议珍藏）:https://sourl.cn/xFTW8n 3w字深度好文|Redis面试全攻略，读完这个就可以和面试官大战几个回合了：3w字深度好文|Redis面试全攻略，读完这个就可以和面试官大战几个回合了 - 掘金 【求锤得锤的故事】Redis锁从面试连环炮聊到神仙打架。:【求锤得锤的故事】Redis锁从面试连环炮聊到神仙打架。 慕课网-一站式学习Redis 从入门到高可用分布式实践]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DialogFragment 监听外部点击事件]]></title>
    <url>%2F14209615%2F</url>
    <content type="text"><![CDATA[疫情概要国内疫情6月20日0—24时，31个省（自治区、直辖市）和新疆生产建设兵团报告新增确诊病例26例，其中境外输入病例1例（在福建），本土病例25例（北京22例，河北3例）；无新增死亡病例；新增疑似病例3例，均为本土病例（均在北京）。 国际疫情世界卫生组织20日公布的最新数据显示，中国以外新冠确诊病例达到8440072例。 世卫组织每日疫情报告显示，截至欧洲中部时间20日10时（北京时间16时），中国以外新冠确诊病例较前一日增加138950例，达到8440072例；中国以外死亡病例较前一日增加6271例，达到452328例。 全球范围内，新冠确诊病例较前一日增加138980例，达到8525042例；死亡病例较前一日增加6271例，达到456973例。 前言本篇主要记录使用DialogFragment实现的弹框，对点击非内容区域事件的监听和控制。 这个需求在着手实现之初，就断定是需要从事件的分发机制处展开的。 实现过程分析DialogFragment 显示Dialog的具体流程为： FragmentManager.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157void moveToState(Fragment f, int newState, int transit, int transitionStyle, boolean keepActive) &#123; ... switch (f.mState) &#123; case Fragment.INITIALIZING: if (DEBUG) Log.v(TAG, "moveto CREATED: " + f); if (f.mSavedFragmentState != null) &#123; f.mSavedFragmentState.setClassLoader(mHost.getContext().getClassLoader()); f.mSavedViewState = f.mSavedFragmentState.getSparseParcelableArray( FragmentManagerImpl.VIEW_STATE_TAG); f.mTarget = getFragment(f.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG); if (f.mTarget != null) &#123; f.mTargetRequestCode = f.mSavedFragmentState.getInt( FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, 0); &#125; f.mUserVisibleHint = f.mSavedFragmentState.getBoolean( FragmentManagerImpl.USER_VISIBLE_HINT_TAG, true); if (!f.mUserVisibleHint) &#123; f.mDeferStart = true; if (newState &gt; Fragment.STOPPED) &#123; newState = Fragment.STOPPED; &#125; &#125; &#125; f.mHost = mHost; f.mParentFragment = mParent; f.mFragmentManager = mParent != null ? mParent.mChildFragmentManager : mHost.getFragmentManagerImpl(); dispatchOnFragmentPreAttached(f, mHost.getContext(), false); f.mCalled = false; f.onAttach(mHost.getContext()); if (!f.mCalled) &#123; throw new SuperNotCalledException("Fragment " + f + " did not call through to super.onAttach()"); &#125; if (f.mParentFragment == null) &#123; mHost.onAttachFragment(f); &#125; else &#123; f.mParentFragment.onAttachFragment(f); &#125; dispatchOnFragmentAttached(f, mHost.getContext(), false); if (!f.mRetaining) &#123; f.performCreate(f.mSavedFragmentState); dispatchOnFragmentCreated(f, f.mSavedFragmentState, false); &#125; else &#123; f.restoreChildFragmentState(f.mSavedFragmentState); f.mState = Fragment.CREATED; &#125; f.mRetaining = false; if (f.mFromLayout) &#123; // For fragments that are part of the content view // layout, we need to instantiate the view immediately // and the inflater will take care of adding it. f.mView = f.performCreateView(f.getLayoutInflater( f.mSavedFragmentState), null, f.mSavedFragmentState); if (f.mView != null) &#123; f.mInnerView = f.mView; if (Build.VERSION.SDK_INT &gt;= 11) &#123; ViewCompat.setSaveFromParentEnabled(f.mView, false); &#125; else &#123; f.mView = NoSaveStateFrameLayout.wrap(f.mView); &#125; if (f.mHidden) f.mView.setVisibility(View.GONE); f.onViewCreated(f.mView, f.mSavedFragmentState); dispatchOnFragmentViewCreated(f, f.mView, f.mSavedFragmentState, false); &#125; else &#123; f.mInnerView = null; &#125; &#125; case Fragment.CREATED: if (newState &gt; Fragment.CREATED) &#123; if (DEBUG) Log.v(TAG, "moveto ACTIVITY_CREATED: " + f); if (!f.mFromLayout) &#123; ViewGroup container = null; if (f.mContainerId != 0) &#123; if (f.mContainerId == View.NO_ID) &#123; throwException(new IllegalArgumentException( "Cannot create fragment " + f + " for a container view with no id")); &#125; container = (ViewGroup) mContainer.onFindViewById(f.mContainerId); if (container == null &amp;&amp; !f.mRestored) &#123; String resName; try &#123; resName = f.getResources().getResourceName(f.mContainerId); &#125; catch (NotFoundException e) &#123; resName = "unknown"; &#125; throwException(new IllegalArgumentException( "No view found for id 0x" + Integer.toHexString(f.mContainerId) + " (" + resName + ") for fragment " + f)); &#125; &#125; f.mContainer = container; f.mView = f.performCreateView(f.getLayoutInflater( f.mSavedFragmentState), container, f.mSavedFragmentState); if (f.mView != null) &#123; f.mInnerView = f.mView; if (Build.VERSION.SDK_INT &gt;= 11) &#123; ViewCompat.setSaveFromParentEnabled(f.mView, false); &#125; else &#123; f.mView = NoSaveStateFrameLayout.wrap(f.mView); &#125; if (container != null) &#123; container.addView(f.mView); &#125; if (f.mHidden) &#123; f.mView.setVisibility(View.GONE); &#125; f.onViewCreated(f.mView, f.mSavedFragmentState); dispatchOnFragmentViewCreated(f, f.mView, f.mSavedFragmentState, false); // Only animate the view if it is visible. This is done after // dispatchOnFragmentViewCreated in case visibility is changed f.mIsNewlyAdded = (f.mView.getVisibility() == View.VISIBLE) &amp;&amp; f.mContainer != null; &#125; else &#123; f.mInnerView = null; &#125; &#125; f.performActivityCreated(f.mSavedFragmentState); dispatchOnFragmentActivityCreated(f, f.mSavedFragmentState, false); if (f.mView != null) &#123; f.restoreViewState(f.mSavedFragmentState); &#125; f.mSavedFragmentState = null; &#125; case Fragment.ACTIVITY_CREATED: if (newState &gt; Fragment.ACTIVITY_CREATED) &#123; f.mState = Fragment.STOPPED; &#125; case Fragment.STOPPED: if (newState &gt; Fragment.STOPPED) &#123; if (DEBUG) Log.v(TAG, "moveto STARTED: " + f); f.performStart(); dispatchOnFragmentStarted(f, false); &#125; case Fragment.STARTED: if (newState &gt; Fragment.STARTED) &#123; if (DEBUG) Log.v(TAG, "moveto RESUMED: " + f); f.performResume(); dispatchOnFragmentResumed(f, false); f.mSavedFragmentState = null; f.mSavedViewState = null; &#125; ... ... &#125; Fragment.java 123456789101112131415161718192021222324252627282930313233343536void performCreate(Bundle savedInstanceState) &#123; if (mChildFragmentManager != null) &#123; mChildFragmentManager.noteStateNotSaved(); &#125; mState = CREATED; mCalled = false; onCreate(savedInstanceState); if (!mCalled) &#123; throw new SuperNotCalledException("Fragment " + this + " did not call through to super.onCreate()"); &#125;&#125;View performCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; if (mChildFragmentManager != null) &#123; mChildFragmentManager.noteStateNotSaved(); &#125; return onCreateView(inflater, container, savedInstanceState);&#125;void performActivityCreated(Bundle savedInstanceState) &#123; if (mChildFragmentManager != null) &#123; mChildFragmentManager.noteStateNotSaved(); &#125; mState = ACTIVITY_CREATED; mCalled = false; onActivityCreated(savedInstanceState); if (!mCalled) &#123; throw new SuperNotCalledException("Fragment " + this + " did not call through to super.onActivityCreated()"); &#125; if (mChildFragmentManager != null) &#123; mChildFragmentManager.dispatchActivityCreated(); &#125;&#125; 从上面可以看出Fragment的部分生命周期回调： onAttach(mHost.getContext()) performCreate(f.mSavedFragmentState) performCreate内部则回调了onCreate f.performCreateView(f.getLayoutInflater(f.mSavedFragmentState), null, f.mSavedFragmentState) 这个是重点，DialogFragment会重写getLayoutInflater -&gt; performGetLayoutInflater -&gt; onGetLayoutInflater 调用顺序调用到的onGetLayoutInflater方法创建Dialog对象（onCreateDialog），并将performCreateView返回的view保存到Fragmnet内。即onViewCreated的第一个入参。performCreateView内会回调onCreateView onViewCreated(f.mView, f.mSavedFragmentState) performActivityCreated(f.mSavedFragmentState) performActivityCreated内部会回调 onActivityCreated DialogFragment.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** @hide */@Overridepublic LayoutInflater onGetLayoutInflater(Bundle savedInstanceState) &#123; if (!mShowsDialog) &#123; return super.onGetLayoutInflater(savedInstanceState); &#125; mDialog = onCreateDialog(savedInstanceState); switch (mStyle) &#123; case STYLE_NO_INPUT: mDialog.getWindow().addFlags( WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE); // fall through... case STYLE_NO_FRAME: case STYLE_NO_TITLE: mDialog.requestWindowFeature(Window.FEATURE_NO_TITLE); &#125; if (mDialog != null) &#123; return (LayoutInflater)mDialog.getContext().getSystemService( Context.LAYOUT_INFLATER_SERVICE); &#125; return (LayoutInflater) mHost.getContext().getSystemService( Context.LAYOUT_INFLATER_SERVICE);&#125;/** * Override to build your own custom Dialog container. This is typically * used to show an AlertDialog instead of a generic Dialog; when doing so, * &#123;@link #onCreateView(LayoutInflater, ViewGroup, Bundle)&#125; does not need * to be implemented since the AlertDialog takes care of its own content. * * &lt;p&gt;This method will be called after &#123;@link #onCreate(Bundle)&#125; and * before &#123;@link #onCreateView(LayoutInflater, ViewGroup, Bundle)&#125;. The * default implementation simply instantiates and returns a &#123;@link Dialog&#125; * class. * * &lt;p&gt;&lt;em&gt;Note: DialogFragment own the &#123;@link Dialog#setOnCancelListener * Dialog.setOnCancelListener&#125; and &#123;@link Dialog#setOnDismissListener * Dialog.setOnDismissListener&#125; callbacks. You must not set them yourself.&lt;/em&gt; * To find out about these events, override &#123;@link #onCancel(DialogInterface)&#125; * and &#123;@link #onDismiss(DialogInterface)&#125;.&lt;/p&gt; * * @param savedInstanceState The last saved instance state of the Fragment, * or null if this is a freshly created Fragment. * * @return Return a new Dialog instance to be displayed by the Fragment. */public Dialog onCreateDialog(Bundle savedInstanceState) &#123; return new Dialog(getActivity(), getTheme());&#125;@Overridepublic void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); if (!mShowsDialog) &#123; return; &#125; View view = getView(); if (view != null) &#123; if (view.getParent() != null) &#123; throw new IllegalStateException( "DialogFragment can not be attached to a container view"); &#125; mDialog.setContentView(view); &#125; final Activity activity = getActivity(); if (activity != null) &#123; mDialog.setOwnerActivity(activity); &#125; mDialog.setCancelable(mCancelable); if (!mDialog.takeCancelAndDismissListeners("DialogFragment", this, this)) &#123; throw new IllegalStateException( "You can not set Dialog's OnCancelListener or OnDismissListener"); &#125; if (savedInstanceState != null) &#123; Bundle dialogState = savedInstanceState.getBundle(SAVED_DIALOG_STATE_TAG); if (dialogState != null) &#123; mDialog.onRestoreInstanceState(dialogState); &#125; &#125;&#125; 根据Fragment内主要生命周期方法调用顺序和DialogFragment重写的具体方法，可以确定一个调用顺序：（注：括号表示的是括号内的为括号前表示方法内部调用，不是表示入参） onAttach -&gt; onCreate -&gt; performCreateView( onGetLayoutInflater（onCreateDialog） -&gt; onCreateView) -&gt; onViewCreated -&gt; onActivityCreated -&gt; onStart 而且DialogFragment显示对话框主要还是通过内部创建Dialog对象来实现。 从Dialog的 dispatchTouchEvent入手： Dialog.java 123456789101112131415161718192021222324252627282930313233343536/** * Called to process touch screen events. You can override this to * intercept all touch screen events before they are dispatched to the * window. Be sure to call this implementation for touch screen events * that should be handled normally. * * @param ev The touch screen event. * * @return boolean Return true if this event was consumed. */@Overridepublic boolean dispatchTouchEvent(@NonNull MotionEvent ev) &#123; if (mWindow.superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev);&#125;/** * Called when a touch screen event was not handled by any of the views * under it. This is most useful to process touch events that happen outside * of your window bounds, where there is no view to receive it. * * @param event The touch screen event being processed. * @return Return true if you have consumed the event, false if you haven't. * The default implementation will cancel the dialog when a touch * happens outside of the window bounds. */public boolean onTouchEvent(@NonNull MotionEvent event) &#123; if (mCancelable &amp;&amp; mShowing &amp;&amp; mWindow.shouldCloseOnTouch(mContext, event)) &#123; cancel(); return true; &#125; return false;&#125; 其中mWindow在Android中的具体实现类为PhoneWindow，关于事件分发的详细说明可查看文章 Android事件分发机制源码解析。由于我们点击的是外部区域，所以superDispatchTouchEvent不会消费此事件，从而转交给onTouchEvent处理。 onTouchEvent内主要看mWindow.shouldCloseOnTouch(mContext, event)，由于PhoneWindow没有重写该方法，所以看Window内的具体实现 Window.java 12345678910111213141516171819202122/** @hide */ @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023) public boolean shouldCloseOnTouch(Context context, MotionEvent event) &#123; final boolean isOutside = event.getAction() == MotionEvent.ACTION_UP &amp;&amp; isOutOfBounds(context, event) || event.getAction() == MotionEvent.ACTION_OUTSIDE; if (mCloseOnTouchOutside &amp;&amp; peekDecorView() != null &amp;&amp; isOutside) &#123; return true; &#125; return false; &#125; private boolean isOutOfBounds(Context context, MotionEvent event) &#123; final int x = (int) event.getX(); final int y = (int) event.getY(); final int slop = ViewConfiguration.get(context).getScaledWindowTouchSlop(); final View decorView = getDecorView(); return (x &lt; -slop) || (y &lt; -slop) || (x &gt; (decorView.getWidth()+slop)) || (y &gt; (decorView.getHeight()+slop)); &#125; Window#shouldCloseOnTouch主要是判断了点击位置是否在DecorView范围内。 实现方案通过上述分析，可以通过重写DialogFragment#onCreateDialog（Bundle）方法，返回重写了onTouchEvent的Dialog对象OutsideClickDialog。通过onTouchEvent拦截事件。 OutsideClickDialog具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public static class OutsideClickDialog extends Dialog &#123; private boolean mCancelable; private OnOutsideClickListener onOutsideClickListener; @Override public void setCanceledOnTouchOutside(boolean cancel) &#123; super.setCanceledOnTouchOutside(cancel); mCancelable = cancel; &#125; public void setOnOutsideClickListener(OnOutsideClickListener onOutsideClickListener) &#123; this.onOutsideClickListener = onOutsideClickListener; &#125; public OutsideClickDialog(@NonNull Context context) &#123; super(context); &#125; public OutsideClickDialog(@NonNull Context context, int themeResId) &#123; super(context, themeResId); &#125; protected OutsideClickDialog(@NonNull Context context, boolean cancelable, @Nullable OnCancelListener cancelListener) &#123; super(context, cancelable, cancelListener); &#125; @Override public boolean onTouchEvent(@NonNull MotionEvent event) &#123; if (mCancelable &amp;&amp; isShowing() &amp;&amp; (event.getAction() == MotionEvent.ACTION_UP &amp;&amp; isOutOfBounds(getContext(), event) || event.getAction() == MotionEvent.ACTION_OUTSIDE)) &#123; boolean consume = onOutsideClickListener.consumeOutsideClick(); if (consume) &#123; return true; &#125; &#125; return super.onTouchEvent(event); &#125; private boolean isOutOfBounds(Context context, MotionEvent event) &#123; final int x = (int) event.getX(); final int y = (int) event.getY(); final int slop = ViewConfiguration.get(context).getScaledWindowTouchSlop(); final View decorView = getWindow().getDecorView(); return (x &lt; -slop) || (y &lt; -slop) || (x &gt; (decorView.getWidth() + slop)) || (y &gt; (decorView.getHeight() + slop)); &#125;&#125; 在DialogFragment子类SimpleDialogFragment内： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@NonNull @Override public Dialog onCreateDialog(@Nullable Bundle savedInstanceState) &#123; //自定义Dialog，通过重写onTouchEvent拦截外部点击事件 OutsideClickDialog outsideClickDialog = new OutsideClickDialog(getContext(), getTheme()); outsideClickDialog.setOnOutsideClickListener(this::consumeOutsideClick); //对返回按键做监听 outsideClickDialog.setOnKeyListener((dialog1, keyCode, event) -&gt; &#123; if (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; event.getAction() == MotionEvent.ACTION_UP) &#123; if (mBuilder.onOutsideClickListener != null) &#123; //根据回调方法判断是否拦截 return mBuilder.onOutsideClickListener.consumeOutsideClick(); &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125;); return outsideClickDialog; &#125; private boolean consumeOutsideClick() &#123; if (mBuilder.onOutsideClickListener != null) &#123; //根据回调方法判断是否拦截外部点击事件 return mBuilder.onOutsideClickListener.consumeOutsideClick(); &#125; return !mBuilder.cancelable; &#125; public static class Builder &#123; boolean cancelable = true; private OnOutsideClickListener onOutsideClickListener; private DialogInterface.OnDismissListener onDismissListener; public Builder setCancelable(boolean cancelable) &#123; this.cancelable = cancelable; return this; &#125; public Builder setOutsideClickListener(OnOutsideClickListener onOutsideClickListener) &#123; this.onOutsideClickListener = onOutsideClickListener; return this; &#125; public Builder setOnDismissListener(DialogInterface.OnDismissListener onDismissListener) &#123; this.onDismissListener = onDismissListener; return this; &#125; public SimpleDialogFragment create() &#123; return SimpleDialogFragment.getInstance(this); &#125; public SimpleDialogFragment show(FragmentManager manager, String tag) &#123; if (manager.findFragmentByTag(tag) != null) &#123; return (SimpleDialogFragment) manager.findFragmentByTag(tag); &#125; SimpleDialogFragment dialog = create(); dialog.show(manager, tag); return dialog; &#125; &#125; 其中Builder 为SimpleDialogFragment静态内部类。 并通过OnKeyListener监听返回按键。 具体使用如下： 123456789101112131415161718@Overrideprotected void bindEvent() &#123; super.bindEvent(); btnShowDialog.setOnClickListener(this::showDialog);&#125;private void showDialog(View v) &#123; new SimpleDialogFragment.Builder() .setOutsideClickListener(() -&gt; &#123; Log.w(TAG, "showDialog outer click "); Toast.makeText(activityInstance, "outer click", Toast.LENGTH_SHORT).show(); return true; &#125;) .setOnDismissListener(dialog -&gt; &#123; Log.w(TAG, "showDialog dismiss"); &#125;) .show(getSupportFragmentManager(), "simple_dialog_test");&#125; 完整代码完整代码在该目录下 https://gitee.com/goldsea/learn/tree/master/app/src/main/java/com/nhtzj/learnapplication/activity/sample/dialog]]></content>
      <categories>
        <category>android</category>
        <category>系统组件</category>
      </categories>
      <tags>
        <tag>DialogFragment</tag>
        <tag>外部点击监听</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConstraintLayout 填坑记]]></title>
    <url>%2F280127131%2F</url>
    <content type="text"><![CDATA[疫情概要国内疫情6月4日0—24时，31个省（自治区、直辖市）和新疆生产建设兵团报告新增确诊病例5例，均为境外输入病例（上海4例，四川1例）；无新增死亡病例；无新增疑似病例。 国际疫情截至6月4日，国际上214个国家/地区、日本领海邮轮上和其他商船(不含港澳台地区)累计确诊6332225例新型冠状病毒肺炎病例，累计死亡378222例；6月4日新增129280例确诊病例，新增4842例死亡病例。无新增报告病例的国家和地区。（来源：世界卫生组织） 前言本篇记录小编在使用ConstrintLayout组件开发过程中遇到的“坑”。 ViewStub高度异常场景ViewStub位于多个子控件之间，宽度设置为 0dp，高度设置为 44dp，start和end都为 parent，即宽为铺满父容器 ConstraintLayout；而Y轴则指定为其他两个子控件之间，即指定了 layout_constraintTop_toBottomof 和layout_constraintBottom_toTopf。 但实际运行调用ViewStub.inflate后的结果是ViewStub会占满自ViewStub开始的所有空间，即ViewStub下方的控件都不会显示。 解决方法ViewStub中有这样一个属性：inflatedId，官方文档中的解释如下： android:inflatedId—Overrides the id of the inflated View with this value 即实际加载的view的ID将会设置为inflatedId所代表的值。 将该属性的值，与ViewStub的android:id的值设置的完全一样，即可解决问题。 通过Android Studio自带的Layout Inspector工具查看ViewStub所在的界面，可以发现ViewStub.inflate后不会再有ViewStub标签，只有android:layout所指向的布局内容，所以使用在ViewStub上的约束必须通过相同的ID获取到。 ConstraintSet相关其中对于ConstraintLayout.LayoutParams有一段特别的说明： This class contains the different attributes specifying how a view want to be laid out inside a ConstraintLayout. For building up constraints at run time, using ConstraintSet is recommended. 翻译过来即：该类包含的属性具体说明了子控件在ConstraintLayout内的布局位置。ConstraintLayout不推荐在运行时用LayoutParams来设置属性，而是用ConstraintSet来设置参数。 applyTo场景ConstraintLayout的子控件通过View.setVisibility(@Visibility int visibility)修改过可见性后，调用ConstraintSet.applyTo(ConstraintLayout constraintLayout) 后，子控件的可见性会恢复成初始状态。 解决方法调用View.setVisibility(@Visibility int visibility)后再添加ConstraintSet的更新：ConstraintSet.setVisibility(int viewId, int visibility) 其中viewId：调用View.setVisibility（）的id。 示例代码：ConstraintActivity.java 分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * Apply the constraints to a ConstraintLayout. * * @param constraintLayout to be modified */ public void applyTo(ConstraintLayout constraintLayout) &#123; applyToInternal(constraintLayout); constraintLayout.setConstraintSet(null); &#125; /** * Used to set constraints when used by constraint layout */ void applyToInternal(ConstraintLayout constraintLayout) &#123; int count = constraintLayout.getChildCount(); HashSet&lt;Integer&gt; used = new HashSet&lt;Integer&gt;(mConstraints.keySet()); for (int i = 0; i &lt; count; i++) &#123; View view = constraintLayout.getChildAt(i); int id = view.getId(); if (mConstraints.containsKey(id)) &#123; used.remove(id); Constraint constraint = mConstraints.get(id); if (constraint.mHelperType != UNSET) &#123; switch (constraint.mHelperType) &#123; case BARRIER_TYPE: Barrier barrier = (Barrier) view; barrier.setId(id); barrier.setReferencedIds(constraint.mReferenceIds); barrier.setType(constraint.mBarrierDirection); ConstraintLayout.LayoutParams param = constraintLayout .generateDefaultLayoutParams(); constraint.applyTo(param); break; &#125; &#125; ConstraintLayout.LayoutParams param = (ConstraintLayout.LayoutParams) view .getLayoutParams(); constraint.applyTo(param); view.setLayoutParams(param); //此处会调用setVisibility刷新控件可见性 view.setVisibility(constraint.visibility); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &#123; view.setAlpha(constraint.alpha); view.setRotation(constraint.rotation); view.setRotationX(constraint.rotationX); view.setRotationY(constraint.rotationY); view.setScaleX(constraint.scaleX); view.setScaleY(constraint.scaleY); view.setPivotX(constraint.transformPivotX); view.setPivotY(constraint.transformPivotY); view.setTranslationX(constraint.translationX); view.setTranslationY(constraint.translationY); if (Build.VERSION.SDK_INT &gt;= VERSION_CODES.LOLLIPOP) &#123; view.setTranslationZ(constraint.translationZ); if (constraint.applyElevation) &#123; view.setElevation(constraint.elevation); &#125; &#125; &#125; &#125; &#125; for (Integer id : used) &#123; Constraint constraint = mConstraints.get(id); if (constraint.mHelperType != UNSET) &#123; switch (constraint.mHelperType) &#123; case BARRIER_TYPE: Barrier barrier = new Barrier(constraintLayout.getContext()); barrier.setId(id); barrier.setReferencedIds(constraint.mReferenceIds); barrier.setType(constraint.mBarrierDirection); ConstraintLayout.LayoutParams param = constraintLayout .generateDefaultLayoutParams(); constraint.applyTo(param); constraintLayout.addView(barrier, param); break; &#125; &#125; if (constraint.mIsGuideline) &#123; Guideline g = new Guideline(constraintLayout.getContext()); g.setId(id); ConstraintLayout.LayoutParams param = constraintLayout.generateDefaultLayoutParams(); constraint.applyTo(param); constraintLayout.addView(g, param); &#125; &#125; &#125; 通过上面源码可知：applyTo内部调用了applyToInternal方法，内部又调用了view.setVisibility(constraint.visibility);使用ConstraintSet内保存的值进行刷新。 ConstraintSet主要是对子控件的位置进行控制调整，包括：visibility、alpha、rotation、rotationX、rotationY、scaleX、scaleY、transformPivotX、transformPivotY、translationX、translationY、elevation。 所以不是通过ConstraintSet更新的这些属性值，在调用applyTo后都不会生效。]]></content>
      <categories>
        <category>android</category>
        <category>系统组件</category>
      </categories>
      <tags>
        <tag>系统组件</tag>
        <tag>ConstraintLayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用却不简单的TextView]]></title>
    <url>%2F2490979448%2F</url>
    <content type="text"><![CDATA[疫情概要国内疫情5月26日0—24时，31个省（自治区、直辖市）和新疆生产建设兵团报告新增确诊病例1例，为境外输入病例（在上海）；无新增死亡病例；新增疑似病例1例，为境外输入病例（在福建） 国际疫情截至2020年5月27日12时，全球共215个国家和地区爆发了新冠疫情。除中国外，其他国家新冠病毒感染病例累计确诊555.3万人，累计治愈223.9万人，累计死亡35.0万人。其中，美国累计确诊168.0万人，累计死亡9.9万人。巴西、俄罗斯、英国、西班牙和意大利累计确诊均超20万人。英国、意大利、法国、西班牙和巴西累计死亡均超2万人。 前言Android开发中TextView是使用频率最高的一个控件，除了能显示文本内容还能展示图片。本篇就记录日常开发中关于TextView的一些特殊或者较少使用却有大用的属性或能力。关于使用TextView显示富文本的相关内容可以转到之前写的文章神奇的TextView-实现富文本，实现了文本、图片加载显示及链接处理。 设置行间距、行高先看效果 android:lineHeight / setLineHeight(int)设置行高，文本高度也包含在内。Added in API level 28 官方文档： 123456789Explicit height between lines of text. If set, this will override the values set for lineSpacingExtra and lineSpacingMultiplier.May be a dimension value, which is a floating point number appended with a unit such as "`14.5sp`". Available units are: px (pixels), dp (density-independent pixels), sp (scaled pixels based on preferred font size), in (inches), and mm (millimeters).Related methods:- `setLineHeight(int)` 翻译过来大致意思是： 指定文本明确的行间距，并且设置了该属性后lineSpacingExtra 和 lineSpacingMultiplier将会被覆盖，即失效。设置的值是一个尺寸值，单位可以是px、dp、sp、in、mm。 android:lineSpacingExtra / setLineSpacing(float,float)设置行间距，文本高度不包含在内。Added in API level 1 官方文档： 123456789Extra spacing between lines of text. The value will not be applied for the last line of text.May be a dimension value, which is a floating point number appended with a unit such as "`14.5sp`". Available units are: px (pixels), dp (density-independent pixels), sp (scaled pixels based on preferred font size), in (inches), and mm (millimeters).**Related methods:**- `setLineSpacing(float,float)` 翻译过来大致意思是： 指定文本行间距的额外距离（即设置的是不包含文本高度的距离），最后一行不会生效。设置的值是一个尺寸值，单位可以是px、dp、sp、in、mm。 其中Java方法 setLineSpacing(float,float) 为： 12public void setLineSpacing (float add, float mult) Parameters add float: The value in pixels that should be added to each line other than the last line. This will be applied after the multiplier mult float: The value by which each line height other than the last line will be multiplied by 第一个入参 add 等同于 xml 中 lineSpacingExtra设置的值，先乘mult值，后加add值； 第二个入参 mult 等同于 xml 中 lineSpacingMultiplier设置的值； android:lineSpacingMultiplier / setLineSpacing(float,float)设置行间距的倍数，文本高度不包含在内。Added in API level 1 官方文档： 123456789Extra spacing between lines of text, as a multiplier. The value will not be applied for the last line of text.May be a floating point value, such as "`1.2`".**Related methods:**- `setLineSpacing(float,float)` 翻译过来大致意思是： 指定文本行间距的倍数（即设置的是不包含文本高度的距离倍数），最后一行不会生效。浮点类型。 android:letterSpacing设置字符间距。Added in API level 21 123456789Text letter-spacing.May be a floating point value, such as "`1.2`".**Related methods:**- `setLetterSpacing(float)` 翻译过来大致意思是： 文本的字符距离。浮点类型。 代码activity_text_view.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".activity.sample.TextViewActivity"&gt; &lt;!--默认样式--&gt; &lt;TextView android:id="@+id/tv_default" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="大家好，我是默认的TextView显示样式。大家好，我是默认的TextView显示样式。大家好，我是默认的TextView显示样式。大家好，我是默认的TextView显示样式" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;!-- android:lineHeight="30dp"--&gt; &lt;TextView android:id="@+id/tv_line_height" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="30dp" android:lineHeight="30dp" android:text="大家好，我是设置了lineHeight=30dp的TextView显示样式，使用该属性后lineSpacingExtra和lineSpacingMultiplier都将无效。该属性需要SDK&gt;=28时才能使用" android:textStyle="bold" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toBottomOf="@id/tv_default" /&gt; &lt;!-- android:lineSpacingExtra="10dp"--&gt; &lt;TextView android:id="@+id/tv_line_space_extra" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="30dp" android:lineSpacingExtra="10dp" android:text="大家好，我是设置了lineSpacingExtra=10dp的TextView显示样式。大家好，我是设置了lineSpacingExtra=10dp的TextView显示样式。" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toBottomOf="@id/tv_line_height" /&gt; &lt;!-- android:lineSpacingMultiplier="1.5"--&gt; &lt;TextView android:id="@+id/tv_line_space_multiplier" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="30dp" android:lineSpacingMultiplier="1.5" android:text="大家好，我是设置了lineSpacingMultiplier=1.5的TextView显示样式。大家好，我是设置了lineSpacingMultiplier=1.5的TextView显示样式。" android:textStyle="bold" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toBottomOf="@id/tv_line_space_extra" /&gt; &lt;!--android:letterSpacing="0.5"--&gt; &lt;TextView android:id="@+id/tv_letter_space" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="30dp" android:letterSpacing="0.5" android:text="大家好，我是设置了letterSpacing=0.5的TextView显示样式。该属性需要SDK&gt;=21时才能使用" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toBottomOf="@id/tv_line_space_multiplier" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; TextViewActivity.java 用于展示java内如何设置，效果同activity_text_view.xml内一致 123456789101112131415161718192021//等同于 android:lineHeight="30dp"TextView tvLineHeight = findViewById(R.id.tv_line_height);int lineHeight = SizeUtils.dp2px(30);if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) &#123; tvLineHeight.setLineHeight(lineHeight);&#125;//等同于android:lineSpacingExtra="10dp"TextView tvLineSpacingExtra = findViewById(R.id.tv_line_spacing_extra);int add = SizeUtils.dp2px(10);tvLineSpacingExtra.setLineSpacing(add, 1);//等同于 android:lineSpacingMultiplier="1.5"TextView tvLineSpacingMultiplier = findViewById(R.id.tv_line_spacing_multiplier);tvLineSpacingMultiplier.setLineSpacing(0, 1.5f);//等同于 android:letterSpacing="0.5"TextView tvLetterSpace = findViewById(R.id.tv_letter_space);if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; tvLetterSpace.setLetterSpacing(0.5f);&#125; 参考TextView官方文档)]]></content>
      <categories>
        <category>android</category>
        <category>view</category>
        <category>TextView</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>TextView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio Gradle无法同步（二）]]></title>
    <url>%2F3004092570%2F</url>
    <content type="text"><![CDATA[疫情概要国内疫情概要5月7日0—24时，31个省（自治区、直辖市）和新疆生产建设兵团报告新增确诊病例1例，为本土病例（在吉林）；无新增死亡病例；新增疑似病例3例，均为境外输入病例（在上海）。 海外疫情概要世界卫生组织：截至欧洲中部时间7日10时（北京时间7日16时），全球新冠确诊病例较前一日增加83465例，达到3672238例；死亡病例较前一日增加6539例，达到254045例。 美国约翰斯·霍普金斯大学：根据北京时间8日6时40分查询到的数据，全球确诊病例达3836215例，死亡病例为268999例。美国确诊病例升至1254740例，死亡病例达75543例。 前言前几周，小编娇贵的Mac Pro频频无故断电，并且必须要连接外接电源才能开机，该问题最早发生在去年2019年冬天，但最近是越发的频繁了，故而预约了Apple 西湖 店自行送修。其实小编是去了两趟，由于第一次无法现场复现，所以就只是重装了系统，第二次去，才答应换电池套装。 换了电池之后，没有从Time Machine中做全盘恢复，只是恢复了部分资料，但几天后Android Studio 却无法同步Gradle文件。本篇就记录一下处理的这个艰辛过程，方便以后回述。 报错详情123456789FAILURE: Build failed with an exception.* What went wrong:A problem occurred configuring root project &apos;Test Application&apos;.&gt; Could not resolve all artifacts for configuration &apos;:classpath&apos;. &gt; Could not download gradle.jar (com.android.tools.build:gradle:3.6.3) &gt; Could not get resource &apos;https://dl.google.com/dl/android/maven2/com/android/tools/build/gradle/3.6.3/gradle-3.6.3.jar&apos;. &gt; Could not GET &apos;https://dl.google.com/dl/android/maven2/com/android/tools/build/gradle/3.6.3/gradle-3.6.3.jar&apos;. Received status code 400 from server: Bad Request 其中 400 Bad Request 是由于明显的客户端错误（例如，格式错误的请求语法，太大的大小，无效的请求消息或欺骗性路由请求），服务器不能或不会处理该请求。 尝试处理（无效） 手动下载 gradle3.6.3 (浏览器内打开 https://dl.google.com/dl/android/maven2/com/android/tools/build/gradle/3.6.3/gradle-3.6.3.jar)，能正常下载。 其实从这可以推断出是代理的问题 关闭ClashX翻墙代理，关闭Android Studio内 Http proxy 重装/降级 Android Studio 降级：当前AS上没有找到 Enble embedded Maven repository 选项。 Setting-&gt;Build,Execution,Deployment-&gt;Gradle-&gt;Android Studio ,然后把 Enble embedded Maven repository 前面的单选框勾选上。 解决方式（有效）在/Users/(用户名)/.gradle/gradle.properties文件内发现如下： 1234567891011121314151617## For more details on how to configure your build environment visit# http://www.gradle.org/docs/current/userguide/build_environment.html## Specifies the JVM arguments used for the daemon process.# The setting is particularly useful for tweaking memory settings.# Default value: -Xmx1024m -XX:MaxPermSize=256m# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8## When configured, Gradle will run in incubating parallel mode.# This option should only be used with decoupled projects. More details, visit# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects# org.gradle.parallel=true#Sun Mar 29 16:36:14 CST 2020systemProp.https.proxyPort=80systemProp.http.proxyHost=mirrors.neusoft.edu.cnsystemProp.https.proxyHost=mirrors.neusoft.edu.cnsystemProp.http.proxyPort=80 最后4行指定了一个代理，原本以为是AS设置里面配了Http Proxy Auto-detect proxy setting引起的。 之后尝试将最后4行的代理删了，结果就可以了。害得我辛辛苦苦折腾了大半天。 简单来讲就是删除 gradle.properties内的代理配置。 其实小编之前那篇 Android Studio Gradle无法同步也试通了一种方式，不过没有在这台机子上试试。不过 Android Studio Gradle无法同步中通过修改host文件添加索引的方式也不便利。]]></content>
      <categories>
        <category>android</category>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 动态切换全屏横屏]]></title>
    <url>%2F3052045100%2F</url>
    <content type="text"><![CDATA[疫情概要国内疫情截至4月25日24时，据31个省（自治区、直辖市）和新疆生产建设兵团报告，现有确诊病例801例（其中重症病例51例），累计治愈出院病例77394例，累计死亡病例4632例，累计报告确诊病例82827例，现有疑似病例12例。累计追踪到密切接触者729885人，尚在医学观察的密切接触者8308人。 海外疫情经济日报-中国经济网北京4月26日讯（记者 朱晓航）截至4月26日上午11点，全球新冠肺炎确诊病例逾291万例，中国以外确诊病例超283万例，共31国累计确诊病例过万，其中美国960651例，西班牙223759例，意大利195351例。 过去24小时，中国以外新冠肺炎病例新增超8.4万例，其中美国今日新增3.3万多（连续第33天新增过万），俄罗斯5900多，英国4900多，西班牙3900多。 目前全球共报告新冠肺死亡病例超20万例，中国以外死亡病例逾19.8万例，其中美国死亡54256例，意大利死亡26384例，西班牙死亡22902例。 前言最近几天的开发强度终于开始缓解下来了，小编才算是可以把之前later了好久的一个bug拿出来好好折腾折腾了。 本篇的主角bug全称：部分设备切换横屏后系统状态栏和导航栏无法隐藏，连续横竖屏切换多次后也会出现横屏全屏无法隐藏系统状态栏和导航栏。 本篇就将该问题的最终解决方案做个总结，接下来就直接进入主题。 问题版本123456789101112131415161718192021222324252627282930313233343536@Override public void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig); if (ActivityInfo.SCREEN_ORIENTATION_USER == newConfig.orientation) &#123; //横屏 hideSystemUI(); &#125; else &#123; //竖屏 showSystemUI(); &#125; &#125; /** * 隐藏系统状态栏和导航栏 */ private void hideSystemUI() &#123; View decorView = getWindow().getDecorView(); decorView.setSystemUiVisibility( View.SYSTEM_UI_FLAG_IMMERSIVE // Set the content to appear under the system bars so that the // content doesn't resize when the system bars hide and show. | View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN // Hide the nav bar and status bar | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_FULLSCREEN); &#125; /** * 显示系统状态栏和导航栏 */ private void showSystemUI() &#123; View decorView = getWindow().getDecorView(); decorView.setSystemUiVisibility( View.SYSTEM_UI_FLAG_VISIBLE); &#125; 改进处理版本（BaseAppCompatActivity）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121 private Handler mHandler = new Handler(); /** * 隐藏系统状态栏和导航栏 */ private Runnable hideSystemUIAction = this::hideSystemUI; @Override protected void onResume() &#123; super.onResume(); XLog.e(TAG, "onResume"); View decorView = getWindow().getDecorView(); //注册监听器，以便让应用获得系统界面可见性更改的通知 decorView.setOnSystemUiVisibilityChangeListener(this::onSystemUiVisibilityChange); &#125; @Override protected void onPause() &#123; super.onPause(); XLog.e(TAG, "onPause"); View decorView = getWindow().getDecorView(); //取消注册监听器 decorView.setOnSystemUiVisibilityChangeListener(null); &#125;/** * 当前activity所属的Window得到/失去焦点时会回调该方法 * * @param hasFocus */ @Override public void onWindowFocusChanged(boolean hasFocus) &#123; super.onWindowFocusChanged(hasFocus); boolean orientationLandscape = isOrientationLandscape(getResources()); Log.w(TAG, String.format("onWindowFocusChanged: %s isLandscape:%s", hasFocus, orientationLandscape)); if (hasFocus &amp;&amp; orientationLandscape) &#123; hideSystemUI(); &#125; &#125; /** * &#123;@link View.OnSystemUiVisibilityChangeListener&#125; 接口的回调操作，setOnSystemUiVisibilityChangeListener设置的哦 * * @param visibility */ public void onSystemUiVisibilityChange(int visibility) &#123; // Note that system bars will only be "visible" if none of the // LOW_PROFILE, HIDE_NAVIGATION, or FULLSCREEN flags are set. boolean orientationLandscape = isOrientationLandscape(getResources()); if ((visibility &amp; View.SYSTEM_UI_FLAG_FULLSCREEN) == 0) &#123; //系统状态栏显示 if (orientationLandscape) &#123; mHandler.removeCallbacks(hideSystemUIAction); mHandler.postDelayed(hideSystemUIAction, 100); &#125; &#125; else &#123;//系统状态栏隐藏 &#125; &#125; /** * 系统配置更新回调 * @param newConfig */ @Override public void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig); if (ActivityInfo.SCREEN_ORIENTATION_USER == newConfig.orientation) &#123; //横屏 hideSystemUI(); mHandler.postDelayed(hideSystemUIAction, 500); &#125; else &#123; //竖屏 mHandler.removeCallbacks(hideSystemUIAction); showSystemUI(); &#125; &#125; /** * 隐藏系统状态栏和导航栏 */ private void hideSystemUI() &#123; //使用SYSTEM_UI_FLAG_IMMERSIVE_STICKY模式， // 即：粘性沉浸模式，如果用户从隐藏了系统栏的边缘滑动，系统栏会显示出来，但它们是半透明的， // 并且轻触手势会传递给应用，因此应用也会响应该手势 View decorView = getWindow().getDecorView(); decorView.setSystemUiVisibility( View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY // Set the content to appear under the system bars so that the // content doesn't resize when the system bars hide and show. | View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN // Hide the nav bar and status bar | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_FULLSCREEN); &#125; /** * 显示系统状态栏和导航栏 */ private void showSystemUI() &#123; View decorView = getWindow().getDecorView(); decorView.setSystemUiVisibility( View.SYSTEM_UI_FLAG_VISIBLE); &#125; /** * 判断当前界面是否为横屏 * * @param resources * @return */ protected boolean isOrientationLandscape(Resources resources) &#123; if (resources == null) &#123; return false; &#125; return Configuration.ORIENTATION_LANDSCAPE == resources.getConfiguration().orientation; &#125; 改动点主要有以下几点： 通过 View.setOnSystemUiVisibilityChangeListener()注册 View.OnSystemUiVisibilityChangeListener ，以便获得系统界面可见性更改的通知 实现 onWindowFocusChanged()。 如果在横屏下获得窗口焦点，则需要再次隐藏系统栏 隐藏操作通过Handler进行适当延迟 使用粘性沉浸模式（SYSTEM_UI_FLAG_IMMERSIVE_STICKY），在普通的沉浸模式中，只要用户从边缘滑动，系统就会负责显示系统栏，您的应用甚至不会知道发生了该手势。因此，如果用户实际上可能是出于主要的应用体验而需要从屏幕边缘滑动，例如在玩需要大量滑动的游戏或使用绘图应用时，您应改为启用“粘性”沉浸模式。 在粘性沉浸模式下，如果用户从隐藏了系统栏的边缘滑动，系统栏会显示出来，但它们是半透明的，并且轻触手势会传递给应用，因此应用也会响应该手势。 源码源码仓库：https://gitee.com/goldsea/learn.git 核心源码：FullScreenActivity、BaseAppCompatActivity 参考启用全屏模式 相应界面可见性更改]]></content>
      <categories>
        <category>android</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>全屏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View之圆角实现]]></title>
    <url>%2F475838307%2F</url>
    <content type="text"><![CDATA[疫情概要截至2月11日24时，据31个省(自治区、直辖市)和新疆生产建设兵团报告，现有确诊病例38800例(其中重症病例8204例)，累计治愈出院病例4740例，累计死亡病例1113例，累计报告确诊病例44653例，现有疑似病例16067例。累计追踪到密切接触者451462人，尚在医学观察的密切接触者185037人。 前言最近项目中需要使用到圆角来展示内容。原先用得多的是用Canvas.clipXXX()或者是使用Paint.setXfermode()，现在用一个简单的方式就可实现，就是SDK21开始引入的ViewOutlineProvider类，用法也很简单。 ViewOutlineProvider Interface by which a View builds its Outline, used for shadow casting and clipping. 从上面官网的说明可以了解到ViewOutlineProvider有两个作用：裁剪、阴影。 用法利用裁剪实现圆角方法： 12345678910ViewOutlineProvider outlineProvider = new ViewOutlineProvider() &#123; @Override public void getOutline(View view, Outline outline) &#123; outline.setRoundRect(0, 0, view.getWidth(), view.getHeight(), 30); //30为圆角半径，可自行修改 &#125; &#125;; View view = findViewById(R.id.view);//需要设置圆角的控件 view.setOutlineProvider(outlineProvider);//将ViewOutlineProvider设置给view view.setClipToOutline(true);//只有设置为true才能进行裁剪，false时不裁剪 可以看到只要3步即可实现： 创建ViewOutlineProvider， 实现getOutline()方法，使用Outline.setRoundRect()设置圆角矩阵，即裁剪后留下的有效区域 将ViewOutlineProvider设置给需要的View，并调用View.setClipToOutline(true)开启裁剪 当然也可以调用View.setClipToOutline(false)关闭裁剪。 还有如下方法提供不同效果： Outline.setOval() Outline.setRect() 等…….. Outline类内部主要是有如下几个成员变量记录 1234567891011121314151617/** @hide */@Modepublic int mMode = MODE_EMPTY;/** * Only guaranteed to be non-null when mode == MODE_CONVEX_PATH * * @hide */public Path mPath;/** @hide */public final Rect mRect = new Rect();/** @hide */public float mRadius = RADIUS_UNDEFINED;/** @hide */public float mAlpha; 利弊利：使用方便 弊：必须要SDK&gt;=21才能使用 SDK&lt;21解决方式SDK&lt;21的这里提供一种，可直接使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * 圆角的RelativeLayout,如需要其他布局的圆角，可直接修改继承的父类 */public class RoundRectLayout extends RelativeLayout &#123; //圆角裁剪范围 private Path mPath; //圆角半径 private int mRadius = 30; private int mWidth; private int mHeight; //是否开启圆角 private boolean mRoundMode = true; public RoundRectLayout(Context context) &#123; super(context); init(); &#125; public RoundRectLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mWidth = w; mHeight = h; &#125; private void init() &#123; if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.JELLY_BEAN) &#123; setBackground(new ColorDrawable(0x33ff0000)); &#125; else &#123; setBackgroundDrawable(new ColorDrawable(0x33ff0000)); &#125; mPath = new Path(); mPath.setFillType(Path.FillType.EVEN_ODD); &#125; /** * 设置是否圆角裁边 * * @param roundMode */ public void setRoundMode(boolean roundMode) &#123; mRoundMode = roundMode; invalidate(); &#125; /** * 设置圆角半径 * * @param radius */ public void setCornerRadius(int radius) &#123; mRadius = radius; invalidate(); &#125; private void refreshRoundPath() &#123; mPath.reset(); if (mRoundMode) &#123; mPath.addRoundRect(new RectF(0, 0, mWidth, mHeight), mRadius, mRadius, Path.Direction.CW); &#125; &#125; @Override public void draw(Canvas canvas) &#123; if (mRoundMode) &#123; int saveCount = canvas.save(); refreshRoundPath(); canvas.clipPath(mPath); super.draw(canvas); canvas.restoreToCount(saveCount); &#125; else &#123; super.draw(canvas); &#125; &#125;&#125;]]></content>
      <categories>
        <category>android</category>
        <category>view</category>
        <category>自定义</category>
      </categories>
      <tags>
        <tag>view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio Gradle无法同步]]></title>
    <url>%2F2768760007%2F</url>
    <content type="text"><![CDATA[疫情概要截至2月9日24时，据31个省（自治区、直辖市）和新疆生产建设兵团报告，现有确诊病例35982例（其中重症病例6484例），累计治愈出院病例3281例，累计死亡病例908例，累计报告确诊病例40171例（湖北核减87例，江西、甘肃各核减1例），现有疑似病例23589例。累计追踪到密切接触者399487人，尚在医学观察的密切接触者187518人。 简介由于新型冠状病毒肺炎在全国快速蔓延，导致小编于2020/02/10正式开启在家办公模式。 申请完公司VPN后，能够成功访问到公司内网。但是无法正常同步获取到dl.google.com和maven.google.com下的文件。一开始还以为是国内高墙的原因，折腾了好一阵子，结果还是不行，最后发现是DNS异常，导致无法访问到。 问题原因DNS异常，域名无法正常访问，直接使用IP可以正常访问。 解决方法在hosts文件中手动添加索引，直接提供域名查询结果，从而绕开DNS。 以配置dl.google.com域名为例，操作步骤如下： 1.获取有效的IP地址通过 IP查询网站，获取dl.google.com域名的IP地址 2.通过ping命令检测各IP地址的有效性和连接速度12345678910➜ ~ ping -c 4 203.208.50.69PING 203.208.50.69 (203.208.50.69): 56 data bytes64 bytes from 203.208.50.69: icmp_seq=0 ttl=115 time=58.021 ms64 bytes from 203.208.50.69: icmp_seq=1 ttl=115 time=81.029 ms64 bytes from 203.208.50.69: icmp_seq=2 ttl=115 time=53.690 ms64 bytes from 203.208.50.69: icmp_seq=3 ttl=115 time=57.790 ms--- 203.208.50.69 ping statistics ---4 packets transmitted, 4 packets received, 0.0% packet lossround-trip min/avg/max/stddev = 53.690/62.633/81.029/10.760 ms -c命令指定ping次数，-c 4 表示ping4次。Mac 下ping命令不设置改参数会一直ping下去，除非用 control + c强制 可以多测试几个IP地址，找到连接时长最短的，即访问速度最快的。 3.在hosts文件中手动添加一条记录Mac下的hosts文件在 /etc/下，操作如下： 终端下输入命令 sudo vim /etc/hosts（不使用sudo命令，打开的文件处于只读状态，无法编辑） 输入登录密码（由于使用了sudo提升为root权限，需要输入密码） 点击键盘上字母 I进入编辑模式，在最后一行输入 203.208.50.69 dl.google.com(格式为IP地址 域名) 点击 esc键退出编辑模式 输入 :wq，按回车 操作完成 4. 测试一下现在可以测试一下下面这个文件能否正常下载 https://dl.google.com/dl/android/maven2/com/android/tools/build/gradle/3.2.0/gradle-3.2.0.jar 关于 maven.google.com域名的设置同上面一致。 注意：由于本方式指定了IP地址，当设置的这个IP地址失效时会导致对应的域名无法访问。 参考解决连不上dl.google.com的问题]]></content>
      <categories>
        <category>android</category>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常处理篇之MIUILOG-_Permission_Denied]]></title>
    <url>%2F3134546857%2F</url>
    <content type="text"><![CDATA[I/ActivityManager: START u0 {act=android.intent.action.SEND cat=[android.intent.category.DEFAULT] typ=image/jpeg flg=0x1b080003 cmp=com.tencent.mm/.ui.tools.ShareImgUI clip={image/jpeg U:file:///storage/emulated/0/linkvisual/image/1569378148032.jpg} (has extras)} from uid 10331 on display 0D/com.android.server.am.ExtraActivityManagerService: MIUILOG- Permission Denied Activity : Intent { act=android.intent.action.SEND cat=[android.intent.category.DEFAULT] typ=image/jpeg flg=0x1b080003 cmp=com.tencent.mm/.ui.tools.ShareImgUI clip={image/jpeg U:file:///storage/emulated/0/linkvisual/image/1569378148032.jpg} (has extras) } pkg : com.aliyun.iotx.iotx_lv_ipc_panel_android uid : 10331 tuid : 1000 参考小米「后台弹出界面权限」最佳适配方案 【开发者】关于默认关闭“后台弹出页面”权限的通知 Purchase : AcquireActivity Intent denied]]></content>
  </entry>
  <entry>
    <title><![CDATA[异常处理篇之TransactionTooLargeException]]></title>
    <url>%2F321269709%2F</url>
    <content type="text"><![CDATA[android.os.TransactionTooLargeExceptionandroid.os.TransactionTooLargeException: data parcel size 725216 bytes 123456789101112131415android.os.TransactionTooLargeException: data parcel size 725216 bytesat android.os.BinderProxy.transactNative(Native Method)at android.os.BinderProxy.transact(Binder.java:506)at android.app.ApplicationThreadProxy.scheduleLaunchActivity(ApplicationThreadNative.java:852)at com.android.server.am.ActivityStackSupervisor.realStartActivityLocked(ActivityStackSupervisor.java:1385)at com.android.server.am.ActivityStackSupervisor.startSpecificActivityLocked(ActivityStackSupervisor.java:1490)at com.android.server.am.ActivityStack.resumeTopActivityInnerLocked(ActivityStack.java:2081)at com.android.server.am.ActivityStack.resumeTopActivityLocked(ActivityStack.java:1594)at com.android.server.am.ActivityStackSupervisor.resumeTopActivitiesLocked(ActivityStackSupervisor.java:2959)at com.android.server.am.ActivityStack.completePauseLocked(ActivityStack.java:1087)at com.android.server.am.ActivityStack.activityPausedLocked(ActivityStack.java:975)at com.android.server.am.ActivityManagerService.activityPaused(ActivityManagerService.java:6932)at android.app.ActivityManagerNative.onTransact(ActivityManagerNative.java:542)at com.android.server.am.ActivityManagerService.onTransact(ActivityManagerService.java:2631)at android.os.Binder.execTransact(Binder.java:453) 问题原因Intent内携带的数据过大 解决方法 将传递的信息封装在一个静态的类中，或则封装在跳转对象的一个静态属性中，效率高，但是耦合性也高！（这种方法在stackoverflow网站看到的，有兴趣可以点击查看详情） 1234Intent intent = new Intent(this,SecondActivity.class);DataSave.setValue(value);//将value设置到静态类DataSave中//SecondActivity.value = value;//或则将value设置到SecondActivity的静态属性中startActivity(intent); 将传递的信息做本地存储，如SP存储、数据库等，然后在跳转对象中取出来，不会提高程序的耦合性，但是效率较低。存储实体类，首先可以使用Gson将实体转为json串(可以使用new Gson().toJson()方法)，然后进行存储，最后在跳转对象中取出再利用Gson转为实体即可(可以使用new Gson().fromJson()方法)。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java位移运算符]]></title>
    <url>%2F3460247515%2F</url>
    <content type="text"><![CDATA[Java中的位移操作符就3个，而且仅对整数类型有效，分别为 &lt;&lt; 左移，右空位补0，相当于乘2 &gt;&gt; 右移（带符号），左空位补符号位（负数补1，正数补0），相当于除2 &gt;&gt;&gt; 右移（无符号），左空位补0 对于32位的int类型，位移超过31时（对于64位的long类型，位移超过63时），编辑工具（intelliJ）会显示warm提示（负数和超范围的数逗被认为是开发者coding错误），但仍可运行。结果等同于 当前位移数%类型长度（整形32，长整型long 64）； 对于位移负数位x，等效于将x+n*类型长度，即将负数位移数转换成小于类型长度的正整数，然后再做位移操作。 看一波Oracle的原文介绍 The Java programming language also provides operators that perform bitwise and bit shift operations on integral types. The operators discussed in this section are less commonly used. Therefore, their coverage is brief; the intent is to simply make you aware that these operators exist. The unary bitwise complement operator “~“ inverts a bit pattern; it can be applied to any of the integral types, making every “0” a “1” and every “1” a “0”. For example, a byte contains 8 bits; applying this operator to a value whose bit pattern is “00000000” would change its pattern to “11111111”. The signed left shift operator “&lt;&lt;“ shifts a bit pattern to the left, and the signed right shift operator “&gt;&gt;“ shifts a bit pattern to the right. The bit pattern is given by the left-hand operand, and the number of positions to shift by the right-hand operand. The unsigned right shift operator “&gt;&gt;&gt;“ shifts a zero into the leftmost position, while the leftmost position after &quot;&gt;&gt;&quot; depends on sign extension. The bitwise &amp; operator performs a bitwise AND operation. The bitwise ^ operator performs a bitwise exclusive OR operation. The bitwise | operator performs a bitwise inclusive OR operation. The following program, BitDemo, uses the bitwise AND operator to print the number “2” to standard output. 123456789&gt; class BitDemo &#123;&gt; public static void main(String[] args) &#123;&gt; int bitmask = 0x000F;&gt; int val = 0x2222;&gt; // prints "2"&gt; System.out.println(val &amp; bitmask);&gt; &#125;&gt; &#125;&gt; 参考Bitwise and Bit Shift Operators Java中的移位运算符]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Centos7中添加新用户并授权sudo操作]]></title>
    <url>%2F3402289417%2F</url>
    <content type="text"><![CDATA[前言最近又新购了一台阿里云的ECS服务器，照着以前写的《Hexo初次使用及部署到云服务器详细指南》中“云端服务器配置Git”一节配好了git服务。其中涉及到了新建用户的操作，但是没有涉及到sudo的操作，这里就借此将新建用户和sudo授权的方式记录下来。 固件信息服务器提供商：阿里云 系统：CentOS Linux release 7.5.1804 web服务：nginx/1.12.2 本地环境：Mac 10.13.6 创建新用户创建用户用到useradd命令： 创建用户：sample 1[root@izuf61enooqdp573q49ywlz ~]# useradd sample 设置该用户密码，Linux会判断输入密码的复杂度，不过可以忽略直接再次输入密码 12345[root@izuf61enooqdp573q49ywlz ~]# passwd sampleChanging password for user sample.New password:BAD PASSWORD: The password is shorter than 7 charactersRetype new password: sudo授权个人用户的权限只可以在本home下有完整权限(比如上面新创建的用户sample只有在/home/sample/目录下有全部权限)，其他目录要看别人授权。而经常需要root用户的权限，这时候sudo可以化身为root来操作。 而新创建的用户不能使用sudo命令，需要在sudoer文件中进行配置。 未配置的结果如下： 1234567891011[sample@izuf61enooqdp573q49ywlz ~]$ sudo dateWe trust you have received the usual lecture from the local SystemAdministrator. It usually boils down to these three things: #1) Respect the privacy of others. #2) Think before you type. #3) With great power comes great responsibility.[sudo] password for sample:sample is not in the sudoers file. This incident will be reported. 使用sudo命令调用date，当输入sample用户的密码后，提示sample用户没有在sudoers文件中。 所以就需要将sample用户添加到sudoers文件中。 使用whereis命令查找sudoers文件的路径。 12[sample@izuf61enooqdp573q49ywlz ~]$ whereis sudoerssudoers: /etc/sudoers /etc/sudoers.d /usr/share/man/man5/sudoers.5.gz 可以看到sudoers在/etc/sudoers，但还有一个/etc/sudoers.d。先去/etc/sudoers看看。在这之前先用su命令切换未root用户进行操作，因为sample用户没有权限修改/etc/文件夹下的内容。 12[sample@izuf61enooqdp573q49ywlz ~]$ suPassword: 进入/etc/目录，并用ll | grep sudoers命令列出/etc/目录下包含sudoers的文件信息 1234[root@izuf61enooqdp573q49ywlz sample]# cd /etc/[root@izuf61enooqdp573q49ywlz etc]# ll | grep sudoers-r--r----- 1 root root 3938 Jun 27 02:07 sudoersdrwxr-x---. 2 root root 4096 Oct 17 10:00 sudoers.d 发现sudoers是一个只写的文件，上面出现过的sudoers.d是一个文件夹，且root用户有全部（读写执行）的权限。 用cat命令查看sudoers文件 1[root@izuf61enooqdp573q49ywlz etc]# cat sudoers 发现最后两行信息如下： 12## Read drop-in files from /etc/sudoers.d (the # here does not mean a comment)#includedir /etc/sudoers.d 该信息提示sudoers文件会将/etc/sudoers.d文件夹下的所有文件读到sudoers文件中，而上面提到“root用户对sudoers.d文件夹及有全部（读写执行）的权限” 所以发现这个后，可以直接用echo命令在sudoers.d文件夹下创建文件。 1[root@izuf61enooqdp573q49ywlz etc]# echo &quot;sample ALL=(ALL) ALL&quot; &gt;&gt; ./sudoers.d/custom_sudoers 之后，在sudoers.d下就有一个custom_sudoers文件。 123[root@izuf61enooqdp573q49ywlz sudoers.d]# lltotal 4-rw-r--r-- 1 root root 28 Oct 18 23:59 custom_sudoers 这时，sample用户就能使用sudo命令了。 不过这样每次使用sudo命令都要输入密码，怎么办呢？ 其实很简单，只要将最后一个ALL修改成NOPASSWD: ALL即可，即sample ALL=(ALL) NOPASSWD: ALL。 最后提一句：在Centos中useradd与adduser一致 adduser软链到了useradd。 12[root@izuf61enooqdp573q49ywlz sudoers.d]# ll /usr/sbin/ | grep useraddlrwxrwxrwx. 1 root root 7 Oct 15 2017 adduser -&gt; useradd 删除用户彻底删除用户和其主目录 测试删除用户：sample 1userdel -r sample 参考在centos7中添加一个新用户，并授权 详解Centos与ubuntu下的useradd与adduser]]></content>
      <categories>
        <category>系统</category>
        <category>linux</category>
        <category>centos7</category>
      </categories>
      <tags>
        <tag>centos7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7使用certbot获取ssl证书]]></title>
    <url>%2F697484412%2F</url>
    <content type="text"><![CDATA[前言之前的文章《NexT主题设置Valine评论系统邮件提醒》介绍了如何在Next主题中配置使用评论邮件提醒。其中主要介绍了一个由zhaojun1998提供的Valine-Admin邮件提醒系统。 由于之前本博客站点是部署在coding上的，并且配置了https的方式，所以在Valine-Admin中也是使用了https方式的请求方式。 而后来coding的黄金会员到期后，coding的静态 Pages服务就有coding的广告，而且导致Google收录无法验证本站点。所以重新购买了台ECS，将站点换到ECS上。而评论系统中使用了https，所以就打算将本站点配置成https的访问方式。 查阅了一些资料后，发现收费的SSL提供商收费基本是按 数千/年收费的，这就太昂贵了啊，所以最终决定使用Let’s Encrypt提供的免费SSL证书。虽说该证书只有90天有效期，但是可以设置定时任务进行更新。 本篇就记录下Let’s Encrypt的配置过程。 固件信息服务器提供商：阿里云 系统：CentOS Linux release 7.5.1804 web服务：nginx/1.12.2 本地环境：Mac 10.13.6 博客站点：hexo 配置过程在讲解配置过程前，先提醒大家将ECS磁盘创建快照，以便在配置出错且不知道如何恢复时可以方便地将系统回退。 创建快照的入口在：进入ECS实例详情 -&gt; 点击左侧“本实例磁盘” -&gt; 右侧磁盘列表上的“创建快照”按钮，即为该磁盘创建快照（备份）。 接下来就具体介绍Let’s Encrypt相关的内容了。 certbot官网操作流程SSL服务商Let’s Encrypt提供了通过certbot脚本申请证书的方式。 certbot官方地址为 https://certbot.eff.org/，Centos7+Nginx的配置方式地址为： https://certbot.eff.org/lets-encrypt/centosrhel7-nginx。也可以通过上面的地址选择对应的web服务和系统的配置方式。 按照官方提供的通过yum命令进行安装的方式，一直无法运行certbot --nginx，主要有如下问题： ImportError: No module named ‘requests.packages.urllib3 DistributionNotFound: The ‘urllib3&lt;1.23,&gt;=1.21.1’ distribution was not found and is required by requests 依照上述issues中的结局方式，都无法解决该问题。最终只得通过先前创建的快照进行回退，使用了pip命令进行安装并成功配置。 pip安装 安装certbot 1pip install certbot 安装certbot的nginx插件 1pip install certbot-nginx 自动配置nginx 1certbot --nginx 输入该命令后，会进行一些交互。 提示输入邮箱，该邮箱会收到ssl证书到期的邮件，所以请正确填写 许可信息确认，貌似输入 A就可以了， A表示agree，即同意他们的许可信息 提示是否将邮箱地址公开给Let’s Encrypt的相关组织，以便收到他们的一些邮件信息 会显示nginx当前已经配置的域名信息，不输入直接按回车键则表示列出的所有域名都配置成https方式；或者输入域名前面的序号并用空格或,进行分隔，则表示仅对选择的域名站点进行https配置 提示 是否将当前的http请求重定向为https请求，1：不重定向,2：重定向。我是选了（输入）2 操作成功 这些交互，都有详细的提示，认真看，不难理解。 这步之后，就可以使用https方式访问了。 注：certbot --nginx命令运行过程中会自动读取配置的域名信息和修改nginx配置信息（上述步骤4和步骤5），如果nginx配置信息中有中文存在（注释中有中文也不行），步骤4中输入完成后会报错直接结束，无法到步骤5，错误信息如下哦： 1certbot UnicodeDecodeError: &apos;ascii&apos; codec can&apos;t decode byte 0xe4 in position 2: ordinal not in range(128) 自动更新certbot --nginx命令运行成功后，即可进行自动更新的配置。 由于Let’s Encrypt证书有效期只有90天，所以配置自动更新还是很有必要的。 在配置之前需要运行如下命令进行是否可以配置自动更新的检测。 1certbot renew --dry-run 如果出现如下内容，则表示测试成功。不懂的话就看有没有Congratulations单词。 123456789- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -** DRY RUN: simulating &apos;certbot renew&apos; close to cert expiry** (The test certificates below have not been saved.)Congratulations, all renewals succeeded. The following certs have been renewed: /etc/letsencrypt/live/www.nhtzj.com/fullchain.pem (success)** DRY RUN: simulating &apos;certbot renew&apos; close to cert expiry** (The test certificates above have not been saved.)- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - cetbot官网上提示可以使用cron job或者systemd timer方式设置定时任务进行更新。 systemd timer方式 进入/usr/lib/systemd/system 1cd /usr/lib/systemd/system 编辑certbot.service文件，如果没有该文件vim会创建该文件 1vim certbot.service 复制并黏贴以下内容，保存 123456[Unit]Description=Let&apos;s Encrypt renewal[Service]Type=oneshotExecStart=/usr/bin/certbot renew --quiet 创建定时器文件 1vim certbot.timer 复制并黏贴一下内容，保存(官方推荐一天两次执行，以确保证书可用，这里选择0/12点) 12345678910[Unit]Description=Twice daily renewal of Let&apos;s Encrypt&apos;s certificates[Timer]OnCalendar=0/12:00:00RandomizedDelaySec=1hPersistent=true[Install]WantedBy=timers.target 激活定时器(设为开机启动) 1systemctl enable certbot.timer 可以使用如下命令查看是否配置成功 12# systemctl is-enabled certbot.timerenabled enabled表示成功。 启动定时 1systemctl start certbot.timer 到这步就配置成了。 cron job方式在centos7 上可以利用crontab 来执行计划任务， 依赖与 crond 的系统服务，这个服务是系统自带的，可以直接查看状态，启动，停止。 本ECS上systemctl status crond命令显示crond.service服务处于活动状态。 1234# systemctl status crond● crond.service - Command Scheduler Loaded: loaded (/usr/lib/systemd/system/crond.service; enabled; vendor preset: enabled) Active: active (running) since Wed 2018-10-17 13:07:49 CST; 7h ago 利用crontab命令查看和设置定时任务。 crontab -u 用户名 -e 编辑用户的定时任务 -u :指定的执行的用户，默认为当前执行命令的用户 比如： 通过Linux终端（Terminal）编辑crontab文件 1crontab -e 输入定时任务命令 123#官网上的提示定时任务#会在每天0点和12点运行一遍0 0,12 * * * python -c &apos;import random; import time; time.sleep(random.random() * 3600)&apos; &amp;&amp; certbot renew 或者自定义的任务 12# 每月1号5时执行执行一次更新，并重启nginx服务器00 05 01 * * /usr/bin/certbot renew --quiet &amp;&amp; /bin/systemctl restart nginx 常用命令更新证书（90天）1certbot renew 查看证书1certbot certificates 示例：12345678910# certbot certificatesSaving debug log to /var/log/letsencrypt/letsencrypt.log- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Found the following certs: Certificate Name: 证书名称 Domains: blog.nhtzj.com unlock.nhtzj.com www.nhtzj.com Expiry Date: 2021-04-23 11:29:35+00:00 (VALID: 89 days) Certificate Path: /etc/letsencrypt/live/证书名称/fullchain.pem Private Key Path: /etc/letsencrypt/live/证书名称/privkey.pem 可以看到当前机器所有域名的证书情况，包括域名、 到期日、证书路径、私钥路径四条信息。 新增域名修改现有的证书，添加新的域名。 比如，你已经有一张域名是 www.nhtzj.com的 SSL 证书，想添加unlock.nhtzj.com，则可以使用下面的命令： 1sudo certbot --expand -d www.nhtzj.com,unlock.nhtzj.com 域名之间要用逗号分隔。 参考CentOS 7 使用certbot自动获取证书并配置nginx使用https centos7.2 利用crontab执行定时计划任务 HTTPS 简介及使用官方工具 Certbot 配置 Let’s Encrypt SSL 安全证书详细教程]]></content>
      <categories>
        <category>系统</category>
        <category>linux</category>
        <category>centos7</category>
      </categories>
      <tags>
        <tag>centos7</tag>
        <tag>https</tag>
        <tag>ssl</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript6学习笔记]]></title>
    <url>%2F2462930587%2F</url>
    <content type="text"><![CDATA[let 和 const 命令let 和 const 用来声明变量。 let 只在let命令所在的代码块内有效 不存在变量提升var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。 暂时性死区 ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 123456789101112131415if (true) &#123; // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123 // 报错 let x = x; // ReferenceError: x is not defined&#125; “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。 12typeof x; // ReferenceErrorlet x; 在相同作用域内不允许重复声明 块级作用域作用域为{}内 块级作用域与函数声明ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。 上面两种函数声明，根据 ES5 的规定都是非法的。 但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。 ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 12345678910function f() &#123; console.log('I am outside!'); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;()); 上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。 123456789// ES5 环境function f() &#123; console.log('I am outside!'); &#125;(function () &#123; function f() &#123; console.log('I am inside!'); &#125; if (false) &#123; &#125; f();&#125;()); ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？ 原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。 允许在块级作用域内声明函数。 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。 同时，函数声明还会提升到所在的块级作用域的头部。 注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。 根据这三条规则，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。 12345678910function f() &#123; console.log('I am outside!'); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f let f = function () &#123; console.log('I am inside!'); &#125; &#125; f();&#125;()); const命令const声明一个只读的常量。一旦声明，常量的值就不能改变。 const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。 const的作用域与let命令相同：只在声明所在的块级作用域内有效。 const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 ES6 声明变量的六种方法ES5 只有两种声明变量的方法：var命令和function命令。 ES6 除了添加let和const命令，还有另外两种声明变量的方法：import命令和class命令。 所以，ES6 一共有 6 种声明变量的方法。 顶层对象的属性顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。 ES6 中，一方面规定，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。 1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android6.0运行时权限相关]]></title>
    <url>%2F1558734619%2F</url>
    <content type="text"><![CDATA[小米Settings.ACTION_APPLICATION_DETAILS_SETTINGS跳转原生权限管理，安全中心里是小米自有权限管理。 代码里去checkPermission()时，会check原生权限；调用某些需要权限的api时(比如AudioManager#startRecord())，MIUI会阻塞check自有权限。 操作原生权限开关只影响android权限相关api的返回，即PERMISSION_GRANTED或PERMISSION_DENIED。想正常用相机等功能，还要打开自有权限开关。 说白了一句话，MIUI的权限管理结合了android 6.0后的原生权限模型和自有模型。（vivo、魅族等手机目前只保留了自有模型） 参考官方文档App permission 系统权限]]></content>
      <categories>
        <category>android</category>
        <category>适配</category>
      </categories>
      <tags>
        <tag>动态权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin学习笔记（未整理）]]></title>
    <url>%2F1864014105%2F</url>
    <content type="text"><![CDATA[函数定义函数定义使用关键字 fun，参数格式为：参数 : 类型 1234567891011121314151617fun sum(a: Int, b: Int): Int &#123; // Int 参数，返回值 Int return a + b&#125;//表达式作为函数体，返回类型自动推断：fun sum1(a: Int, b: Int) = a + bpublic fun sum2(a: Int, b: Int): Int = a + bfun printSum(a: Int, b: Int): Unit &#123; print(a + b)&#125;//如果是返回 Unit类型，则可以省略(对于public方法也是这样)：fun printSum1(a: Int, b: Int) &#123; print(a + b)&#125; 可变长参数函数用 vararg 关键字进行标识 定义常量与变量可变变量定义：var 关键字 1var &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt; 不可变变量定义：val 关键字，只能赋值一次的变量(类似Java中final修饰的变量) 1val &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt; 编译器支持自动类型判断,即声明时可以不指定类型,由编译器判断。 12345678val a: Int = 1val b = 1 // 系统自动推断变量类型为Intval c: Int // 如果不在声明时初始化则必须提供变量类型c = 1 // 明确赋值var x = 5 // 系统自动推断变量类型为Intx += 1 // 变量可修改 字符串$ 表示一个变量名或者变量值 $varName 表示变量值 ${varName.fun()} 表示变量的方法返回值: 123456789fun strFun()&#123; var a=1 val s1="a is $a" println(s1)//a is 1 a=2 val s2="$&#123;s1.replace("is","was")&#125;, but now is $a" println(s2)//a was 1,but now is 2&#125; Kotlin 支持三个引号 “”” 扩起来的字符串，支持多行字符串 123456789101112fun multilineText() &#123; println(""" |aa |fff |ggg |hhh """.trimMargin()) // trimMargin()删除前置空格&#125;fun main(args: Array&lt;String&gt;) &#123; multilineText()&#125; NULL机制检查Kotlin的空安全设计对于声明可为空的参数，在使用时要进行空判断处理，有两种处理方式， 字段后加!!像Java一样抛出空异常， 字段后加?可不做处理返回值为 null或配合?:做空判断处理 12345678//类型后面加?表示可为空var age: String? = "23" //抛出空指针异常val ages = age!!.toInt()//不做处理返回 nullval ages1 = age?.toInt()//age为空返回-1val ages2 = age?.toInt() ?: -1 类型检测及自动类型转换用is运算符检测一个表达式是否某类型的一个实例(类似于Java中的instanceof关键字)。 12345678fun getStringLength(obj: Any): Int? &#123; return if (obj is String) &#123; // 做过类型判断以后，obj会被系统自动转换为String类型 obj.length &#125;else&#123; null &#125;&#125; 或者 1234567fun getStringLength(obj: Any): Int? &#123; if (obj !is String) &#123; return null &#125; // 在这个分支中, `obj` 的类型会被自动转换为 `String` return obj.length&#125; 甚至还可以 123456fun getStringLength(obj: Any): Int? &#123; // 在 `&amp;&amp;` 运算符的右侧, `obj` 的类型会被自动转换为 `String` if (obj is String &amp;&amp; obj.length &gt; 0) return obj.length return null&#125; 区间区间表达式由具有操作符形式 ..的 rangeTo 函数辅以 in和!in形成。 区间是为任何可比较类型定义的，但对于整型原生类型，它有一个优化的实现。以下是使用区间的一些示例: 12345678910111213141516171819202122for (i in 1..4) print(i) // 输出“1234”for (i in 4..1) print(i) // 什么都不输出if (i in 1..10) &#123; // 等同于 1 &lt;= i &amp;&amp; i &lt;= 10 println(i)&#125;if (i in 1 until 10) &#123; // 等同于 1 &lt;= i &amp;&amp; i = 10, 不包含 10 println(i)&#125;// 使用 step 指定步长for (i in 1..4 step 2) print(i) // 输出“13”for (i in 4 downTo 1 step 2) print(i) // 输出“42”// 使用 until 函数排除结束元素for (i in 1 until 10) &#123; // i in [1, 10) 排除了 10 println(i)&#125; 基本数据类型 类型 位宽度 Double 64 Float 32 Long 64 Int 32 Short 16 Byte 8 字面常量下面是所有类型的字面常量： 十进制：123 长整型以大写的 L 结尾：123L 16 进制以 0x 开头：0x0F 2 进制以 0b 开头：0b00001011 注意：8进制不支持 Kotlin 同时也支持传统符号表示的浮点数值： Doubles 默认写法: 123.5, 123.5e10 Floats 使用 f 或者 F 后缀：123.5f 你可以使用下划线使数字常量更易读： 12345val oneMillion = 1_000_000val creditCardNumber = 1234_5678_9012_3456Lval socialSecurityNumber = 999_99_9999Lval hexBytes = 0xFF_EC_DE_5Eval bytes = 0b11010010_01101001_10010100_10010010 比较两个数字Kotlin 中没有基础数据类型，只有封装的数字类型 三个等号 === 表示比较对象地址，两个 == 表示比较两个值大小 位操作符Kotlin的位操作符只可用在Int和Long类型 1234567shl(bits) – 左移位 (Java’s &lt;&lt;)shr(bits) – 右移位 (Java’s &gt;&gt;)ushr(bits) – 无符号右移位 (Java’s &gt;&gt;&gt;)and(bits) – 与or(bits) – 或xor(bits) – 异或inv() – 反向 补充说明：负数的右移操作123456789fun testByteOperation() &#123; var a = -1 println(a.ushr(1))//2147483647 println(a.shr(1))//-1&#125;fun main(args: Array&lt;String&gt;) &#123; testByteOperation()&#125; 负数在计算机中是以补码的形式存储的，即：负数的绝对值取反码后加1。 在Kotlin中int类型位4位，即32字节，所以|b|即1的反码为 加1后为 即-1在计算机中的存储方式（补码）为如下 无符号右移（ushr）即该32位都为数值（最高位不是符号位），右移后高位补0。 所以无符号右移1位:变成如下图所示: 其值为：2^31 - 1=2147483647 带符号右移（shr）即最高位（第31位，位数从0开始）为符号位，不参与位移运算。 右移后高位补与符号位相同的值，即负数补1，正数补0。 所以-1带符号右移1位可以拆分位两步： 除符号位右移一位 空缺的高位（第30位）补1 结果值还是-1。 位操作符应用 判断Int型变量a是奇数还是偶数 12a1 and 1 = 0 // 偶数a1 and 1 = 0 // 奇数 获取Int型变量的第K位(注：K从0开始依次由右往左，以下揭同) 1a1 shr k and 1 将Int型变量的第K位清0 1a1 and ((1 shl k).inv()) 将Int型变量的第K位置1 1a1 or (1 shl k) 平均值（整数） 1(a1 and b1)+((a1 xor b1) shr 1) 不用temp交换两个整数 123a1 = a1 xor b1b1 = b1 xor a1a1 = a1 xor b1 获取绝对值 1234val temp = c1 shr 31(c1 + temp) xor temp//或者//(c1 xor temp) - temp 获取相反数(正&gt;负，负&gt;正) 1c1.inv()+1 Int转byte数组 12345val bytes = ByteArray(4)bytes[0] = (a1 and 0xFF).toByte()bytes[1] = (a1 shr 8 and 0xFF).toByte()bytes[2] = (a1 shr 16 and 0xFF).toByte()bytes[3] = (a1 shr 24 and 0xFF).toByte() 数组数组的创建两种方式：一种是使用函数arrayOf()；另外一种是使用工厂函数。 12345678910fun main(args: Array&lt;String&gt;) &#123; //[1,2,3] val a = arrayOf(1, 2, 3) //[0,2,4] val b = Array(3, &#123; i -&gt; (i * 2) &#125;) //读取数组内容 println(a[0]) // 输出结果：1 println(b[1]) // 输出结果：2&#125; 第一类 arrayOf(vararg elements: T) doubleArrayOf(vararg elements: Double) floatArrayOf(vararg elements: Float) longArrayOf(vararg elements: Long) intArrayOf(vararg elements: Int) charArrayOf(vararg elements: Char) shortArrayOf(vararg elements: Short) byteArrayOf(vararg elements: Byte) booleanArrayOf(vararg elements: Boolean)第二类 Array ByteArray CharArray ShortArray IntArray LongArray FloatArray DoubleArray BooleanArray 条件控制If-else表达式作为表达式 1val max = if (a &gt; b) a else b 把 IF 表达式的结果赋值给一个变量 1234567val max = if (a &gt; b) &#123; println("Choose a") a&#125; else &#123; println("Choose b") b&#125; 使用 in 运算符来检测某个数字是否在指定区间内，区间格式为 x..y ： 12345fun testIfIn(x: Int) &#123; if (x in 1..8) &#123; println("x=$x 在区间内") &#125;&#125; When 表达式等同于Java中的switch其中的else相当于switch中的default 12345678910fun testIfWhen(x: Int) &#123; when (x) &#123; 1 -&gt; &#123; print("选择了") println(1) &#125; 2 -&gt; println("选择了$x") else -&gt; println("x 不是 1 ，也不是 2") &#125;&#125; 多分支相同的方式处理 把多个分支条件放在一起，用逗号分隔 12345678910fun testIfWhenSame(x: Int) &#123; when (x) &#123; 1, 2 -&gt; println("选择了$x") 3 -&gt; &#123; print("选择了 ") println(3) &#125; else -&gt; println("x 不是 1 ，也不是 2，也不是 3") &#125;&#125; 在（in）或者不在（!in）一个区间或者集合中注：不同分支的区间如果有重叠部分，按照分支的先后顺序进入分支后就结束，不会继续后续的符合的分支。如下x=4时，只会进入1..4分支。 123456789fun testIfWhenIn(x: Int) &#123; var validNumbers = intArrayOf(4, 5, 6, 7, 8, 9) when (x) &#123; in 1..4 -&gt; println("选择了$x") in validNumbers -&gt; println("x is valid") !in 10..20 -&gt; println("x is outside the range") else -&gt; println("none of the above") &#125;&#125; 配合is字段判断特定类型检测一个值是（is）或者不是（!is）一个特定类型的值。注意： 由于智能转换，你可以访问该类型的方法和属性而无需 任何额外的检测。 1234567891011121314/** * hasPrefix1 的简写 */fun hasPrefix(x: Any) = when(x) &#123; is String -&gt; x.startsWith("prefix") else -&gt; false&#125;fun hasPrefix1(x: Any): Boolean &#123; return when (x) &#123; is String -&gt; x.startsWith("prefix") else -&gt; false &#125;&#125; 不提供参数不提供参数，所有的分支条件都是简单的布尔表达式，而当一个分支的条件为真时则执行该分支。等同于 if-else if链。 1234567fun testIfWhenNone(x: Int) &#123; when &#123; x.and(1) == 1 -&gt; print("x is odd") x.and(1) == 0 -&gt; print("x is even") else -&gt; print("x is funny") &#125;&#125; 循环控制For 循环or 循环可以对任何提供迭代器（iterator）的对象进行遍历，语法如下: 1for (item in collection) print(item) 获取索引 123456789101112val arr = arrayOf(1, 2, 3, 4)for ((index, value) in arr.withIndex()) &#123; println("the element at $index is $value")&#125;//或for (indexedValue in arr.withIndex()) &#123; println("the element at $&#123;indexedValue.index&#125; is $&#123;indexedValue.value&#125;")&#125;//或for (index in arr.indices) &#123; println("the element at $index is $&#123;arr[index]&#125;")&#125; while 与 do…while 循环与Java中的一致 1234567while( 布尔表达式 ) &#123; //循环内容&#125;do &#123; //代码语句&#125;while(布尔表达式); 返回和跳转Kotlin 有三种结构化跳转表达式： return。默认从最直接包围它的函数或者匿名函数返回。 break。终止最直接包围它的循环。 continue。继续下一次最直接包围它的循环。 Break 、Continue标签在 Kotlin 中任何表达式都可以用标签（label）来标记。 标签的格式为标识符后跟 @ 符号，例如：abc@、fooBar@都是有效的标签。 要为一个表达式加标签，我们只要在其前加标签即可。一般用于多层循环中。 12345678outter@ for (i in 1..4) &#123; for (index in arr.indices) &#123; if (index == 2) &#123; continue@outter &#125; println("outer index is $i,inner element at $index is $&#123;arr[index]&#125;") &#125;&#125; 标签处返回Kotlin 有函数字面量、局部函数和对象表达式。因此 Kotlin 的函数可以被嵌套。 标签限制的 return 允许我们从外层函数返回。 最重要的一个用途就是从 lambda 表达式中返回 1234567891011121314151617181920212223242526//从最直接包围它的函数即 foo 中返回，15fun foo() &#123; val ints = arrayOf(1, 5, 2, 4) ints.forEach &#123; if (it == 2) return print(it) &#125;&#125;//从 lambda 表达式中返回，我们必须给它加标签并用以限制 return，154fun foo1() &#123; val ints = arrayOf(1, 5, 2, 4) ints.forEach lit@&#123; if (it == 2) return@lit print(it) &#125;&#125;//隐藏式标签，该标签与接受该 lambda 的函数同名，效果同foo1()一致，154fun foo2() &#123; val ints = arrayOf(1, 5, 2, 4) ints.forEach &#123; if (it == 2) return@forEach print(it) &#125;&#125; 类和对象类可以有一个 主构造器，以及一个或多个次构造器，主构造器是类头部的一部分，位于类名称之后 1class Person constructor(firstName: String) &#123;&#125; 如果主构造器没有任何注解，也没有任何可见度修饰符，那么constructor关键字可以省略。 12class Person(firstName: String) &#123;&#125; getter 和 setter属性声明的完整语法： 123var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;] [&lt;getter&gt;] [&lt;setter&gt;] getter 和 setter 都是可选 如果属性类型可以从初始化语句或者类的成员函数中推断出来，那就可以省去类型，val不允许设置setter函数，因为它是只读的。 1234var allByDefault: Int? // 错误: 需要一个初始化语句, 默认实现了 getter 和 setter 方法var initialized = 1 // 类型为 Int, 默认实现了 getter 和 setterval simple: Int? // 类型为 Int ，默认实现 getter ，但必须在构造函数中初始化val inferredType = 1 // 类型为 Int 类型,默认实现 getter 示例 1234567891011121314151617181920212223242526class User &#123; var lastName: String = "zhang" get() = field.toUpperCase() var age: Int = 40 set(value) &#123; when &#123; value &lt; 0 -&gt; field = 0 value &gt; 100 -&gt; field = 100 else -&gt; field = value &#125; &#125; fun printUserInfo() &#123; println("user:lastName=$lastName, age= $age") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val user = User() user.age=200 user.printUserInfo() //user:lastName=ZHANG, age= 100&#125; 非空属性必须在定义的时候初始化,kotlin提供了一种可以延迟初始化的方案,使用 lateinit 关键字描述属性 主构造器主构造器中不能包含任何代码，初始化代码可以放在初始化代码段中，初始化代码段使用 init 关键字作为前缀。 12345class Person constructor(firstName: String) &#123; init &#123; println("FirstName is $firstName") &#125;&#125; 注意：主构造器的参数可以在初始化代码段中使用，也可以在类主体n定义的属性初始化代码中使用。 一种简洁语法，可以通过主构造器来定义属性并初始化属性值（可以是var或val）： 123class People(val firstName: String, val lastName: String) &#123; //...&#125; 如果构造器有注解，或者有可见度修饰符，这时constructor关键字是必须的，注解和修饰符要放在它之前。 123456789101112131415161718class Person(val name: String, age: Int, weight: Int) &#123; var mAge: Int = 0 var mWeight = weight init &#123; println("初始化用户：name=$name ,age=$age, weight= $weight") mAge = age &#125; fun printUserInfo() &#123; println("用户：name=$name ,age=$mAge, weight= $mWeight") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; var person = Person("jack", 18, 65) person.printUserInfo()&#125; 次构造函数类也可以有二级构造函数，需要加前缀 constructor: 如果类有主构造函数，每个次构造函数都要，或直接或间接通过另一个次构造函数代理主构造函数。在同一个类中代理另一个构造函数使用 this 关键字 如果一个非抽象类没有声明构造函数(主构造函数或次构造函数)，它会产生一个没有参数的构造函数。构造函数是 public 。如果你不想你的类有公共的构造函数，你就得声明一个空的主构造函数： 12class DontCreateMe private constructor () &#123;&#125; 注意：在 JVM 虚拟机中，如果主构造函数的所有参数都有默认值，编译器会生成一个附加的无参的构造函数，这个构造函数会直接使用默认值。这使得 Kotlin 可以更简单的使用像 Jackson 或者 JPA 这样使用无参构造函数来创建类实例的库。 12&gt; class Customer(val customerName: String = "")&gt; 12345678910111213141516171819202122232425262728293031class Person(val name: String, age: Int, weight: Int) &#123; var mAge: Int = 0 var mWeight = weight var mHeight: Int = 0 init &#123; println("初始化用户：name=$name ,age=$age, weight= $weight") mAge = age &#125; constructor(name: String, age: Int, weight: Int, height: Int) : this(name, age, weight) &#123; mHeight = height println("height= $height") &#125; fun printUserInfo() &#123; println("用户：name=$name, age=$mAge, weight= $mWeight, height= $mHeight") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; var person = Person("jack", 18, 65) person.printUserInfo() var person2 = Person("pander", 10, 60, 100) person2.printUserInfo()// 初始化用户：name=jack ,age=18, weight= 65// 用户：name=jack, age=18, weight= 65, height= 0// 初始化用户：name=pander ,age=10, weight= 60// height= 100// 用户：name=pander, age=10, weight= 60, height= 100&#125; 嵌套类我们可以把类嵌套在其他类中，看以下实例： 1234567891011class Outer &#123; // 外部类 private val bar: Int = 1 class Nested &#123; // 嵌套类 fun foo() = 2 &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val demo = Outer.Nested().foo() // 调用格式：外部类.嵌套类.嵌套类方法/属性 println(demo) // == 2&#125; 内部类内部类使用 inner 关键字来表示。 内部类会带有一个对外部类的对象的引用，所以内部类可以访问外部类成员属性和成员函数。 12345678910111213141516171819class Outer &#123; private val bar: Int = 1 var v = "成员属性" /**嵌套内部类**/ inner class Inner &#123; fun foo() = bar // 访问外部类成员 fun innerTest() &#123; var o = this@Outer //获取外部类的成员变量 println("内部类可以引用外部类的成员，例如：" + o.v) &#125; &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val demo = Outer().Inner().foo() println(demo) // 1 val demo2 = Outer().Inner().innerTest() println(demo2) // 内部类可以引用外部类的成员，例如：成员属性&#125; 匿名内部类使用对象表达式来创建匿名内部类：1234567891011121314151617181920212223242526272829class Test &#123; var v = "成员属性" fun setInterFace(test: TestInterFace) &#123; test.test() &#125;&#125;/** * 定义接口 */interface TestInterFace &#123; fun test()&#125;fun main(args: Array&lt;String&gt;) &#123; var test = Test() /** * 采用对象表达式来创建接口对象，即匿名内部类的实例。 * 这里的参数名称必须为'object' */ test.setInterFace(object : TestInterFace &#123; override fun test() &#123; println("对象表达式创建匿名内部类的实例") &#125; &#125;)&#125; 类的修饰符类的修饰符包括 classModifier 和accessModifier: classModifier: 类属性修饰符，标示类本身特性。 12345abstract // 抽象类 final // 类不可继承，默认属性enum // 枚举类open // 类可继承，类默认是final的annotation // 注解类 accessModifier: 访问权限修饰符 1234private // 仅在同一个文件中可见protected // 同一个文件中或子类可见public // 所有调用的地方都可见internal // 同一个模块中可见 示例 12345678// 文件名：example.ktpackage fooprivate fun foo() &#123;&#125; // 在 example.kt 内可见public var bar: Int = 5 // 该属性随处可见internal val baz = 6 // 相同模块内可见 继承Kotlin 中所有类都继承该 Any 类，它是所有类的超类，对于没有超类型声明的类是默认超类： 1class Example // 从 Any 隐式继承 Any 默认提供了三个函数： 12345equals()hashCode()toString() 注意：Any 不是 java.lang.Object。 如果一个类要被继承，可以使用 open 关键字进行修饰。 123open class Base(p: Int) // 定义基类class Derived(p: Int) : Base(p) 构造函数子类有主构造函数如果子类有主构造函数， 则基类必须在主构造函数中立即初始化。 1234567891011121314151617181920open class Person(var name : String, var age : Int)&#123;// 基类&#125;class Student(name : String, age : Int, var no : String, var score : Int) : Person(name, age) &#123;&#125;// 测试fun main(args: Array&lt;String&gt;) &#123; val s = Student("Runoob", 18, "S12346", 89) println("学生名： $&#123;s.name&#125;") println("年龄： $&#123;s.age&#125;") println("学生号： $&#123;s.no&#125;") println("成绩： $&#123;s.score&#125;")// 学生名： Runoob// 年龄： 18// 学生号： S12346// 成绩： 89&#125; 子类没有主构造函数如果子类没有主构造函数，则必须在每一个二级构造函数中用 super 关键字初始化基类，或者在代理另一个构造函数。初始化基类时，可以调用基类的不同构造方法。 123456789101112131415161718192021222324252627282930313233open class Person(var name: String, var age: Int) &#123;&#125;class Teacher : Person &#123; var mLevel: Int = 0 var category: String? = null constructor(name: String, age: Int, level: Int) : super(name, age) &#123; this.mLevel = level &#125; constructor(name: String, age: Int, mLevel: Int, category: String?) : super(name, age) &#123; this.mLevel = mLevel this.category = category &#125; fun printInfo() &#123; println("teacher: name=$name, age= $age, level=$mLevel, category=$category") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val teacher = Teacher("jack", 30, 2) teacher.printInfo() //teacher: name=jack, age= 30, level=2, category=null val teacherF = Teacher("Flo", 34, 3,"English") teacherF.printInfo() //teacher: name=Flo, age= 34, level=3, category=English&#125; 重写在基类中，使用fun声明函数时，此函数默认为final修饰，不能被子类重写。如果允许子类重写该函数，那么就要手动添加 open 修饰它, 子类重写方法使用 override 关键词 如果有多个相同的方法（继承或者实现自其他类，如A、B类），则必须要重写该方法，使用super范型去选择性地调用父类的实现。 123456789101112131415161718192021222324252627282930313233open class A &#123; open fun f() &#123; print("A:f") &#125; fun a() &#123; print("A:a") &#125;&#125;interface B &#123;//interface中的成员变量默认都是open fun f() &#123; print("B:f") &#125; fun b() &#123; print("B:b") &#125;&#125;class C : A(), B &#123; override fun f() &#123; super&lt;A&gt;.f()//调用 A.f() super&lt;B&gt;.f()//调用 B.f() &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val c = C() c.f()//A:fB:f&#125; 属性重写属性重写使用 override 关键字，属性必须具有兼容类型，每一个声明的属性都可以通过初始化程序或者getter方法被重写 1234567open class Foo &#123; open val x: Int get &#123; …… &#125;&#125;class Bar1 : Foo() &#123; override val x: Int = ……&#125; 你可以用一个var属性重写一个val属性，但是反过来不行(属性扩大)。因为val属性本身定义了getter方法，重写为var属性会在衍生类中额外声明一个setter方法 你可以在主构造函数中使用 override 关键字作为属性声明的一部分: 123456789interface Foo &#123; val count: Int&#125;class Bar1(override val count: Int) : Fooclass Bar2 : Foo &#123; override var count: Int = 0&#125; 接口Kotlin 接口与 Java 8 类似，使用 interface 关键字定义接口，允许方法有默认实现： 1234567interface MyInterface &#123; fun bar() // 未实现 fun foo() &#123; //已实现 // 可选的方法体 println("foo") &#125;&#125; 实现接口时，必须重写的几种类别： 抽象方法、抽象成员变量 多个接口时，遇到同一方法继承多个实现 实现接口一个类或者对象可以实现一个或多个接口，多个接口时用,分隔。 12345class Child : MyInterface, OtherInterface &#123; override fun bar() &#123; // 方法体 &#125;&#125; 接口中的属性接口中的属性只能是抽象的，不允许初始化值，接口不会保存属性值，实现接口时，必须重写属性： 1234567interface MyInterface&#123; var name:String //name 属性, 抽象的&#125; class MyImpl:MyInterface&#123; override var name: String = "runoob" //重载属性&#125; 扩展Kotlin 可以对一个类的属性和方法进行扩展，且不需要继承或使用 Decorator 模式。 扩展是一种静态行为，对被扩展的类代码本身不会造成任何影响。 扩展函数扩展函数可以在已有类(系统类、自己写的类)中添加新的方法，不会对原类做修改，扩展函数定义形式： 123fun receiverType.functionName(params)&#123; body&#125; receiverType：表示函数的接收者，也就是函数扩展的对象 functionName：扩展函数的名称 params：扩展函数的参数，可以为NULL 示例： 12345678910111213141516class User(var name:String)fun User.Print()&#123; println("user: name= $name")&#125;fun Student.print()&#123; //Student类可以到上面的代码中查看 println("")&#125;fun main(args: Array&lt;String&gt;) &#123; val user = User("jack") user.Print() val stu = Student("Runoob", 18, "S12346", 89) stu.print()&#125; 扩展函数是静态解析的扩展函数是静态解析的，并不是接收者类型的虚拟成员，在调用扩展函数时，具体被调用的的是哪一个函数，由调用函数的的对象表达式来决定的，而不是动态的类型决定的: 12345678910111213141516open class Jclass D: J()fun J.foo() = "j" // 扩展函数 foofun D.foo() = "d" // 扩展函数 foofun printFoo(j: J) &#123; println(j.foo()) // 类型是 J 类&#125;fun main(args: Array&lt;String&gt;) &#123; printFoo(D())//j&#125; 若扩展函数和成员函数一致，则使用该函数时，只会使用成员函数。 1234567891011class P &#123; fun foo() &#123; println("成员函数") &#125;&#125;fun P.foo() &#123; println("扩展函数") &#125;//Extension is shadowed by a memberfun main(args: Array&lt;String&gt;) &#123; val p = P() p.foo()//成员函数&#125; 扩展一个空对象在扩展函数内， 可以通过 this 来判断接收者是否为 NULL,这样，即使接收者为 NULL,也可以调用扩展函数。例如: 12345678910fun Any?.toString(): String &#123; if (this == null) return "null" // 空检测之后，“this”会自动转换为非空类型，所以下面的 toString() // 解析为 Any 类的成员函数 return toString()&#125;fun main(arg:Array&lt;String&gt;)&#123; var t = null println(t.toString())&#125; 扩展的作用域通常扩展函数或属性定义在顶级包下: 123package foo.barfun Baz.goo() &#123; …… &#125; 要使用所定义包之外的一个扩展, 通过import导入被扩展的类和扩展的函数名进行使用: 12345678910package com.example.usageimport foo.bar.Bazimport foo.bar.goo // 导入所有名为 goo 的扩展 // 或者import foo.bar.* // 从 foo.bar 导入一切fun usage(baz: Baz) &#123; baz.goo()&#125; 数据类Kotlin 可以创建一个只包含数据的类，关键字为 data： 1data class User(val name: String, val age: Int) 编译器会自动的从主构造函数中根据所有声明的属性提取以下函数： equals() / hashCode() toString() 格式如 &quot;User(name=John, age=42)&quot; componentN() functions 对应于属性，按声明顺序排列 copy() 函数 如果这些函数在类中已经被明确定义了，或者从超类中继承而来，就不再会生成。 为了保证生成代码的一致性以及有意义，数据类需要满足以下条件： 主构造函数至少包含一个参数。 所有的主构造函数的参数必须标识为val 或者 var ; 数据类不可以声明为 abstract, open, sealed 或者 inner; 数据类不能继承其他类 (但是可以实现接口)。 复制复制使用 copy() 函数，我们可以使用该函数复制对象并修改部分属性, 对于上文的 User 类，其实现会类似下面这样： 1fun copy(name: String = this.name, age: Int = this.age) = User(name, age) 数据类以及解构声明组件函数允许数据类在解构声明中使用： 1234567891011data class Chinese(val name: String, val age: Int)fun main(args: Array&lt;String&gt;) &#123; val zj = Chinese("浙江", age = 100) val nb = zj.copy(name = "宁波") println(zj)//Chinese(name=浙江, age=100) println(nb)//Chinese(name=宁波, age=100) val (name,age)=zj//结构声明 println("$name, $age years of age")//浙江, 100 years of age&#125; 密封类密封类用来表示受限的类继承结构：当一个值为有限几种的类型, 而不能有任何其他类型时。在某种意义上，他们是枚举类的扩展：枚举类型的值集合 也是受限的，但每个枚举常量只存在一个实例，而密封类 的一个子类可以有可包含状态的多个实例。 声明一个密封类，使用 sealed 修饰类，密封类可以有子类，但是所有的子类都必须要内嵌在密封类中。 sealed 不能修饰 interface ,abstract class(会报 warning,但是不会出现编译错误)]]></content>
      <categories>
        <category>android</category>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NexT主题设置Valine评论系统邮件提醒]]></title>
    <url>%2F3315416634%2F</url>
    <content type="text"><![CDATA[前言今天无意间看到很久之前写的一篇文章有新的评论，而评论时间呢也是10天以前的。这就有点伤了啊，别人兴致冲冲地提了疑惑，而我却10天后才看到。经过这一茬，意识到评论提醒功能的重要性。由于我使用的是hexo+NexT主题+Valine评论系统，自然而然地就去Valine官网看了看，没想到还真有提醒的功能「邮件提醒」。 这里就给大家讲讲Valine中如何配置邮件提醒功能。 Valine邮件提醒Valine评论功能是基于Leancloud的，Valine评论功能还不能跑起来的可以看看我之前写的文章《Hexo使用NexT主题及配置》，其中就有详细的使用说明，这里就不展开了。 Valine官方提供的邮件提醒功能是基于Leancloud的密码重置邮件提醒，操作步骤如下： 进入Leancloud&gt;选择你的评论所存放的应用&gt;设置&gt;邮件模板，按下图设置好用于重置密码的邮件主题&gt;然后保存: 修改邮件主题：你在 的评论收到了新的评论 修改内容：将下面的代码复制到“内容”中，并将其中的你的网址首页链接改为你的网址首页链接。 12345&lt;p&gt;Hi, &#123;&#123;username&#125;&#125;&lt;/p&gt;&lt;p&gt;你在 &#123;&#123;appname&#125;&#125; 的评论收到了新的回复，请点击查看：&lt;/p&gt;&lt;p&gt;&lt;a href="你的网址首页链接" style="display: inline-block; padding: 10px 20px; border-radius: 4px; background-color: #3090e4; color: #fff; text-decoration: none;"&gt;马上查看&lt;/a&gt;&lt;/p&gt; 点击“保存”按钮 修改NexT主题配置文件，搜索valine（快速定位），将其中的notify改为true。 12345678910111213# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: true appid: gaKW5SWAvf7NBolU9wFbxN8O-gzGxoHsz appkey: susRJyHS8Fq1SyKXg0r9ad65 notify: true # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: 您的评论可以一针见血 (*^ω^*)~~ # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size 注意事项 发送次数过多，可能会暂时被Leancloud 屏蔽邮件发送功能 由于邮件提醒功能使用的Leancloud的密码重置邮件提醒，只能传递昵称、邮箱两个属性，所以邮件提醒链接无法直达指定文章页。请悉知。 开启邮件提醒会默认开启验证码选项。 该功能目前还在测试阶段，谨慎使用。 目前邮件提醒正处于测试阶段，仅在子级对存在邮件地址的父级发表评论时发送邮件 第三方支持这里重点讲一下第三方邮件提醒：Valine-Admin (by @zhaojun1998) 这也先需要将Valine的评论功能成功跑起来。 然后进入 Leancloud 对应的 Valine 应用中。 点击 云引擎 -&gt; 设置 填写代码库并保存：https://github.com/zhaojun1998/Valine-Admin 切换到部署标签页，分支使用 master，点击部署即可： 设置云引擎的环境变量 必选参数 SITE_NAME : 网站名称。 SITE_URL : 网站地址, 最后不要加 / 。 SMTP_USER : SMTP 服务用户名，一般为邮箱地址。 SMTP_PASS : SMTP 密码，一般为授权码，而不是邮箱的登陆密码，请自行查询对应邮件服务商的获取方式 SMTP_SERVICE : 邮件服务提供商，支持 QQ、163、126、Gmail、&quot;Yahoo&quot;、...... ，全部支持请参考 : Nodemailer Supported services。 — 如这里没有你使用的邮件提供商，请查看自定义邮件服务器 SENDER_NAME : 寄件人名称。 由于我使用的是我自己的企业邮箱，所以这边的SMTP_SERVICE就不适用了，需要用这三个参数替换：SMTP_HOST、SMTP_PORT、SMTP_SECURE。 详细说明如下： SMTP_HOST : 邮件服务提供商 SMTP 地址，如 qq : smtp.qq.com，此项需要自行查询或询问其服务商。 SMTP_PORT : 邮件服务提供商 SMTP 端口, 此项需要自行查询或询问其服务商。 SMTP_SECURE : 是否启用加密, 默认为 true，一般不需要设置，如有特殊请自行配置。 此项需要自行查询或询问其服务商。 如果也同我一样使用阿里云企业邮箱，SMTP_HOST、SMTP_PORT、SMTP_SECURE可以照我的写。 可以看到上图中，我的自定义环境变量还多了2个，分别是： TO_EMAIL：这个是填收邮件提醒的邮箱地址，若没有这个字段，则将邮件发到SMTP_USER。 TEMPLATE_NAME：设置提醒邮件的主题，目前内置了两款主题，分别为 default 与 rainbow。默认为 default 。 Web 评论管理此项目还为 Valine 提供了更方便的评论管理功能，可以在 web 端对评论进行查看与删除操作。配置方式如下。 后台登录需要账号密码，需要在这里设置，只需要填写 email、password、username，这三个字段即可, 使用 email 作为账号登陆即可。（为了安全考虑，此 email 必须为配置中的 SMTP_USER 或 TO_EMAIL， 否则不允许登录） Web 后台目前仅有 查看 与 删除 功能 LeanCloud 休眠策略免费版的 LeanCloud 容器，是有强制性休眠策略的，不能 24 小时运行： 每天必须休眠 6 个小时 30 分钟内没有外部请求，则休眠。 休眠后如果有新的外部请求实例则马上启动（但激活时此次发送邮件会失败）。 分析了一下上方的策略，如果不想付费的话，最佳使用方案就设置定时器，每天 7 - 23 点每 20 分钟访问一次，这样可以保持每天的绝大多数时间邮件服务是正常的。 附 Linux crontab 定时器代码： 1*/20 7-23 * * * curl https://你配置的域名前缀.leanapp.cn 注 : 此 crontab 不是 LeanCloud 后台的定时任务，如果你没有 Linux 服务器来配置此定时器，那么可以在此 issues 中回复zhaojun1998，让他帮你加上。 注更新新版本与更改环境变量均需要重启容器后生效。 重启容器]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>valine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View之Paint]]></title>
    <url>%2F2732738906%2F</url>
    <content type="text"><![CDATA[前言本篇对Paint的一些常用方法和具有特殊效果的几个方法做一下的总结。 主要围绕以下几点展开说明： 基础使用 颜色 setXfermode()方法 文本 基础使用setAntiAlias(boolean aa)该属性在上文 《自定义View之Canvas.drawXXX()》中也有说明。 抗锯齿。让图形和文字的边缘更加平滑。 也可在 new Paint() 的时候加上一个 Paint.ANTI_ALIAS_FLAG 参数，进行设置。 1Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG); 锯齿出现的主要原因是屏幕的分辨率过低，使得绘制的边缘出现颗粒化。抗锯齿效果是修改图形边缘处的像素颜色，从而让图形在肉眼看来具有更加平滑的感觉。 setStyle(Style style)设置画笔样式，系统提供了3种： Paint.Style.FILL :0，填充模式，是paint的默认模式 Paint.Style.STROKE :1，画线模式 Paint.Style.FILL_AND_STROKE :2，填充完后画线 所以drawCircle时，paint为STROKE样式，则画出来的是一个圆环。 12paint.setStyle(Paint.Style.STROKE); // Style 修改为画线模式canvas.drawCircle(300, 300, 200, paint); FILL_AND_STROKE样式，相当于是先FILL模式绘制，再STROKE模式绘制。可以通过设置setStrokeWidth(float width)来设置一个较大的线条宽度来查看效果。 线条形状设置线条形状的一共有 4 个方法：setStrokeWidth(float width), setStrokeCap(Paint.Cap cap), setStrokeJoin(Paint.Join join), setStrokeMiter(float miter) 。 这4个方法都需要在setStyle(Style style)为STROKE或FILL_AND_STROKE模式下有效。 setStrokeWidth(float width)设置线条的宽度。 当传入width=0时，宽度永远为1像素，不会因为matrix的作用而改变宽度大小。 setStrokeCap(Cap cap)设置线头形状，系统提供了三种： 1234567891011121314151617/** * The stroke ends with the path, and does not project beyond it. * 平头，在线条结束处的平面 */BUTT (0),/** * The stroke projects out as a semicircle, with the center at the * end of the path. * 半圆，以线条结束处的中心为圆心，绘制半圆 */ROUND (1),/** * The stroke projects out as a square, with the center at the end * of the path. * 方头， */SQUARE (2); 当线条宽度较细时，效果不明显，或者是没有效果（比如宽度为1时）。 下方是三者效果演示： 12345678910111213141516171819202122mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);//画线用mTextPaint = new Paint();//画字用mTextPaint.setTextSize(26);mPaint.setStyle(Paint.Style.STROKE);mPaint.setStrokeWidth(40);mPaint.setStrokeCap(Paint.Cap.BUTT);canvas.drawLine(100, 100, 400, 100, mPaint);canvas.drawText("BUTT,平头", 500, 100, mTextPaint);mPaint.setStrokeCap(Paint.Cap.ROUND);canvas.drawLine(100, 160, 400, 160, mPaint);canvas.drawText("ROUND,圆头", 500, 160, mTextPaint);mPaint.setStrokeCap(Paint.Cap.SQUARE);canvas.drawLine(100, 220, 400, 220, mPaint);canvas.drawText("SQUARE,方头", 500, 220, mTextPaint);//绘制红色虚线mPaint.setColor(Color.RED);mPaint.setStrokeWidth(2);mPaint.setPathEffect(new DashPathEffect(new float[]&#123;10, 10&#125;, 10));canvas.drawLine(400, 0, 400, 400, mPaint); 虚线左边是线的实际长度，虚线右边是线头。有了虚线作为辅助，可以清楚地看出 BUTT 和 SQUARE 的区别。 setStrokeJoin(Join join)设置拐角连接处形状。 系统提供了3种： 123456789101112131415/** * The outer edges of a join meet at a sharp angle * 尖角，拐角处通过延伸两遍形成尖角 */MITER (0),/** * The outer edges of a join meet in a circular arc. * 圆角，用圆补全拐角 */ROUND (1),/** * The outer edges of a join meet with a straight line * 平角，拐角处直接用直线连接 */BEVEL (2); 具体效果如下： 123456789101112131415161718192021222324252627282930mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);mPaint.setStyle(Paint.Style.STROKE);mPath = new Path();//尖拐角mPaint.setStrokeWidth(16);mPaint.setStrokeJoin(Paint.Join.MITER);mPath.moveTo(100, 100);mPath.rLineTo(100, 0);mPath.rLineTo(-50, 50);canvas.drawPath(mPath, mPaint);//平拐角mPaint.setStrokeJoin(Paint.Join.BEVEL);mPath.reset();mPath.moveTo(250, 100);mPath.rLineTo(100, 0);mPath.rLineTo(-50, 50);canvas.drawPath(mPath, mPaint);//圆拐角mPaint.setStrokeJoin(Paint.Join.ROUND);mPath.reset();mPath.moveTo(400, 100);mPath.rLineTo(100, 0);mPath.rLineTo(-50, 50);canvas.drawPath(mPath, mPaint);//两条线canvas.drawLines(new float[]&#123;550,100,650,100,650,100,600,150&#125;,mPaint); 从左到右依次为：尖角，平角，圆角，两线段 setStrokeMiter(float miter)在setStrokeJoin()为MITER时，设置尖角的最大延长值。当超过这个值时，剩余的延长线用BEVEL模式直接截断。 其中参数miter的计算如下： 即：miter = 1 / sin ( θ / 2 ) 。其中θ为两遍夹角。 简单来讲就是：miter值越大，在夹角越小的情况下就越不会被截。 setPathEffect(PathEffect effect)设置图形显示效果。 PathEffect有6个子类，可以简单分为两类： 单一效果 CornerPathEffect 线段转角处用圆角过度 DiscretePathEffect 把线条进行随机的离散 DashPathEffect 用虚线来绘制线条 PathDashPathEffect 用Path 来绘制「虚线」 组合效果 SumPathEffect 用两种效果来分别绘制 ComposePathEffect 用两种效果组合成一种组合效果绘制 CornerPathEffect线段转角处用圆角过度 构造方法 1CornerPathEffect(float radius) 通过radius参数为圆角半径，用于控制转角处用圆角效果。radius越大，圆角越大越明显。 123456PathEffect pathEffect = new CornerPathEffect(20); paint.setPathEffect(pathEffect);...canvas.drawPath(path, paint); DiscretePathEffect把线条进行随机的离散。 构造方法 1DiscretePathEffect(float segmentLength, float deviation) segmentLength：线段长度 deviation：偏离量 DiscretePathEffect效果即：用segmentLength长度的线段并随机偏移从而拼成原大致图形，线段的离散偏移由deviation的大小决定。 DashPathEffect用虚线绘制图形。 构造方法 1DashPathEffect(float intervals[], float phase) intervals 间隔数组，即虚线的样式，数组长度必须是非0偶数。数组下标为偶数的为绘制线段的长度，奇数则为空格的长度。 phase 偏移量， 正数：在0的基础上，虚线的绘制效果往左移动phase个长度 负数：在0的基础上，虚线的绘制效果往右移动phase个长度 类似于phase=0时，数组为[1,2,3,4,5,6] phase=2时，数组为[3,4,5,6,1,2] phase=-2时，数组为[5,6,1,2,3,4] PathDashPathEffect在DashPathEffect的基础上使用自定义的path来绘制DashPathEffect中的横线。 构造方法 1PathDashPathEffect(Path shape, float advance, float phase, Style style) shape ：自定义的path用来绘制DashPathEffect中的横线 advance ：两个相邻的 shape 段起点之间的间隔 phase ：偏移量，同DashPathEffect种的一致 style ：指定拐弯改变的时候 shape 的转换方式，是PathDashPathEffect内的一个美枚举类型，有3个： TRANSLATE ：位移 ROTATE ：旋转 MORPH ：变体 123456789101112131415mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);mPaint.setStyle(Paint.Style.STROKE); PathEffect pathEffect;// pathEffect = new CornerPathEffect(100);// pathEffect = new DiscretePathEffect(10, 1);// pathEffect = new DashPathEffect(new float[]&#123;20, 10, 5, 10&#125;, -13);Path dashPath = new Path(); // 使用一个三角形来做 dashdashPath.rLineTo(10,20);dashPath.rLineTo(-20,0);dashPath.close(); //闭合图形pathEffect = new PathDashPathEffect(dashPath, 40, 0, PathDashPathEffect.Style.TRANSLATE);mPaint.setPathEffect(pathEffect);canvas.drawRoundRect(100, 100, 600, 400, 100, 100,mPaint); 其中的close()方法的效果在 《自定义View之Path》中有具体说明，用于封闭当前子图形，相当于lineTo(起点坐标) 。 SumPathEffect构造方法 1SumPathEffect(PathEffect first, PathEffect second) 分别用first、second两种效果绘制，绘制结果是：first效果的一个图形 + second效果的一个图形。 1234567PathEffect dashEffect = new DashPathEffect(new float[]&#123;20, 10&#125;, 0); PathEffect discreteEffect = new DiscretePathEffect(20, 5); pathEffect = new SumPathEffect(dashEffect, discreteEffect);...canvas.drawPath(mPath, mPaint); ComposePathEffect构造方法 1ComposePathEffect(PathEffect outerpe, PathEffect innerpe) e.g. outer(inner(path)) 是innerpe和outerpe两种效果的组合结果，在innerpe效果的基础上使用outerpe效果绘制。 1234567PathEffect dashEffect = new DashPathEffect(new float[]&#123;20, 10&#125;, 0); PathEffect discreteEffect = new DiscretePathEffect(20, 5); pathEffect = new ComposePathEffect(dashEffect, discreteEffect);...canvas.drawPath(mPath, mPaint); setDither(boolean dither)设置是否使用图像抖动。false：取消抖动；true：设置抖动。 setFilterBitmap(boolean filter)设置是否使用双线性过滤来绘制 Bitmap 。 图像在放大绘制的时候，默认使用的是最近邻插值过滤，这种算法简单，但会出现马赛克现象；而如果开启了双线性过滤，就可以让结果图像显得更加平滑。 setShadowLayer(float radius, float dx, float dy, int shadowColor)在绘制内容下添加阴影效果。 各参数作用： radius：阴影半径；值越大，阴影延伸越多。radius=0时，不绘制阴影效果。 dx：阴影x轴方向偏移量 dy：阴影y轴方向偏移量 shadowColor：阴影颜色 官方注释： 123456789101112131415/** * This draws a shadow layer below the main layer, with the specified * offset and color, and blur radius. If radius is 0, then the shadow * layer is removed. * &lt;p&gt; * Can be used to create a blurred shadow underneath text. Support for use * with other drawing operations is constrained to the software rendering * pipeline. * &lt;p&gt; * The alpha of the shadow will be the paint's alpha if the shadow color is * opaque, or the alpha from the shadow color if not. */public void setShadowLayer(float radius, float dx, float dy, int shadowColor) &#123; nSetShadowLayer(mNativePaint, radius, dx, dy, shadowColor);&#125; 其中提到了以下几点： radius=0时，取消阴影效果 文本都可以使用阴影效果 文本外的其他图形，如果需要使用阴影效果，必须关闭硬件加速 阴影透明度值的来源：参数shadowColor中不带透明度时，使用画笔中的透明度；参数shadowColor中带透明度时，使用shadowColor中的透明度 如果要清除阴影层，使用 clearShadowLayer() 。 123456/** * Clear the shadow layer. */public void clearShadowLayer() &#123; setShadowLayer(0, 0, 0, 0);&#125; setMaskFilter(MaskFilter maskfilter)为之后的绘制设置 MaskFilter。上一个方法 setShadowLayer() 是设置的在绘制层下方的附加效果；而这个 MaskFilter 和它相反，设置的是在绘制层上方的附加效果。 该属性需要关闭硬件加速，才能有效果。 MaskFilter有两个子类：BlurMaskFilter, EmbossMaskFilter BlurMaskFilter(float radius, Blur style)模糊效果。 参数说明 radius：模糊的半径（值越大，模糊范围越大） style：模糊类型，共4种 NORMAL：内外都模糊绘制，内部颜色变淡 OUTER：内部不绘制，外部模糊 INNER：内部模糊，外部不绘制 SOLID：内部正常绘制，外布模糊 1234567891011121314151617181920212223242526272829303132mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);mPaint.setColor(Color.RED);//绘制辅助线canvas.drawLine(100, 0, 100, 2000, mPaint);canvas.drawLine(500, 0, 500, 2000, mPaint);//绘制原图canvas.drawBitmap(mBitmap, 100, 100, mPaint);MaskFilter maskFilter;//OUTER,radius=100maskFilter = new BlurMaskFilter(100, BlurMaskFilter.Blur.OUTER);mPaint.setMaskFilter(maskFilter);canvas.drawBitmap(mBitmap, 500, 100, mPaint);//NORMAL,radius=50maskFilter = new BlurMaskFilter(50, BlurMaskFilter.Blur.NORMAL);mPaint.setMaskFilter(maskFilter);canvas.drawBitmap(mBitmap, 100, 500, mPaint);//OUTER,radius=50maskFilter = new BlurMaskFilter(50, BlurMaskFilter.Blur.OUTER);mPaint.setMaskFilter(maskFilter);canvas.drawBitmap(mBitmap, 500, 500, mPaint);//SOLID,radius=50maskFilter = new BlurMaskFilter(50, BlurMaskFilter.Blur.SOLID);mPaint.setMaskFilter(maskFilter);canvas.drawBitmap(mBitmap, 100, 900, mPaint);//INNER,radius=50maskFilter = new BlurMaskFilter(50, BlurMaskFilter.Blur.INNER);mPaint.setMaskFilter(maskFilter);canvas.drawBitmap(mBitmap, 500, 900, mPaint); EmbossMaskFilter(float[] direction, float ambient, float specular, float blurRadius)设置浮雕效果。Api28开始deprecated（不推荐使用）。 direction：3个数据的数组，[x,y,z]，代表光照方向。 ambient：环境光的强度，数值范围是 0 到 1 specular：炫光系数，例如：8 blurRadius：照明前的模糊量，例如：3 12345mTextPaint = new Paint(Paint.ANTI_ALIAS_FLAG);mTextPaint.setTextSize(96);MaskFilter maskFilter = new EmbossMaskFilter(new float[]&#123;1, 1, 1&#125;, 0.1f, 1f, 5f);mTextPaint.setMaskFilter(maskFilter);canvas.drawText("Hello World", 50, 200, mTextPaint); getFillPath(Path src, Path dst)获取src的实际path dst； 所谓实际 Path ，指的就是 drawPath() 的绘制内容的轮廓，要算上线条宽度和设置的 PathEffect。 方法的参数里，src 是原 Path ，而 dst 就是实际 Path 的保存位置。 getFillPath(src, dst) 会计算出实际 Path，然后把结果保存在 dst 里。 该方法返回结果为boolean类型。true：填充dst；false：dst宽度为0（发际线）。 1234567891011121314/** * Applies any/all effects (patheffect, stroking) to src, returning the * result in dst. The result is that drawing src with this paint will be * the same as drawing dst with a default paint (at least from the * geometric perspective). * * @param src input path * @param dst output path (may be the same as src) * @return true if the path should be filled, or false if it should be * drawn with a hairline (width == 0) */public boolean getFillPath(Path src, Path dst) &#123; return nGetFillPath(mNativePaint, src.readOnlyNI(), dst.mutateNI());&#125; getTextPath(String text, int start, int end, float x, float y, Path path) / getTextPath(char[] text, int index, int count, float x, float y, Path path)获取「文字的 Path」。 文字的绘制，虽然是使用 Canvas.drawText()方法，但其实在下层，文字信息全是被转化成图形，对图形进行绘制的。 getTextPath() 方法，获取的就是目标文字所对应的 Path 。这个就是所谓「文字的 Path」。 颜色setColor(@ColorInt int color)、setARGB(int a, int r, int g, int b)、setAlpha(int a)直接设置颜色。setARGB()与setAlpha()的参数取值范围为[0,255]。 setShader(Shader shader)设置着色器。 参数shader为null时，用于清除之前设置的shader效果。 这里并非直接使用shader类，而是使用它的子类。 shader有5个直接子类：BitmapShader, ComposeShader, LinearGradient, RadialGradient, SweepGradient LinearGradient线性渐变效果。有两个构造方法： LinearGradient(float x0, float y0, float x1, float y1, @NonNull @ColorInt int colors[], @Nullable float positions[], @NonNull TileMode tile) LinearGradient(float x0, float y0, float x1, float y1, @ColorInt int color0, @ColorInt int color1, @NonNull TileMode tile) 两构造方法参数相同之处： x0, y0：线性渐变开始坐标 x1, y1：线性渐变结束坐标 tile：用于处理处理x0, y0和 x1, y1之外的颜色效果。共3种类型，在下面会详细介绍。 不同之处： 第一个构造方法： colors[]：整形数组，用于存放各个颜色 positions[]：用于设置对应colors[]中位置处颜色的相对位置，取值范围[0,1]。当该参数为null时，colors[]中的颜色在渐变过程中均匀出现。 比如： 123int[] colors = &#123;Color.GRAY, Color.RED, Color.YELLOW&#125;;float[] positions = &#123;0.2f, 0.4f, 0.8f&#125;;mLineraGradient = new LinearGradient(0, 0, mViewWidth, 0, colors, positions, Shader.TileMode.CLAMP); 其中的positions代表： 在当前view坐标内的(0,0)到(mViewWidth,0)中，在20%处为GRAY，40%处为RED，80%处为YELLOW。 第二个构造方法： color0：渐变开始颜色 color1：渐变结束颜色 也就是说第二个构造方法只有2种颜色，第一个构造方法可以指定数个渐变颜色。 TileMode的3种类型： 123456789101112131415161718192021222324public enum TileMode &#123; /** * replicate the edge color if the shader draws outside of its * original bounds * 边缘拉伸 */ CLAMP (0), /** * repeat the shader's image horizontally and vertically * 在水平和垂直方向上重复 */ REPEAT (1), /** * repeat the shader's image horizontally and vertically, alternating * mirror images so that adjacent images always seam * 以镜像方式在水平和垂直方向上重复 */ MIRROR (2); TileMode(int nativeInt) &#123; this.nativeInt = nativeInt; &#125; final int nativeInt;&#125; CLAMP REPEAT MIRROR LinearGradient可以用于TextView文本的闪动效果。 RadialGradient从中心辐射。 构造方法： RadialGradient(float centerX, float centerY, float radius, @NonNull @ColorInt int colors[], @Nullable float stops[], @NonNull TileMode tileMode) RadialGradient(float centerX, float centerY, float radius, @ColorInt int centerColor, @ColorInt int edgeColor, @NonNull TileMode tileMode) 与LinearGradient类似，其中第一个构造方法中的参数stops相当于LinearGradient中的positions。 12345Shader shader = new RadialGradient(300, 300, 200, Color.parseColor("#E91E63"), Color.parseColor("#2196F3"), Shader.TileMode.CLAMP);mPaint.setShader(shader);canvas.drawCircle(300, 300, 200, mPaint); SweepGradient绕指定中心点，扫描渐变。 构造方法： SweepGradient(float cx, float cy, @NonNull @ColorInt int colors[], @Nullable float positions[]) SweepGradient(float cx, float cy, @ColorInt int color0, @ColorInt int color1) 其中第一个构造方法中的参数colors[],positions[]与LinearGradient中的同名参数作用一致。 cx, cy为扫描中心点。 12345shader = new SweepGradient(300, 300, Color.parseColor("#E91E63"), Color.parseColor("#2196F3"));mPaint.setShader(shader);canvas.drawCircle(300, 300, 200, mPaint); BitmapShader用 Bitmap 来着色。其实也就是用 Bitmap 的像素来作为图形或文字的填充。 1234567int radius = mBitmap.getWidth() / 2;canvas.drawBitmap(mBitmap, 0, radius * 2 + 10, null);//绘制原图shader = new BitmapShader(mBitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);mPaint.setShader(shader);canvas.drawCircle(radius, radius, radius, mPaint);//绘制圆图 ComposeShader使用两种shader混合绘制。 构造方法： ComposeShader(@NonNull Shader shaderA, @NonNull Shader shaderB, @NonNull Xfermode mode) ComposeShader(@NonNull Shader shaderA, @NonNull Shader shaderB, @NonNull PorterDuff.Mode mode) 这两个构造方法前两个参数一致，代表连个Shader。 第三个参数代表混合的模式，这个在下一节中详细展开介绍。 setColorFilter(ColorFilter colorFilter)设置颜色过滤。 参数ColorFilter不能直接使用，但它有3个直接子类：ColorMatrixColorFilter, LightingColorFilter, PorterDuffColorFilter。 ColorMatrixColorFilter通过一个4x5的颜色矩阵，过滤颜色。 可以用于设置饱和度、YUV转换成RGB等等，具体功能同ColorMatrix类。 ColorMatrix内有一个长度为20的浮点数组，即4x5的颜色矩阵。 1234[ a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t ] 对于颜色 [R, G, B, A] ，转换算法是这样的： 1234R’ = a*R + b*G + c*B + d*A + e; G’ = f*R + g*G + h*B + i*A + j; B’ = k*R + l*G + m*B + n*A + o; A’ = p*R + q*G + r*B + s*A + t; [R’, G’, B’, A’]则为新的颜色。 比如通过ColorMatrix设置灰白图片： 12345ColorMatrix colorMatrix = new ColorMatrix();colorMatrix.setSaturation(0);//设置饱和度，0：灰白，1：原图，&gt;1：过饱和ColorFilter colorFilter = new ColorMatrixColorFilter(colorMatrix);mPaint.setColorFilter(colorFilter);canvas.drawBitmap(mBitmap, 50, 50, mPaint); 其他的设置可以查看开源项目StyleImageView。 LightingColorFilter模拟简单的光照效果。 LightingColorFilter 的构造方法是 LightingColorFilter(int mul, int add) ，参数里的 mul 和 add 都是和颜色值格式相同的 int 值，其中 mul 用来和目标像素相乘，add 用来和目标像素相加，最终的[R’,G’,B’]值范围均限定在[0,255]内。 123R&apos; = R * mul.R / 0xff + add.R G&apos; = G * mul.G / 0xff + add.G B&apos; = B * mul.B / 0xff + add.B PorterDuffColorFilter构造方法为PorterDuffColorFilter(@ColorInt int color, @NonNull PorterDuff.Mode mode)。 PorterDuffColorFilter通过mode模式将color作用到原像素上。 setXfermode(Xfermode xfermode)其中“X”表示“Trans”，所以“Xfermode”即“Transfermode”，转换方式。 用于设置处理将源像素（source pixels）合并到目标像素（destination pixels）的不同算法。 参数xfermode为null时，用于清除之前设置的xfermode。 目标像素：画布上已有内容 源像素：将要绘制的内容 目前，Xfermode的子类只有PorterDuffXfermode。AvoidXfermode、PixelXorXfermode已经废弃。 PorterDuffXfermode的构造方法为PorterDuffXfermode(PorterDuff.Mode mode)，通过参数设置mode。 PorterDuff.Mode有如下几种：CLEAR、SRC、DST、SRC_OVER、DST_OVER、SRC_IN、DST_IN、SRC_OUT、DST_OUT、SRC_ATOP、DST_ATOP、XOR、DARKEN、LIGHTEN、MULTIPLY、SCREEN。 下图中：Sa,Sc,Da,Dc中的S、D、a、c分别表示source、destination、alpha、color，所以 Sa全称为Source alpha表示源图的Alpha通道； Sc全称为Source color表示源图的颜色； Da全称为Destination alpha表示目标图的Alpha通道； Dc全称为Destination color表示目标图的颜色. 上图中“[,]”，表示的是混合后图片的计算方式，其中“,”前面的为alpha通道，“,”后面的是颜色。 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143public class Xfermodes extends Activity &#123; // create a bitmap with a circle, used for the "dst" image // 圆，dst static Bitmap makeDst(int w, int h) &#123; Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); Canvas c = new Canvas(bm); Paint p = new Paint(Paint.ANTI_ALIAS_FLAG); p.setColor(0xFFFFCC44); c.drawOval(new RectF(0, 0, w * 3 / 4, h * 3 / 4), p); return bm; &#125; // create a bitmap with a rect, used for the "src" image // 方形，src static Bitmap makeSrc(int w, int h) &#123; Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); Canvas c = new Canvas(bm); Paint p = new Paint(Paint.ANTI_ALIAS_FLAG); p.setColor(0xFF66AAFF); c.drawRect(w / 3, h / 3, w * 19 / 20, h * 19 / 20, p); return bm; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(new SampleView(this)); &#125; private static class SampleView extends View &#123; private static final int W = 160; private static final int H = 160; private static final int ROW_MAX = 4; // number of samples per row private Bitmap mSrcB; private Bitmap mDstB; private Shader mBG; // background checker-board pattern private static final Xfermode[] sModes = &#123; new PorterDuffXfermode(PorterDuff.Mode.CLEAR), new PorterDuffXfermode(PorterDuff.Mode.SRC), new PorterDuffXfermode(PorterDuff.Mode.DST), new PorterDuffXfermode(PorterDuff.Mode.SRC_OVER), new PorterDuffXfermode(PorterDuff.Mode.DST_OVER), new PorterDuffXfermode(PorterDuff.Mode.SRC_IN), new PorterDuffXfermode(PorterDuff.Mode.DST_IN), new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT), new PorterDuffXfermode(PorterDuff.Mode.DST_OUT), new PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP), new PorterDuffXfermode(PorterDuff.Mode.DST_ATOP), new PorterDuffXfermode(PorterDuff.Mode.XOR), new PorterDuffXfermode(PorterDuff.Mode.DARKEN), new PorterDuffXfermode(PorterDuff.Mode.LIGHTEN), new PorterDuffXfermode(PorterDuff.Mode.MULTIPLY), new PorterDuffXfermode(PorterDuff.Mode.SCREEN) &#125;; private static final String[] sLabels = &#123; "Clear", "Src", "Dst", "SrcOver", "DstOver", "SrcIn", "DstIn", "SrcOut", "DstOut", "SrcATop", "DstATop", "Xor", "Darken", "Lighten", "Multiply", "Screen" &#125;; public SampleView(Context context) &#123; super(context); mSrcB = makeSrc(W, H); mDstB = makeDst(W, H); // make a checkerboard pattern Bitmap bm = Bitmap.createBitmap(new int[]&#123;0xFFFFFFFF, 0xFFCCCCCC, 0xFFCCCCCC, 0xFFFFFFFF&#125;, 2, 2, Bitmap.Config.RGB_565); mBG = new BitmapShader(bm, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT); Matrix m = new Matrix(); m.setScale(6, 6); mBG.setLocalMatrix(m); //在sdkversion&gt;=11时，需要关闭硬件加速，否则 Mode.CLEAR 、 Mode.DARKEN 、 Mode.LIGHTEN 三种模式下绘制效果不正常。 if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB)&#123; //View从API Level 11才加入setLayerType方法 //关闭硬件加速 setLayerType(View.LAYER_TYPE_SOFTWARE, null); &#125; &#125; @Override protected void onDraw(Canvas canvas) &#123; canvas.drawColor(Color.WHITE); Paint labelP = new Paint(Paint.ANTI_ALIAS_FLAG); labelP.setTextAlign(Paint.Align.CENTER); labelP.setTextSize(16); Paint paint = new Paint(); paint.setFilterBitmap(false); canvas.translate(15, 35); int x = 0; int y = 0; for (int i = 0; i &lt; sModes.length; i++) &#123; // draw the border paint.setStyle(Paint.Style.STROKE); paint.setShader(null); canvas.drawRect(x - 0.5f, y - 0.5f, x + W + 0.5f, y + H + 0.5f, paint); // draw the checker-board pattern paint.setStyle(Paint.Style.FILL); paint.setShader(mBG); canvas.drawRect(x, y, x + W, y + H, paint); // draw the src/dst example into our offscreen bitmap int sc = canvas.saveLayer(x, y, x + W, y + H, null, Canvas.ALL_SAVE_FLAG); canvas.translate(x, y); canvas.drawBitmap(mDstB, 0, 0, paint); paint.setXfermode(sModes[i]); canvas.drawBitmap(mSrcB, 0, 0, paint); paint.setXfermode(null); canvas.restoreToCount(sc); // draw the label canvas.drawText(sLabels[i], x + W / 2, y - labelP.getTextSize() / 2, labelP); x += W + 10; // wrap around when we've drawn enough for one row if ((i % ROW_MAX) == ROW_MAX - 1) &#123; x = 0; y += H + 90; &#125; &#125; &#125; &#125;&#125; 上图为上面示例代码的运行效果，与官方文档中的效果一致。 上图中灰白相间的背景是为了方便用户查看而刻意通过BitmapShader绘制上去的。 不过请注意看其中makeDst(int w, int h)和makeSrc(int w, int h)两个方法，方法内先以w、h创建bitmap，但是bitmap的内容只有其中一部分c.drawOval(new RectF(0, 0, w * 3 / 4, h * 3 / 4), p);、c.drawRect(w / 3, h / 3, w * 19 / 20, h * 19 / 20, p);，所以上图中的src和dst两个图就是mSrcB和mDstB连个bitmap的显示效果，其中灰白相间的背景所覆盖的范围就是mSrcB和mDstB的大小。 注：调用Canvas.saveLayer()方法，用做短时的离屏缓冲（offscreen）。相当于photoshop中的涂层。绘制完成后调用Canvas.restoreToCount()。 调整上述代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146public class MyXfermodes extends AppCompatActivity&#123; // create a bitmap with a circle, used for the "dst" image static Bitmap makeDst(int w, int h) &#123; Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); Canvas c = new Canvas(bm); Paint p = new Paint(Paint.ANTI_ALIAS_FLAG); p.setColor(0xFFFFCC44);// c.drawOval(new RectF(0, 0, w * 3 / 4, h * 3 / 4), p); //绘制圆内容占据全部 c.drawOval(new RectF(0, 0, w, h), p); return bm; &#125; // create a bitmap with a rect, used for the "src" image static Bitmap makeSrc(int w, int h) &#123; Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); Canvas c = new Canvas(bm); Paint p = new Paint(Paint.ANTI_ALIAS_FLAG); p.setColor(0xFF66AAFF);// c.drawRect(w / 3, h / 3, w * 19 / 20, h * 19 / 20, p); //绘制方形内容占据全部 c.drawRect(0, 0, w, h, p); return bm; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(new MyXfermodes.SampleView(this)); &#125; private static class SampleView extends View &#123; private static final int W = 160; private static final int H = 160; private static final int ROW_MAX = 4; // number of samples per row private Bitmap mSrcB; private Bitmap mDstB; private Shader mBG; // background checker-board pattern private static final Xfermode[] sModes = &#123; new PorterDuffXfermode(PorterDuff.Mode.CLEAR), new PorterDuffXfermode(PorterDuff.Mode.SRC), new PorterDuffXfermode(PorterDuff.Mode.DST), new PorterDuffXfermode(PorterDuff.Mode.SRC_OVER), new PorterDuffXfermode(PorterDuff.Mode.DST_OVER), new PorterDuffXfermode(PorterDuff.Mode.SRC_IN), new PorterDuffXfermode(PorterDuff.Mode.DST_IN), new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT), new PorterDuffXfermode(PorterDuff.Mode.DST_OUT), new PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP), new PorterDuffXfermode(PorterDuff.Mode.DST_ATOP), new PorterDuffXfermode(PorterDuff.Mode.XOR), new PorterDuffXfermode(PorterDuff.Mode.DARKEN), new PorterDuffXfermode(PorterDuff.Mode.LIGHTEN), new PorterDuffXfermode(PorterDuff.Mode.MULTIPLY), new PorterDuffXfermode(PorterDuff.Mode.SCREEN) &#125;; private static final String[] sLabels = &#123; "Clear", "Src", "Dst", "SrcOver", "DstOver", "SrcIn", "DstIn", "SrcOut", "DstOut", "SrcATop", "DstATop", "Xor", "Darken", "Lighten", "Multiply", "Screen" &#125;; public SampleView(Context context) &#123; super(context); //调整dst、src大小 mSrcB = makeSrc(W * 37 / 60,H * 37 / 60); mDstB = makeDst(W * 3 / 4, H * 3 / 4); // make a checkerboard pattern Bitmap bm = Bitmap.createBitmap(new int[]&#123;0xFFFFFFFF, 0xFFCCCCCC, 0xFFCCCCCC, 0xFFFFFFFF&#125;, 2, 2, Bitmap.Config.RGB_565); mBG = new BitmapShader(bm, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT); Matrix m = new Matrix(); m.setScale(6, 6); mBG.setLocalMatrix(m); //在sdkversion&gt;=11时，需要关闭硬件加速，否则 Mode.CLEAR 、 Mode.DARKEN 、 Mode.LIGHTEN 三种模式下绘制效果不正常。 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123; //View从API Level 11才加入setLayerType方法 //关闭硬件加速 setLayerType(View.LAYER_TYPE_SOFTWARE, null); &#125; &#125; @Override protected void onDraw(Canvas canvas) &#123; canvas.drawColor(Color.WHITE); Paint labelP = new Paint(Paint.ANTI_ALIAS_FLAG); labelP.setTextAlign(Paint.Align.CENTER); labelP.setTextSize(16); Paint paint = new Paint(); paint.setFilterBitmap(false); canvas.translate(15, 35); int x = 0; int y = 0; for (int i = 0; i &lt; sModes.length; i++) &#123; // draw the border paint.setStyle(Paint.Style.STROKE); paint.setShader(null); canvas.drawRect(x - 0.5f, y - 0.5f, x + W + 0.5f, y + H + 0.5f, paint); // draw the checker-board pattern paint.setStyle(Paint.Style.FILL); paint.setShader(mBG); canvas.drawRect(x, y, x + W, y + H, paint); // draw the src/dst example into our offscreen bitmap int sc = canvas.saveLayer(x, y, x + W, y + H, null, Canvas.ALL_SAVE_FLAG); canvas.translate(x, y); canvas.drawBitmap(mDstB, 0, 0, paint); paint.setXfermode(sModes[i]); //调整src方形的绘制位置 canvas.drawBitmap(mSrcB, W / 3, H / 3, paint); paint.setXfermode(null); canvas.restoreToCount(sc); // draw the label canvas.drawText(sLabels[i], x + W / 2, y - labelP.getTextSize() / 2, labelP); x += W + 10; // wrap around when we've drawn enough for one row if ((i % ROW_MAX) == ROW_MAX - 1) &#123; x = 0; y += H + 90; &#125; &#125; &#125; &#125;&#125; 代码中改动如下： makeDst(int w, int h)和makeSrc(int w, int h)两个方法中的内容占满w，h 调用makeDst()和makeSrc()两个方法时，参数大小调整 绘制mSrcB时调整位置 可以看到上图与没改动前只有一个差别，就是dst圆形未与src方形相交的部分一直显示。也就是说未相交部分不参与计算，所以不会变化。]]></content>
      <categories>
        <category>android</category>
        <category>view</category>
        <category>自定义</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>view</tag>
        <tag>Paint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View之Scroller]]></title>
    <url>%2F3461679658%2F</url>
    <content type="text"><![CDATA[前言本篇文章主要介绍Scroller的用法，并配合上一篇文章《自定义View之scroll系列方法》中介绍的View.scrollTo()和scrollBy()两个方法以及View.computeScroll()方法，实现平滑滑动效果。 并通过Scroller及view事件分发机制源码，为大家具体讲解其中的奥妙。 Scroller典型使用方式Scroller 的典型代码是固定的，主要有如下3步： 创建Scroller的实例 调用startScroll()或fling()方法来初始化滚动数据并刷新界面 重写computeScroll()方法，并在其内部完成平滑滚动的逻辑 代码实现如下： 123456789101112131415161718192021//第一步，创建Scroller的实例，一般在控件初始化的时候进行Scroller mScroller = new Scroller(mContext);//平滑移动到指定位置private void smoothScrollTo(int destX, int destY) &#123; int curScrollX = getScrollX(); int delta = destX - curScrollX; // 第二步，调用startScroll()方法来初始化滚动数据并刷新界面 // 1000ms内滑向destX，效果就是满满滑动 mScroller.startScroll(curScrollX, 0, delta, 0, 1000); invalidate();//刷新UI&#125;@Overridepublic void computeScroll() &#123; // 第三步，重写computeScroll()方法，并在其内部完成平滑滚动的逻辑 if (mScroller.computeScrollOffset()) &#123; scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); invalidate(); &#125;&#125; 源码解析Scroller通过上面的示例，可以归纳出scroller工作的整体流程： 既然有了这么明确的流程图，那我们下面就来依据这个流程简单分析下Scroller的源码。可以发现Scroller这类的代码不多，确实是一个工具类，它只是保存了我们传递的几个参数，我们先看下构造方法： 1234567891011121314151617181920212223242526272829303132333435/** * Create a Scroller with the default duration and interpolator. */ public Scroller(Context context) &#123; this(context, null); &#125; /** * Create a Scroller with the specified interpolator. If the interpolator is * null, the default (viscous) interpolator will be used. "Flywheel" behavior will * be in effect for apps targeting Honeycomb or newer. */ public Scroller(Context context, Interpolator interpolator) &#123; this(context, interpolator, context.getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.HONEYCOMB); &#125; /** * Create a Scroller with the specified interpolator. If the interpolator is * null, the default (viscous) interpolator will be used. Specify whether or * not to support progressive "flywheel" behavior in flinging. */ public Scroller(Context context, Interpolator interpolator, boolean flywheel) &#123; mFinished = true; if (interpolator == null) &#123; mInterpolator = new ViscousFluidInterpolator(); &#125; else &#123; mInterpolator = interpolator; &#125; mPpi = context.getResources().getDisplayMetrics().density * 160.0f; mDeceleration = computeDeceleration(ViewConfiguration.getScrollFriction()); mFlywheel = flywheel; mPhysicalCoeff = computeDeceleration(0.84f); // look and feel tuning &#125; scroller总共有3个构造方法，其实前两个都调用了第三个构造方法。 主要是初始化了一些参数，其中interpolator为插值器，用于处理滑动过程中各时间段的快慢过程。 其中computeDeceleration()方法通过传入的摩擦系数，计算减速度（用于fling()方法中计算当前速度）。 123456private float computeDeceleration(float friction) &#123; return SensorManager.GRAVITY_EARTH // g (m/s^2) * 39.37f // inch/meter * mPpi // pixels per inch * friction;&#125; 下面我们看看与Scroller相关的startScroll()和fling()方法，源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private static final int DEFAULT_DURATION = 250;private static final int SCROLL_MODE = 0;private static final int FLING_MODE = 1;//使用默认滑动时间进行滑动public void startScroll(int startX, int startY, int dx, int dy) &#123; startScroll(startX, startY, dx, dy, DEFAULT_DURATION);&#125;/** * 使用传入的参数duration滑动过程时间来完成滑动 * * @param startX 滑动起点水平坐标，正数表示内容往左移 * @param startY 滑动起点垂直坐标，正数表示内容往上移 * @param dx 水平方向移动距离 * @param dy 垂直方向移动距离 * @param duration 移动过程持续时间 */public void startScroll(int startX, int startY, int dx, int dy, int duration) &#123; mMode = SCROLL_MODE; mFinished = false; mDuration = duration; mStartTime = AnimationUtils.currentAnimationTimeMillis(); mStartX = startX; mStartY = startY; mFinalX = startX + dx; mFinalY = startY + dy; mDeltaX = dx; mDeltaY = dy; mDurationReciprocal = 1.0f / (float) mDuration;&#125;//在快速滑动时松开的基础上开始惯性滚动，滚动距离取决于fling的初速度public void fling(int startX, int startY, int velocityX, int velocityY, int minX, int maxX, int minY, int maxY) &#123; ...... mMode = FLING_MODE; mFinished = false; ...... mStartX = startX; mStartY = startY; ...... mDistance = (int) (totalDistance * Math.signum(velocity)); mMinX = minX; mMaxX = maxX; mMinY = minY; mMaxY = maxY; ...... mFinalY = Math.min(mFinalY, mMaxY); mFinalY = Math.max(mFinalY, mMinY);&#125; 注：这里的滑动指的是View内容的滑动而非View本身位置的改变 可以看到，scroller中的方法只是初始化了一些数据，没有做滑动相关的事。所以说这些只是工具方法而已，实质的滑动其实是需要我们在startScroll或fling后面手动调运View.invalidate()或View.postInvalidate()进行重绘，然后在View的draw方法中又会去调运自己的computeScroll()方法，computeScroll()方法View中是一个空实现，需要我们自己去实现，上面的代码已经实现了computeScroll()方法，我们在该方法中进行Scroller.computeScrollOffset()判断并触发View的滑动方法和重绘。 我们再看一下Scroller的computeScrollOffset方法的实现，如下所示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//判断滚动是否还在继续，true继续，false结束public boolean computeScrollOffset() &#123; //mFinished为true表示已经完成了滑动，直接返回为false if (mFinished) &#123; return false; &#125; //mStartTime为开始时的时间戳，timePassed就是当前滑动持续时间 int timePassed = (int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime); //mDuration为我们设置的持续时间，当当前已滑动耗时timePassed小于总设置持续时间时才进入if if (timePassed &lt; mDuration) &#123; //mMode有两中，如果调运startScroll()则为SCROLL_MODE模式，调运fling()则为FLING_MODE模式 switch (mMode) &#123; case SCROLL_MODE: //根据Interpolator插值器计算在该时间段里移动的距离赋值给mCurrX和mCurrY final float x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal); mCurrX = mStartX + Math.round(x * mDeltaX); mCurrY = mStartY + Math.round(x * mDeltaY); break; case FLING_MODE: //各种数学运算获取mCurrY、mCurrX，实质类似上面SCROLL_MODE，只是这里时惯性的 ...... // Pin to mMinX &lt;= mCurrX &lt;= mMaxX mCurrX = Math.min(mCurrX, mMaxX); mCurrX = Math.max(mCurrX, mMinX); mCurrY = mStartY + Math.round(distanceCoef * (mFinalY - mStartY)); // Pin to mMinY &lt;= mCurrY &lt;= mMaxY mCurrY = Math.min(mCurrY, mMaxY); mCurrY = Math.max(mCurrY, mMinY); if (mCurrX == mFinalX &amp;&amp; mCurrY == mFinalY) &#123; mFinished = true; &#125; break; &#125; &#125; else &#123; //认为滑动结束，mFinished置位true，标记结束，下一次再触发该方法时一进来就判断返回false了 mCurrX = mFinalX; mCurrY = mFinalY; mFinished = true; &#125; return true;&#125; 可以看见该方法的作用其实就是实时计算滚动的偏移量（也是一个工具方法），同时判断滚动是否结束（true代表没结束，false代表结束）。 仿ViewPager示例既然已经将Scroller的主要方法讲解完毕了，那就小试牛刀。 代码ScrollerLayout.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132/** * Created by nht on 2018/8/21. * Scroller使用示例，仿ViewPager水平滑动 */public class ScrollerLayout extends ViewGroup &#123; /** * 用于完成滚动操作的实例 */ private Scroller mScroller; /** * 判定为拖动的最小移动像素数 */ private int mTouchSlop; /** * 手机按下时的屏幕坐标 */ private float mXDown; /** * 手机当时所处的屏幕坐标 */ private float mXMove; /** * 上次触发ACTION_MOVE事件时的屏幕坐标 */ private float mXLastMove; /** * 界面可滚动的左边界 */ private int leftBorder; /** * 界面可滚动的右边界 */ private int rightBorder; public ScrollerLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); // 第一步，创建Scroller的实例 mScroller = new Scroller(context); mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop(); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int childCount = getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; View childView = getChildAt(i); // 为ScrollerLayout中的每一个子控件测量大小 measureChild(childView, widthMeasureSpec, heightMeasureSpec); &#125; &#125; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; if (changed) &#123; int childCount = getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; View childView = getChildAt(i); // 为ScrollerLayout中的每一个子控件在水平方向上进行布局 childView.layout(i * childView.getMeasuredWidth(), 0, (i + 1) * childView.getMeasuredWidth(), childView.getMeasuredHeight()); &#125; // 初始化左右边界值 leftBorder = getChildAt(0).getLeft(); rightBorder = getChildAt(getChildCount() - 1).getRight(); &#125; &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: mXDown = ev.getRawX(); mXLastMove = mXDown; break; case MotionEvent.ACTION_MOVE: mXMove = ev.getRawX(); float diff = Math.abs(mXMove - mXDown); mXLastMove = mXMove; // 当手指拖动值大于TouchSlop值时，认为应该进行滚动，拦截子控件的事件 if (diff &gt; mTouchSlop) &#123; return true; &#125; break; &#125; return super.onInterceptTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_MOVE: mXMove = event.getRawX(); int scrolledX = (int) (mXLastMove - mXMove); if (getScrollX() + scrolledX &lt; leftBorder) &#123; scrollTo(leftBorder, 0); return true; &#125; else if (getScrollX() + getWidth() + scrolledX &gt; rightBorder) &#123; scrollTo(rightBorder - getWidth(), 0); return true; &#125; scrollBy(scrolledX, 0); mXLastMove = mXMove; break; case MotionEvent.ACTION_UP: // 当手指抬起时，根据当前的滚动值来判定应该滚动到哪个子控件的界面 int targetIndex = (getScrollX() + getWidth() / 2) / getWidth(); int dx = targetIndex * getWidth() - getScrollX(); // 第二步，调用startScroll()方法来初始化滚动数据并刷新界面 mScroller.startScroll(getScrollX(), 0, dx, 0); invalidate(); break; &#125; return super.onTouchEvent(event); &#125; @Override public void computeScroll() &#123; // 第三步，重写computeScroll()方法，并在其内部完成平滑滚动的逻辑 if (mScroller.computeScrollOffset()) &#123; scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); invalidate(); &#125; &#125;&#125; 12345678public class ScrollerActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_scroller); &#125;&#125; 布局文件activity_scroller.xml 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;com.nhtzj.myapplication.scroller.ScrollerLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;Button android:layout_width="match_parent" android:layout_height="100dp" android:text="This is first child view" /&gt; &lt;Button android:layout_width="match_parent" android:layout_height="100dp" android:text="This is second child view" /&gt; &lt;Button android:layout_width="match_parent" android:layout_height="100dp" android:text="This is third child view" /&gt;&lt;/com.nhtzj.myapplication.scroller.ScrollerLayout&gt; 重绘流程在介绍Scroller源码过程中说到了“手动调运View.invalidate()或View.postInvalidate()进行重绘，然后在View的draw方法中又会去调运自己的computeScroll()方法”。 现在就从源码的角度说明一下调用View.invalidate()后到computeScroll()的流程。 View的刷新会调用View.draw()方法，其实在调用该方法前还有几个步骤，这里就不提了，想要了解的可以查看这篇文章《Android应用层View绘制流程与源码分析》，小编关于View绘制流程的学习也是从这里看起的。 1234567891011121314151617181920212223public void draw(Canvas canvas) &#123; final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ …… // Step 4, draw the children dispatchDraw(canvas); …… &#125; View 绘制流程 1.绘制背景 2.2和5，如果有需要，绘制渐隐(fading) 效果 3.绘制内容 4.绘制 children 6.绘制装饰物 （scrollbars） 这里看第四步dispatchDraw()，ViewGroup用于绘制子view，在View中是个空方法。 123protected void dispatchDraw(Canvas canvas) &#123;&#125; 查看ViewGroup.dispatchDraw()方法。 123456789protected void dispatchDraw(Canvas canvas) &#123; ...... for (int i = 0; i &lt; childrenCount; i++) &#123; ...... more |= drawChild(canvas, child, drawingTime); ...... &#125; ......&#125; 123protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123; return child.draw(canvas, this, drawingTime);&#125; 可以看到ViewGroup.dispatchDraw()内调用了ViewGroup.drawChild()。 这里引出了View.draw(Canvas canvas, ViewGroup parent, long drawingTime)方法，这个方法不同于 View.draw(Canvas canvas)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * This method is called by ViewGroup.drawChild() to have each child view draw itself. * * This is where the View specializes rendering behavior based on layer type, * and hardware acceleration. */boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) &#123; final boolean hardwareAcceleratedCanvas = canvas.isHardwareAccelerated(); /* If an attached view draws to a HW canvas, it may use its RenderNode + DisplayList. * * If a view is dettached, its DisplayList shouldn't exist. If the canvas isn't * HW accelerated, it can't handle drawing RenderNodes. */ boolean drawingWithRenderNode = mAttachInfo != null &amp;&amp; mAttachInfo.mHardwareAccelerated &amp;&amp; hardwareAcceleratedCanvas; …… int sx = 0; int sy = 0; if (!drawingWithRenderNode) &#123; computeScroll(); sx = mScrollX; sy = mScrollY; &#125; final boolean drawingWithDrawingCache = cache != null &amp;&amp; !drawingWithRenderNode; final boolean offsetForScroll = cache == null &amp;&amp; !drawingWithRenderNode; int restoreTo = -1; if (!drawingWithRenderNode || transformToApply != null) &#123; restoreTo = canvas.save(); &#125; if (offsetForScroll) &#123; canvas.translate(mLeft - sx, mTop - sy); &#125; …… // Fast path for layouts with no backgrounds if ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123; mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK; dispatchDraw(canvas); &#125; else &#123; draw(canvas); &#125; …… &#125; 其中drawingWithRenderNode用于判断是否开启硬件加速。 1234567int sx = 0;int sy = 0;if (!drawingWithRenderNode) &#123; computeScroll(); sx = mScrollX; sy = mScrollY;&#125; 代码运行中，先会调用 computeScroll()方法，然后将 mScrollX 和 mScrollY 赋值给变量 sx 和 sy 变量。 终于找到了第一节中重写的computeScroll()方法。 1canvas.translate(mLeft - sx, mTop - sy); 这里解释了View.scrollTo()、View.scrollBy()方法为什么当参数为正数时，内容是向左移动。 回过头去看《自定义View之scroll系列方法》中关于参数正负性和内容移动方向的对应关系，是否就更加清晰了呢。 1234567if ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123; mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK; dispatchDraw(canvas);&#125; else &#123; // 在这里调用 draw() 单参数方法。 draw(canvas);&#125; 之后在这里进行绘制子view。 参考不再迷惑，也许之前你从未真正懂得 Scroller 及滑动机制 Android应用开发Scroller详解及源码浅析 Android Scroller完全解析，关于Scroller你所需知道的一切]]></content>
      <categories>
        <category>android</category>
        <category>view</category>
        <category>自定义</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>view</tag>
        <tag>Scroller</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View之Path]]></title>
    <url>%2F2623377752%2F</url>
    <content type="text"><![CDATA[前言本篇承上文 自定义View之Canvas.drawXXX()中drawPath(@NonNull Path path, @NonNull Paint paint)方法而来，详细讲解其中的参数Path的作用。 简介先上一下官方的注释 123456789101112package android.graphics;/** * The Path class encapsulates compound (multiple contour) geometric paths * consisting of straight line segments, quadratic curves, and cubic curves. * It can be drawn with canvas.drawPath(path, paint), either filled or stroked * (based on the paint's Style), or it can be used for clipping or to draw * text on a path. */public class Path &#123; ……&#125; 可以看到Path类位于android.graphics包中。 注释的英文翻译过来大致如下： Path类封装了由直线段、二次曲线和三次曲线组成的复合（多个轮廓）几何路径。 它可以用Canvas.drawPath(path,paint)绘制，无论是填充还是描边（取决于paint画笔的样式）； 或者它可以用于剪裁或绘画路径上的文字。 用于裁截的方法有Canvas.clipPath(@NonNull Path path)，另外还有几个重载方法。 用于绘画路径上的文字的方法我所知道的目前只有一个，drawTextOnPath(@NonNull char[] text, int index, int count, @NonNull Path path, float hOffset, float vOffset, @NonNull Paint paint)，这个方法在上文自定义View之Canvas.drawXXX()中的drawText()一节中有简要说明。 Path 可以描述直线、二次曲线、三次曲线、圆、椭圆、弧形、矩形、圆角矩形。把这些图形结合起来，就可以描述出很多复杂的图形 这里主要围绕Canvas.drawPath(path,paint)展开说明。 Path类的具体使用Path 主要有两类方法，一类是直接描述路径的，另一类是辅助的设置或计算。 Path 方法第一类：直接描述路径Path.addXxx()系列Path.addXX()系列是直接调用Path提供的方法添加子图形到Path中。 addCircle(float x, float y, float radius, Direction dir)添加封闭的圆。 x, y, radius 这三个参数是圆的基本信息，最后一个参数 dir 是画圆的路径的方向。 路径方向有两种：顺时针 (CW clockwise) 和逆时针 (CCW counter-clockwise) 。对于描边(Paint.Style 为 STROKE )情况，这个参数填 CW 还是填 CCW 没有影响。它只是在需要填充图形 (Paint.Style 为 FILL 或 FILL_AND_STROKE) ，并且图形出现自相交时，用于判断填充范围的。比如下面这个图形： 填充类型 OR 关于采取那个方式来操作，取决于Path.setFillType()，关于这方法，会在辅助的设置或计算中具体展开。 addRect(float left, float top, float right, float bottom, Direction dir)添加封闭的矩形。 left，top，right，bottom 四个参数确定矩形的四边。 重载方法： addRect(RectF rect, Direction dir) 用RectF封装了float类型的四个变量： left，top，right，bottom addRoundRect(RectF rect, float rx, float ry, Direction dir)添加封闭的圆角矩形。 rx、ry分别与rect的四边形成四个矩形绘制椭圆，此椭圆的一角形成圆角矩形的圆角。 rx、ry的具体效果，可查看上篇 自定义View之Canvas.drawXXX()的drawRoundRect章节。 重载方法： addRoundRect(float left, float top, float right, float bottom, float rx, float ry, Direction dir) 添加于api21 addRoundRect(RectF rect, float[] radii, Direction dir) addRoundRect(float left, float top, float right, float bottom, float[] radii, Direction dir) 添加于api21 后两个重载方法中多了float[] radii这个参数。radii数组有8个值，组成4对(x,y)，分别表示左上、右上，右下，左下，分别控制对应的圆角。 addArc(RectF oval, float startAngle, float sweepAngle)添加弧形，该弧形是椭圆的一部分。oval确定椭圆的四边界。可以看作是在oval决定的矩形中绘制了一个椭圆。startAngle 为绘制椭圆弧形的起始角度（x 轴的正向，即正右的方向，是 0 度的位置；顺时针为正角度，逆时针为负角度）；sweepAngle 是弧形划过的角度； 重载方法： addArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle) 添加于api21 1234567891011121314151617181920212223242526 paint = new Paint(Paint.ANTI_ALIAS_FLAG); paint.setColor(Color.RED); paint.setStyle(Paint.Style.STROKE); mPath = new Path(); mDashPathEffect = new DashPathEffect(new float[]&#123;4, 4&#125;, 0); //设置虚线@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); //绘制下半红色椭圆 mPath.addArc(100, 100, 600, 400, 0, 180); canvas.drawPath(mPath, paint); //绘制上半蓝色椭圆 mPath.reset(); paint.setColor(Color.BLUE); mPath.addArc(100, 100, 600, 400, 0, -180); canvas.drawPath(mPath, paint); //绘制灰色虚线矩形 mPath.reset(); mPath.addRect(100, 100, 600, 400, Path.Direction.CCW); paint.setColor(Color.GRAY); paint.setPathEffect(mDashPathEffect); //设置虚线 canvas.drawPath(mPath, paint);&#125; addOval(RectF oval, Direction dir)添加椭圆。 重载方法： addOval(float left, float top, float right, float bottom, Direction dir) 添加于api21 addPath(Path src)将一个path数据添加到当前的path中。 重载方法： addPath(Path src, float dx, float dy) addPath(Path src, Matrix matrix) addPath(Path src, float dx, float dy) 将坐标系平移到(dx,dy)后添加src内容。也可以说是给src内的每个坐标点都添加(dx,dy)大小。addPath(Path src, Matrix matrix)与addPath(Path src, float dx, float dy)类似，不过matrix能做的事比dx,dy多得多了，addPath(Path src, float dx, float dy)中的dx,dy相当于matrix.postTranslate(dx,dy)。通过matrix几何变换后再添加src。 Path.XxxTo系列添加线条。 这一组和第一组 addXxx() 方法的区别在于，第一组是添加的完整封闭图形（除了 addPath() ），而这一组添加的只是一条线。 lineTo(float x, float y)、rLineTo(float dx, float dy)画直线。比如当前画笔停留的坐标为(x0,y0),则lineTo是从(x0,y0)画直线到(x,y)。rLineTo是从(x0,y0)画直线到(x0+dx,y0+dy)。 123paint.setStyle(Style.STROKE);path.lineTo(100, 100); // 由当前位置 (0, 0) 向 (100, 100) 画一条直线path.rLineTo(100, 0); // 由当前位置 (100, 100) 向正右方 100 像素的位置画一条直线 moveTo (float x, float y)、rMoveTo (float dx, float dy)将当前画笔的位置移动到指定位置。此过程不绘制任何内容。好比是写字时，你将笔抬起后移动到下一行这个过程，之后再继续书写。 moveTo 是直接将画笔移动到(x,y)处。rMoveTo 是将画笔在当前位置基础上x轴移动dx，y轴移动dy。 arcTo(RectF oval, float startAngle, float sweepAngle)、arcTo(RectF oval, float startAngle, float sweepAngle, boolean forceMoveTo)、arcTo(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean forceMoveTo)添加弧线。 与addArc类似，arcTo多了参数forceMoveTo，用于控制是否连接上一点与弧线起点。true：不连接，直接开始画弧线；false：连接后再开始画弧线。 由此来看，addArc相当于是forceMoveTo=true的arcTo arcTo(RectF oval, float startAngle, float sweepAngle)内部默认将forceMoveTo设置为false。 123public void arcTo(RectF oval, float startAngle, float sweepAngle) &#123; arcTo(oval.left, oval.top, oval.right, oval.bottom, startAngle, sweepAngle, false);&#125; arcTo(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean forceMoveTo) 添加于api21 123paint.setStyle(Style.STROKE);path.lineTo(100, 100);path.arcTo(100, 100, 300, 300, -90, 90, true); // 强制移动到弧形起点（无痕迹） 123paint.setStyle(Style.STROKE);path.lineTo(100, 100);path.arcTo(100, 100, 300, 300, -90, 90, false); // 直接连线连到弧形起点（有痕迹） 123paint.setStyle(Style.STROKE);path.lineTo(100, 100);path.addArc(100, 100, 300, 300, -90, 90); quadTo(float x1, float y1, float x2, float y2)、rQuadTo(float dx1, float dy1, float dx2, float dy2)画二次贝塞尔曲线。 起点为画笔的当前位置，(x1,y1)为控制点坐标，(x2,y2)为终点坐标。 假设画笔的当前位置为(x0,y0)，则rQuadTo中的控制点坐标为(x0+dx1,y0+dy1)，终点坐标为(x0+dx2,y0+dy2)。 cubicTo(float x1, float y1, float x2, float y2,float x3, float y3)、rCubicTo(float x1, float y1, float x2, float y2,float x3, float y3)画三次贝塞尔曲线。与二次贝塞尔曲线方法类似，不过三次贝塞尔曲线控制点有两个，其中(x1,y1)，(x2,y2)为控制点，(x3,y3)为终点。 Path 方法第二类：辅助的设置或计算setFillType(FillType ft)先上官方注释 12345678/** * Set the path's fill type. This defines how "inside" is computed. * * @param ft The new fill type for this path */public void setFillType(FillType ft) &#123; nSetFillType(mNativePath, ft.nativeInt);&#125; 设置path的填充类型。处理内容重叠曲的显示方式。 前面在说 dir 参数的时候提到， Path.setFillType(fillType) 是用来设置图形自相交时的填充算法的： 123456789101112131415161718192021222324252627282930/** * Enum for the ways a path may be filled. */public enum FillType &#123; // these must match the values in SkPath.h /** * Specifies that "inside" is computed by a non-zero sum of signed * edge crossings. */ WINDING (0), /** * Specifies that "inside" is computed by an odd number of edge * crossings. */ EVEN_ODD (1), /** * Same as &#123;@link #WINDING&#125;, but draws outside of the path, rather than inside. */ INVERSE_WINDING (2), /** * Same as &#123;@link #EVEN_ODD&#125;, but draws outside of the path, rather than inside. */ INVERSE_EVEN_ODD(3); FillType(int ni) &#123; nativeInt = ni; &#125; final int nativeInt;&#125; 系统提供了4种填充类型： WINDING EVEN_ODD INVERSE_WINDING INVERSE_EVEN_ODD INVERSE_WINDING和INVERSE_EVEN_ODD从字面上就可以知道与WINDING和EVEN_ODD刚好反了一下。 所以只要理了WINDING和EVEN_ODD，剩下的两种自然也就理解了。 EVEN_ODDEVEN：偶数的 ODD：奇数的 即奇偶原则：对于平面中的任意一点，向任意方向射出一条射线，这条射线和图形相交的次数（相交才算，相切不算哦）如果是奇数，则这个点被认为在图形内部，是要被涂色的区域；如果是偶数，则这个点被认为在图形外部，是不被涂色的区域。还以左右相交的双圆为例： 简单来讲：线方向无关，射线交点（奇数画，偶数不画） 射线的方向无所谓，同一个点射向任何方向的射线，结果都是一样的 WINDING即 non-zero winding rule （非零环绕数原则） 首先，它需要你图形中的所有线条都是有绘制方向的： 然后，同样是从平面中的点向任意方向射出一条射线，但计算规则不一样：以 0 为初始值，对于射线和图形的所有交点，遇到每个顺时针的交点（图形从射线的左边向右穿过）把结果加 1，遇到每个逆时针的交点（图形从射线的右边向左穿过）把结果减 1，最终把所有的交点都算上，得到的结果如果不是 0，则认为这个点在图形内部，是要被涂色的区域；如果是 0，则认为这个点在图形外部，是不被涂色的区域。 简单来讲：线方向相关，射线交点（顺时针+1，逆时针-1），非0画，0不画 图形的方向： 对于添加子图形类方法（如 Path.addCircle() Path.addRect()）的方向，由方法的 dir 参数来控制，这个在前面已经讲过了； 而对于画线类的方法（如 Path.lineTo()Path.arcTo()），线的方向就是图形的方向。 12345678paint = new Paint(Paint.ANTI_ALIAS_FLAG);paint.setColor(Color.RED);mPath = new Path();mPath.setFillType(Path.FillType.INVERSE_EVEN_ODD);mPath.addCircle(200,200,100, Path.Direction.CW);mPath.addCircle(350,200,100, Path.Direction.CW);canvas.drawPath(mPath,paint); 12345678paint = new Paint(Paint.ANTI_ALIAS_FLAG);paint.setColor(Color.RED);mPath = new Path();mPath.setFillType(Path.FillType.INVERSE_WINDING);mPath.addCircle(200,200,100, Path.Direction.CW);mPath.addCircle(350,200,100, Path.Direction.CW);canvas.drawPath(mPath,paint); 12345678paint = new Paint(Paint.ANTI_ALIAS_FLAG);paint.setColor(Color.RED);mPath = new Path();mPath.setFillType(Path.FillType.INVERSE_WINDING);mPath.addCircle(200,200,100, Path.Direction.CW);mPath.addCircle(350,200,100, Path.Direction.CCW);canvas.drawPath(mPath,paint); EVEN_ODD 和 WINDING 的效果应该是这样的： Path.Op类似于Paint中的xfermode属性，可以用来组合两个Path。 系统提供了如下几种： 12345678910111213141516171819202122232425262728/** * The logical operations that can be performed when combining two paths. * * @see #op(Path, android.graphics.Path.Op) * @see #op(Path, Path, android.graphics.Path.Op) */public enum Op &#123; /** * Subtract the second path from the first path. */ DIFFERENCE, /** * Intersect the two paths. */ INTERSECT, /** * Union (inclusive-or) the two paths. */ UNION, /** * Exclusive-or the two paths. */ XOR, /** * Subtract the first path from the second path. */ REVERSE_DIFFERENCE&#125; 不添加OP属性示例123456789101112paint = new Paint(Paint.ANTI_ALIAS_FLAG);paint.setColor(Color.RED);paint.setStyle(Paint.Style.STROKE);mPath = new Path();mPathSec = new Path();mPath.addCircle(200, 200, 100, Path.Direction.CW);mPathSec.addRect(200, 200, 300, 300, Path.Direction.CW);canvas.drawPath(mPath, paint);paint.setColor(Color.GRAY);canvas.drawPath(mPathSec, paint); 为了区分圆形和矩形，设置了不同颜色。 DIFFERENCE从当前path中去除另一个path，即显示当前path中不相交的部分。 12345678910paint = new Paint(Paint.ANTI_ALIAS_FLAG);paint.setColor(Color.RED);paint.setStyle(Paint.Style.STROKE);mPath = new Path();mPathSec = new Path();mPath.addCircle(200, 200, 100, Path.Direction.CW);mPathSec.addRect(200, 200, 300, 300, Path.Direction.CW);mPath.op(mPathSec, Path.Op.DIFFERENCE);canvas.drawPath(mPath, paint); INTERSECT取相交的部分显示出来 12345678910paint = new Paint(Paint.ANTI_ALIAS_FLAG);paint.setColor(Color.RED);paint.setStyle(Paint.Style.STROKE);mPath = new Path();mPathSec = new Path();mPath.addCircle(200, 200, 100, Path.Direction.CW);mPathSec.addRect(200, 200, 300, 300, Path.Direction.CW);mPath.op(mPathSec, Path.Op.INTERSECT);canvas.drawPath(mPath, paint); UNIONinclusive-or，两个path组合在一起（STORKE的样式下，重叠部分的线不绘制）。 12345678910paint = new Paint(Paint.ANTI_ALIAS_FLAG);paint.setColor(Color.RED);paint.setStyle(Paint.Style.STROKE);mPath = new Path();mPathSec = new Path();mPath.addCircle(200, 200, 100, Path.Direction.CW);mPathSec.addRect(250, 250, 300, 300, Path.Direction.CW);mPath.op(mPathSec, Path.Op.UNION);canvas.drawPath(mPath, paint); XOR取两个path不相交部分。 当画笔在描边模式下时，与 不添加OP属性示例一致。 12345678910paint = new Paint(Paint.ANTI_ALIAS_FLAG);paint.setColor(Color.RED);paint.setStyle(Paint.Style.STROKE);mPath = new Path();mPathSec = new Path();mPath.addCircle(200, 200, 100, Path.Direction.CW);mPathSec.addRect(250, 250, 300, 300, Path.Direction.CW);mPath.op(mPathSec, Path.Op.XOR);canvas.drawPath(mPath, paint); 12345678910paint = new Paint(Paint.ANTI_ALIAS_FLAG);paint.setColor(Color.RED);paint.setStyle(Paint.Style.FILL);//或者FILL_OR_STROKEmPath = new Path();mPathSec = new Path();mPath.addCircle(200, 200, 100, Path.Direction.CW);mPathSec.addRect(250, 250, 300, 300, Path.Direction.CW);mPath.op(mPathSec, Path.Op.XOR);canvas.drawPath(mPath, paint); REVERSE_DIFFERENCEDIFFERENCE是从当前path中去除另一个path； 而REVERSE_DIFFERENCE是从另一个path中去除当前path部分，即显示另一个path中不相交的部分。 12345678910paint = new Paint(Paint.ANTI_ALIAS_FLAG);paint.setColor(Color.RED);paint.setStyle(Paint.Style.STROKE);mPath = new Path();mPathSec = new Path();mPath.addCircle(200, 200, 100, Path.Direction.CW);mPathSec.addRect(250, 250, 300, 300, Path.Direction.CW);mPath.op(mPathSec, Path.Op.REVERSE_DIFFERENCE);canvas.drawPath(mPath, paint); close()封闭当前子图形，即由当前位置向当前子图形的起点绘制一条直线。 相当于lineTo(起点坐标) 。 当Paint画笔为填充类型时（即 Paint.Style 为 FILL 或 FILL_AND_STROKE），会自动封闭子图形。 1234paint.setStyle(Style.STROKE);path.moveTo(100, 100);path.lineTo(200, 100);path.lineTo(150, 150); 12345paint.setStyle(Style.STROKE);path.moveTo(100, 100);path.lineTo(200, 100);path.lineTo(150, 150);path.close(); // 使用 close() 封闭子图形。等价于 path.lineTo(100, 100) 1234paint.setStyle(Style.FILL);//或者Style.FILL_AND_STROKEpath.moveTo(100, 100);path.lineTo(200, 100);path.lineTo(150, 150); reset()重置path，清空内容，但是不会改变fillType。 set (@NonNull Path src)用src替换当前path内的内容。 setLastPoint(float dx, float dy)设置path的最后一个点坐标。 与moveTo()的比较 类型 是否影响起点 是否影响之前的操作 moveTo() 是 否 setLastPoint() 否 是 如瞎下面画矩形addRect(200, 400, 400, 500, Path.Direction.CW)， 确定矩形的四个顶点坐标为(200,400)，(400,400)，(200,500)，(400,500)。 但设置setLastPoint(100, 450)后，四个点的坐标变为(200,400)，(400,400)，(100,450)，(400,500)。 这个方法在不同形状的子图形上有不同的显示效果，可以自己去试试。 12345678paint = new Paint(Paint.ANTI_ALIAS_FLAG);paint.setColor(Color.RED);paint.setStyle(Paint.Style.STROKE);mPath = new Path();mPath.addRect(200, 400, 400, 500, Path.Direction.CW);mPath.setLastPoint(100, 450);canvas.drawPath(mPath, paint); isConvex ()判断path是否为凸多边形。 offset(float dx, float dy)、offset(float dx, float dy, @Nullable Path dst)offset(float dx, float dy)：将当前path平移(dx,dy) offset(float dx, float dy, @Nullable Path dst)：dst为null时，与offset(float dx, float dy)效果一致；dst不为null时，将当前path平移后的状态存入dst中，不会影响当前path。 12345678public void offset(float dx, float dy, @Nullable Path dst) &#123; if (dst != null) &#123; dst.set(this); &#125; else &#123; dst = this; &#125; dst.offset(dx, dy);&#125;]]></content>
      <categories>
        <category>android</category>
        <category>view</category>
        <category>自定义</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>view</tag>
        <tag>Path</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View之Canvas.drawXXX()]]></title>
    <url>%2F3854066347%2F</url>
    <content type="text"><![CDATA[前言本篇主要记录Canvas 的绘制类方法： drawXXX() 。 关于画笔、范围裁切和几何变换的详细介绍，放到之后的篇章中具体展开。 预备知识坐标系 Android坐标系将屏幕的左上角的顶点作为Android坐标系的原点，这个原点向右是X轴正方向，原点向下是Y轴正方向。 并且提供了View.getLocationInWindow()、View.getLocationOnScreen()方法来获取view在屏幕中的坐标。详见Android获得控件在屏幕中的坐标 视图坐标系相对父布局而言。 如上图所示有如下几类： 自身宽高（getHeight()、getWidth()） 相对父容器坐标（getTop()、getLeft()、getRight()、getBottom()） MotionEvent提供的方法（getX()、getY()、getRawX()、getRawY()，其中前两个是相对于父容器，后两个是相对于屏幕） Canvas坐标系Canvas坐标系指的是Canvas本身的坐标系，Canvas坐标系有且只有一个，且是唯一不变的，其坐标原点在View的左上角，从坐标原点向右为x轴的正半轴，从坐标原点向下为y轴的正半轴。 绘图坐标系Canvas的drawXXX方法中传入的各种坐标指的都是绘图坐标系中的坐标，而非Canvas坐标系中的坐标。默认情况下，绘图坐标系与Canvas坐标系完全重合，即初始状况下，绘图坐标系的坐标原点也在View的左上角，从原点向右为x轴正半轴，从原点向下为y轴正半轴。但不同于Canvas坐标系，绘图坐标系并不是一成不变的，可以通过调用Canvas的translate方法平移坐标系，可以通过Canvas的rotate方法旋转坐标系，还可以通过Canvas的scale方法缩放坐标系，而且需要注意的是，translate、rotate、scale的操作都是基于当前绘图坐标系的，而不是基于Canvas坐标系，一旦通过以上方法对坐标系进行了操作之后，当前绘图坐标系就变化了，以后绘图都是基于更新的绘图坐标系了。也就是说，真正对我们绘图有用的是绘图坐标系而非Canvas坐标系。 drawXX系列常见的drawXX有：drawColor()、drawCircle()、drawRect()、drawPoint()、drawOval()、drawLine()、drawRoundRect()、drawArc()、drawPath()、drawText()、drawBitmap() 接下来就逐个介绍一下Canvas的各个drawXX方法的效果。 一般这些方法在protected void onDraw(Canvas canvas)方法中进行绘制。 drawColor(@ColorInt int color)在画布上填充（画）一层指定的颜色。如: 123456 @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas);// canvas.drawColor(Color.parseColor("#FF0000")); canvas.drawColor(Color.RED); &#125; 另一方法：drawColor(@ColorInt int color, @NonNull PorterDuff.Mode mode) 指定了PorterDuff模式，该参数的具体说明在下面章节中详细说明。这里简单提一下：该参数是设置绘画的重叠效果。 drawColor(@ColorInt int color)内部是指定为PorterDuff.Mode.SRC_OVER，这种模式的效果就是会覆盖之前的内容。 示例（盗用下别人的图）： 1drawColor(Color.parse("#88880000"); // 半透明红色 绘制颜色的还有两个方法drawARGB(int a, int r, int g, int b)和drawRGB(int r, int g, int b)。 这两个方法分别是通过传入ARGB、RGB 颜色值，进行颜色填充。其中各参数的取值范围为[0,255]。 可以看到，这两个方法内部最终是调用了drawColor()方法。 1234567public void drawARGB(int a, int r, int g, int b) &#123; drawColor(Color.argb(a, r, g, b));&#125;public void drawRGB(int r, int g, int b) &#123; drawColor(Color.rgb(r, g, b));&#125; drawCircle(float cx, float cy, float radius, @NonNull Paint paint)以（cx,cy）坐标为圆心，radius为半径，用paint画笔画一个圆。 其中cx、cy、radius用以确定圆的位置，而第四个参数paint则是控制所画圆的效果。 比如： 一：Paint.setColor(@ColorInt int color)设置画笔颜色 12paint.setColor(Color.RED); // 设置为红色canvas.drawCircle(300, 300, 200, paint); 二：Paint.setStyle(Style style)设置画笔样式，系统提供了3种： Paint.Style.FILL :0，填充模式，是paint的默认模式 Paint.Style.STROKE :1，画线模式 Paint.Style.FILL_AND_STROKE :2，填充完后画线 所以drawCircle时，paint为STROKE样式，则画出来的是一个圆环。 12paint.setStyle(Paint.Style.STROKE); // Style 修改为画线模式canvas.drawCircle(300, 300, 200, paint); 注：本篇未涉及到画布的几何变换（translate、rotate、scale、skew），所以这边的坐标系都以当前view左上角为原点，坐标原点向右为x轴的正半轴，从坐标原点向下为y轴的正半轴，即 Canvas坐标系。 三：Paint.setStrokeWidth(float width)为STROKE模式或FILL_AND_STROKE模式设置线条的宽度。 123paint.setStyle(Paint.Style.STROKE);paint.setStrokeWidth(20); // 线条宽度为 20 像素canvas.drawCircle(300, 300, 200, paint); 四： Paint.setAntiAlias(boolean aa)抗锯齿。让图形和文字的边缘更加平滑。 也可在 new Paint() 的时候加上一个 Paint.ANTI_ALIAS_FLAG 参数。 1Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG); 锯齿出现的主要原因是屏幕的分辨率过低，使得绘制的边缘出现颗粒化。抗锯齿效果是修改图形边缘处的像素颜色，从而让图形在肉眼看来具有更加平滑的感觉。 drawRect(float left, float top, float right, float bottom, @NonNull Paint paint)用paint绘制指定大小的矩形。矩形的大小形状由left、top、right、bottom四个参数决定。矩形的实心、空心等属性由paint决定。 重载方法： drawRect(@NonNull RectF rect, @NonNull Paint paint) drawRect(@NonNull Rect r, @NonNull Paint paint) 这两个方法通过第一个参数确定所绘制的矩形的4边位置。RectF和Rect内部都维护了left、top、right、bottom四个参数。区别是RectF内的是float类型，Rect内的是int类型。 123456789101112131415public class RectF implements Parcelable &#123; public float left; public float top; public float right; public float bottom; ……&#125;public final class Rect implements Parcelable &#123; public int left; public int top; public int right; public int bottom; ……&#125; drawRoundRect(float left, float top, float right, float bottom, float rx, float ry, @NonNull Paint paint)绘制圆角矩形。 与drawRect()类似，不过drawRoundRect()在paint前多传了两个参数用以确定四个圆角的弧度。 rx、ry分别与left、top、right、bottom四边形成四个矩形绘制椭圆，此椭圆的一边形成圆角矩形的圆角。 与drawRect()类似，该方法还有一个重载方法drawRoundRect(@NonNull RectF rect, float rx, float ry, @NonNull Paint paint)，通过RectF确定四边。 123456789101112 paint = new Paint(Paint.ANTI_ALIAS_FLAG); paint.setColor(Color.RED); paint.setStyle(Paint.Style.STROKE); @TargetApi(Build.VERSION_CODES.LOLLIPOP)@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); paint.setStrokeWidth(6); canvas.drawRoundRect(100, 100, 200, 300, 100, 200, paint); canvas.drawRoundRect(300, 100, 600, 600, 100, 200, paint);&#125; drawPoint(float x, float y, @NonNull Paint paint)绘制点。 x，y确定点的位置。paint控制点的属性。 drawPoint()中常用的Paint属性有： Paint.setStrokeWidth(width)：设置点的大小 Paint.setStrokeCap(cap)：设置点的形状 Paint.Cap.ROUND ：圆头，画线的时候会长于原始长度补半圆形 Paint.Cap.SQUARE：方头，画线的时候会长于原始长度补方形 Paint.Cap.BUTT：方头，画线的时候会等于原始长度，平头 注：Paint.setStrokeCap(cap) 可以设置点的形状，但这个方法并不是专门用来设置点的形状的，而是一个设置线条端点形状的方法。端点有圆头 (ROUND)、平头 (BUTT) 和方头 (SQUARE) 三种 与drawPoint()类似还有两个画点的方法： drawPoints(@Size(multiple = 2) @NonNull float[] pts, @NonNull Paint paint) drawPoints(@Size(multiple = 2) float[] pts, int offset, int count, @NonNull Paint paint) 这两个方法的作用是批量画点。 通过pts数组（数组长度是2的倍数）传入点的位置，两个为一组。 第二个方法中offset表示跳过pts数组中的前offset项开始记count个数，绘制count/2个点。 比如： 1234float[] points = &#123;0, 0, 50, 50, 50, 100, 100, 50, 100, 100, 150, 50, 150, 100&#125;;// 绘制四个点：(50, 50) (50, 100) (100, 50) (100, 100)canvas.drawPoints(points, 2 /* 跳过两个数，即前两个 0 */, 8 /* 一共绘制 8 个数（4 个点）*/, paint); drawOval(float left, float top, float right, float bottom, @NonNull Paint paint)绘制椭圆。 当left、top、right、bottom四边围成的是一个正方形时，绘制出来的是圆形。 重载方法：drawOval(@NonNull RectF oval, @NonNull Paint paint) drawLine(float startX, float startY, float stopX, float stopY, @NonNull Paint paint)绘制一条直线。(startX,startY)为绘制起点，(stopX,stopY)为绘制终点，如果线条很粗，则从startY对半延伸。 绘制多条直线： drawLines(@Size(multiple = 4) @NonNull float[] pts, int offset, int count, @NonNull Paint paint) drawLines(@Size(multiple = 4) @NonNull float[] pts, @NonNull Paint paint) 这两个方法与drawPoints()类似，不过drawLines()中的pts数组长度必须是4的倍数，用以确定每条线的起点与终点。 drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, @NonNull Paint paint)绘制弧线，用一个椭圆来描述弧形。 left, top, right, bottom 描述的是这个弧形所在的椭圆； startAngle 是弧形的起始角度（x 轴的正向，即正右的方向，是 0 度的位置；顺时针为正角度，逆时针为负角度）； sweepAngle 是弧形划过的角度； useCenter 表示是否连接到圆心，如果不连接到圆心，就是弧形，如果连接到圆心，就是扇形。 123456paint.setStyle(Paint.Style.FILL); // 填充模式canvas.drawArc(200, 100, 800, 500, -110, 100, true, paint); // 绘制扇形canvas.drawArc(200, 100, 800, 500, 20, 100, false, paint); // 绘制弧形paint.setStyle(Paint.Style.STROKE); // 画线模式canvas.drawArc(200, 100, 800, 500, 130, 40, true, paint); // 绘制封口的扇形边线canvas.drawArc(200, 100, 800, 500, 180, 60, false, paint); // 绘制不封口的弧形 drawText(@NonNull String text, float x, float y, @NonNull Paint paint)绘制文字。 text 是绘制的文字内容，(x,y)是绘制的起点位置（是文本对应的baseline处，并非绘制文本的左上角），paint用以控制绘制文本的属性（比如：Paint.setTextSize(textSize)，可以设置文字的大小；Paint.setTypeface(Typeface typeface)，设置字体）。 重载方法： drawText(@NonNull char[] text, int index, int count, float x, float y, @NonNull Paint paint) drawText(@NonNull String text, int start, int end, float x, float y, @NonNull Paint paint) drawText(@NonNull CharSequence text, int start, int end, float x, float y, @NonNull Paint paint) 这三个方法通过参数index、count或start、end去截取text中的内容进行绘制。 绘制文本的还有两个方法： drawTextOnPath(@NonNull char[] text, int index, int count, @NonNull Path path, float hOffset, float vOffset, @NonNull Paint paint) rawTextOnPath(@NonNull String text, @NonNull Path path, float hOffset, float vOffset, @NonNull Paint paint) 这两个方法将文本绘制在path路径上。好比是之前的baseline是条直线，现在的baseline是path这条线。 hOffset 和 vOffset是文字相对于 Path 的水平偏移量和竖直偏移量，利用它们可以调整文字的位置。 关于drawText()配合paint的其他效果，将在下篇文章中具体展开。 drawPath(@NonNull Path path, @NonNull Paint paint)绘制path路径（自定义图像），将path内容绘制出来。 path中所涉及到的内容比较复杂，这节也会单独抽出来详细讲解path的用途。 这里简单说一下path在drawPath()中可以做哪些事：线段、二次曲线、三次曲线。 drawBitmap(@NonNull Bitmap bitmap, float left, float top, @Nullable Paint paint)绘制 Bitmap 对象，将Bitmap的内容绘制在指定位置（left,top）。（left,top）为绘制Bitmap对象的左上角。 重载方法： drawBitmap(@NonNull Bitmap bitmap, @Nullable Rect src, @NonNull RectF dst, @Nullable Paint paint) drawBitmap(@NonNull Bitmap bitmap, @Nullable Rect src, @NonNull Rect dst, @Nullable Paint paint) drawBitmap(@NonNull Bitmap bitmap, @NonNull Matrix matrix, @Nullable Paint paint) 前两个方法的唯一区别是dst参数的类型，这与drawRect的重载方法中的类似，这里就一起讲解其作用。 前两个方法中： src 用于裁剪bitmap，drawBitmap()方法只会绘制src所限定的区域 dst 用于确定bitmap绘制的位置，通过src所限定的区域内的bitmap内容会显示在dst区域内，并且会通过缩放铺满dst区域。通过修改dst值，可以实现图像的移动及缩放。 第三个方法传入的matrix来绘制bitmap。drawBitmap()的其他重载方法内部是使用了Canvas当前的matrix来进行几何变换。常用的方法有pre/postTranslate/Rotate/Scale/Skew()。 关于几何变换，会在之后的篇章中详细介绍，尤其是对pre和post的几个方法组合调用先后关系的理解。 关于drawBitmap的方法还有一个：drawBitmapMesh(@NonNull Bitmap bitmap, int meshWidth, int meshHeight, @NonNull float[] verts, int vertOffset, @Nullable int[] colors, int colorOffset, @Nullable Paint paint) 实现对 Bitmap 的各种扭曲。 方法drawBitmapMesh中的Mesh翻译过来即：网格。 将一个图片横向、纵向均匀切割成 n 份，就会形成一个「网格」，我把所有网格线的交点称为「顶点」。 正常情况下，顶点是均匀分布的。当我们改变了顶点的位置时，系统会拿偏移后的顶点坐标，和原来的坐标进行对比，通过一套算法，将图片进行扭曲，像这样： 方法参数说明： bitmap - 需要转换的位图 meshWidth - 横向的格数， 0的时候不会绘制 meshHeight - 纵向的格数，0的时候不会绘制 verts - 网格顶点坐标数组，记录扭曲后图片各顶点的坐标，数组大小为 (meshWidth+1) (meshHeight+1) 2 + vertOffset vertOffset - 从第几个顶点开始对位图进行扭曲，通常传 0 colors - 设置网格顶点的颜色，该颜色会和位图对应像素的颜色叠加，数组大小为 (meshWidth+1) * (meshHeight+1) + colorOffset，可以传 null colorOffset - 从第几个顶点开始转换颜色，通常传 0 paint - 「画笔」，可以传 null 需要说明一下的是，可以用 colors 这个参数来实现阴影的效果，但在 API 18 以下开启了硬件加速，colors 这个参数是不起作用的 具体的使用可以查看这篇文章浪起来！使用 drawBitmapMesh 实现仿真水波纹效果 官方介绍 table th:nth-of-type(1) { width: 16%; } table th:nth-of-type(2) { width: 84%; } 返回类型 Canvas.drawXXX()方法简介 void drawARGB(int a, int r, int g, int b)Fill the entire canvas’ bitmap (restricted to the current clip) with the specified ARGB color, using srcover porterduff mode. void drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint)Draw the specified arc, which will be scaled to fit inside the specified oval. void drawArc(RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint)Draw the specified arc, which will be scaled to fit inside the specified oval. void drawBitmap(Bitmap bitmap, Matrix matrix, Paint paint)Draw the bitmap using the specified matrix. void drawBitmap(int[] colors, int offset, int stride, float x, float y,int width, int height, boolean hasAlpha, Paint paint)This method was deprecated in API level 21. Usage with a hardware accelerated canvas requires an internal copy of color buffer contents every time this method is called. Using a Bitmap avoids this copy, and allows the application to more explicitly control the lifetime and copies of pixel data. void drawBitmap(int[] colors, int offset, int stride, int x, int y, int width, int height, boolean hasAlpha, Paint paint)This method was deprecated in API level 21. Usage with a hardware accelerated canvas requires an internal copy of color buffer contents every time this method is called. Using a Bitmap avoids this copy, and allows the application to more explicitly control the lifetime and copies of pixel data. void drawBitmap(Bitmap bitmap, Rect src, Rect dst, Paint paint)Draw the specified bitmap, scaling/translating automatically to fill the destination rectangle. void drawBitmap(Bitmap bitmap, Rect src, RectF dst, Paint paint)Draw the specified bitmap, scaling/translating automatically to fill the destination rectangle. void drawBitmap(Bitmap bitmap, float left, float top, Paint paint)Draw the specified bitmap, with its top/left corner at (x,y), using the specified paint, transformed by the current matrix. void drawBitmapMesh(Bitmap bitmap, int meshWidth, int meshHeight, float[] verts, int vertOffset, int[] colors, int colorOffset, Paint paint)Draw the bitmap through the mesh, where mesh vertices are evenly distributed across the bitmap. void drawCircle(float cx, float cy, float radius, Paint paint)Draw the specified circle using the specified paint. void drawColor(int color)Fill the entire canvas’ bitmap (restricted to the current clip) with the specified color, using srcover porterduff mode. void drawColor(int color, PorterDuff.Mode mode)Fill the entire canvas’ bitmap (restricted to the current clip) with the specified color and porter-duff xfermode. void drawLine(float startX, float startY, float stopX, float stopY, Paintpaint)Draw a line segment with the specified start and stop x,y coordinates, using the specified paint. void drawLines(float[] pts, int offset, int count, Paint paint)Draw a series of lines. void drawLines(float[] pts, Paint paint) void drawOval(float left, float top, float right, float bottom, Paintpaint)Draw the specified oval using the specified paint. void drawOval(RectF oval, Paint paint)Draw the specified oval using the specified paint. void drawPaint(Paint paint)Fill the entire canvas’ bitmap (restricted to the current clip) with the specified paint. void drawPatch(NinePatch patch, RectF dst, Paint paint) void drawPatch(NinePatch patch, Rect dst, Paint paint) void drawPath(Path path, Paint paint)Draw the specified path using the specified paint. void drawPicture(Picture picture, RectF dst)Draw the picture, stretched to fit into the dst rectangle. void drawPicture(Picture picture)Save the canvas state, draw the picture, and restore the canvas state. void drawPicture(Picture picture, Rect dst)Draw the picture, stretched to fit into the dst rectangle. void drawPoint(float x, float y, Paint paint)Helper for drawPoints() for drawing a single point. void drawPoints(float[] pts, Paint paint)Helper for drawPoints() that assumes you want to draw the entire array void drawPoints(float[] pts, int offset, int count, Paint paint)Draw a series of points. void drawPosText(String text, float[] pos, Paint paint)This method was deprecated in API level 16. This method does not support glyph composition and decomposition and should therefore not be used to render complex scripts. It also doesn’t handle supplementary characters (eg emoji). void drawPosText(char[] text, int index, int count, float[] pos, Paintpaint)This method was deprecated in API level 16. This method does not support glyph composition and decomposition and should therefore not be used to render complex scripts. It also doesn’t handle supplementary characters (eg emoji). void drawRGB(int r, int g, int b)Fill the entire canvas’ bitmap (restricted to the current clip) with the specified RGB color, using srcover porterduff mode. void drawRect(float left, float top, float right, float bottom, Paintpaint)Draw the specified Rect using the specified paint. void drawRect(Rect r, Paint paint)Draw the specified Rect using the specified Paint. void drawRect(RectF rect, Paint paint)Draw the specified Rect using the specified paint. void drawRoundRect(RectF rect, float rx, float ry, Paint paint)Draw the specified round-rect using the specified paint. void drawRoundRect(float left, float top, float right, float bottom,float rx, float ry, Paint paint)Draw the specified round-rect using the specified paint. void drawText(CharSequence text, int start, int end, float x, float y,Paint paint)Draw the specified range of text, specified by start/end, with its origin at (x,y), in the specified Paint. void drawText(String text, float x, float y, Paint paint)Draw the text, with origin at (x,y), using the specified paint. void drawText(char[] text, int index, int count, float x, float y, Paintpaint)Draw the text, with origin at (x,y), using the specified paint. void drawText(String text, int start, int end, float x, float y, Paintpaint)Draw the text, with origin at (x,y), using the specified paint. void drawTextOnPath(String text, Path path, float hOffset, float vOffset,Paint paint)Draw the text, with origin at (x,y), using the specified paint, along the specified path. void drawTextOnPath(char[] text, int index, int count, Path path, float hOffset, float vOffset, Paint paint)Draw the text, with origin at (x,y), using the specified paint, along the specified path. void drawTextRun(char[] text, int index, int count, int contextIndex, int contextCount, float x, float y, boolean isRtl, Paint paint)Draw a run of text, all in a single direction, with optional context for complex text shaping. void drawTextRun(CharSequence text, int start, int end, int contextStart,int contextEnd, float x, float y, boolean isRtl, Paint paint)Draw a run of text, all in a single direction, with optional context for complex text shaping. void drawVertices(Canvas.VertexMode mode, int vertexCount, float[] verts,int vertOffset, float[] texs, int texOffset, int[] colors, int colorOffset, short[] indices, int indexOffset, int indexCount, Paintpaint)Draw the array of vertices, interpreted as triangles (based on mode). 参考Android中的坐标系统 Android 开发进阶 UI 部分 1-1：绘制基础 浪起来！使用 drawBitmapMesh 实现仿真水波纹效果]]></content>
      <categories>
        <category>android</category>
        <category>view</category>
        <category>自定义</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>view</tag>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View之使用DrawableState实现选择框]]></title>
    <url>%2F2231365790%2F</url>
    <content type="text"><![CDATA[前言本篇主要记录一下有两种状态（选中、未选中）图标的ImageView。通过点击可以切换状态。 主要记录源码。其中主要的代码是CheckableImageView.java，其中的主要代码也写有注释，这里就不啰嗦了。 详细代码CheckableImageView.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117/** * &lt;pre&gt; * author : Haitao * blog : http://www.nhtzj.com * time : 2018/8/14 * desc : 选中、未选中图标的ImageView * version: 1.0 * &lt;/pre&gt; */public class CheckableImageView extends AppCompatImageView implements Checkable, View.OnClickListener &#123; private OnViewListener mListener; private boolean mChecked; private static final int[] CHECKED_STATE_SET = &#123;android.R.attr.state_checked&#125;; public CheckableImageView(Context context) &#123; this(context, null); &#125; public CheckableImageView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public CheckableImageView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); //若未指定切换的图标，则使用默认的 Drawable drawable = getDrawable(); if (drawable == null) &#123; setImageResource(R.drawable.check_button); &#125; //设置点击监听，这样即使用户没有设置回调，本控件也能使用 bindEvent(); &#125; @Override public int[] onCreateDrawableState(final int extraSpace) &#123; if (!isChecked()) &#123; // 如果未选中，直接返回父类的结果 return super.onCreateDrawableState(extraSpace); &#125; else &#123; // 如果选中，将父类的结果和选中状态合并之后返回 int[] drawableState = super.onCreateDrawableState(extraSpace + 1); return mergeDrawableStates(drawableState, CHECKED_STATE_SET); &#125; &#125; @Override public void setChecked(boolean checked) &#123; if (mChecked != checked) &#123; mChecked = checked; refreshDrawableState(); &#125; &#125; @Override public boolean isChecked() &#123; return mChecked; &#125; @Override public void toggle() &#123; setChecked(!mChecked); &#125; /** * 重写setOnClickListener方法，将传入的参数进行包装 * * @param l */ @Override public void setOnClickListener(final OnClickListener l) &#123; OnClickListener onClickListener = new OnClickListener() &#123; @Override public void onClick(View v) &#123; toggle(); if (l != null) &#123; l.onClick(v); &#125; &#125; &#125;; super.setOnClickListener(onClickListener); &#125; @Override public void onClick(View v) &#123; if (mListener != null) &#123; mListener.onViewClick(v); &#125; &#125; /** * 绑定点击监听 */ private void bindEvent() &#123; setOnClickListener(this); &#125; /** * 设置回调 * * @param l */ public void setListener(OnViewListener l) &#123; this.mListener = l; &#125; /** * 自定义点击回调 */ interface OnViewListener &#123; void onViewClick(View v); &#125;&#125; 资源文件check_button.xml12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android" android:enterFadeDuration="@android:integer/config_shortAnimTime" android:exitFadeDuration="@android:integer/config_shortAnimTime"&gt; &lt;item android:drawable="@drawable/ic_checked" android:state_checked="true" /&gt; &lt;item android:drawable="@drawable/ic_unchecked" android:state_checked="false" /&gt;&lt;/selector&gt; ic_checked.xml123456789101112&lt;vector xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:width="24dp" android:height="24dp" android:autoMirrored="true" android:viewportHeight="1024" android:viewportWidth="1024" tools:ignore="UnusedAttribute,VectorRaster"&gt; &lt;path android:fillColor="#1FC88B" android:pathData="M512,64C265.6,64 64,265.6 64,512s201.6,448 448,448 448,-201.6 448,-448S758.4,64 512,64zM755.2,387.2l-294.4,278.4c-12.8,12.8 -32,12.8 -44.8,0L297.6,544c-12.8,-12.8 -12.8,-32 0,-44.8s32,-12.8 44.8,0l96,96 272,-256c12.8,-12.8 32,-12.8 44.8,0s12.8,35.2 0,48z" /&gt;&lt;/vector&gt; ic_unchecked.xml123456789101112&lt;vector xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:width="24dp" android:height="24dp" android:autoMirrored="true" android:viewportHeight="1024" android:viewportWidth="1024" tools:ignore="UnusedAttribute,VectorRaster"&gt; &lt;path android:fillColor="#1FC88B" android:pathData="M512,960C265.6,960 64,758.4 64,512S265.6,64 512,64s448,201.6 448,448 -201.6,448 -448,448zM512,896c211.2,0 384,-172.8 384,-384S723.2,128 512,128 128,300.8 128,512s172.8,384 384,384z" /&gt;&lt;/vector&gt; 参考Android 中 View 的中的 DrawableState]]></content>
      <categories>
        <category>android</category>
        <category>view</category>
        <category>自定义</category>
      </categories>
      <tags>
        <tag>view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F1935562632%2F</url>
    <content type="text"><![CDATA[前言Java 中常见的排序算法有如下几种： 选择排序（SelectionSort） 冒泡排序（BubbleSort） 插入排序（InsertionSort） 快速排序（QuickSort） 归并排序（MergeSort） 希尔排序（ShellSort） 堆排序（HeapSort） 代码中使用到的SortUtils和SortAlgorithm请查看章节 SortUtils和SortAlgorithm 选择排序（SelectionSort） table th:nth-of-type(1) { width: 50%; } table th:nth-of-type(2) { width: 50%; } 选择排序 选择排序的示例动画。红色表示当前最小值，黄色表示已排序序列，蓝色表示当前位置。 算法说明From Wikipedia：选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 Java代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package sort;import static sort.SortUtils.*;/** * 选择排序 * * @see SortAlgorithm * */public class SelectionSort implements SortAlgorithm &#123; /** * This method implements the Generic Selection Sort * * @param arr The array to be sorted * Sorts the array in increasing order **/ @Override public &lt;T extends Comparable&lt;T&gt;&gt; T[] sort(T[] arr) &#123; int n = arr.length; for (int i = 0; i &lt; n - 1; i++) &#123; // Initial index of min int min = i; for (int j = i +1 ; j &lt; n; j++) &#123; if (less(arr[j], arr[min])) &#123; min = j; &#125; &#125; // Swapping if index of min is changed if (min != i) &#123; swap(arr, i , min); &#125; &#125; return arr; &#125; // Driver Program public static void main(String[] args) &#123; Integer[] arr = &#123;4, 23, 6, 78, 1, 54, 231, 9, 12&#125;; SelectionSort selectionSort = new SelectionSort(); Integer[] sorted = selectionSort.sort(arr); // Output =&gt; 1 4 6 9 12 23 54 78 231 print(sorted); // String Input String[] strings = &#123;"c", "a", "e", "b","d"&#125;; String[] sortedStrings = selectionSort.sort(strings); //Output =&gt; a b c d e print(sortedStrings); &#125;&#125; 冒泡排序（BubbleSort） 使用冒泡排序为一列数字进行排序的过程 冒泡排序 From Wikipedia:冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 冒泡排序对n个项目需要O( n^{2})的比较次数，且可以原地排序。尽管这个算法是最简单了解和实现的排序算法之一，但它对于包含大量的元素的数列排序是很没有效率的。 冒泡排序是与插入排序拥有相等的运行时间，但是两种算法在需要的交换次数却很大地不同。在最坏的情况，冒泡排序需要 O(n^{2})次交换，而插入排序只要最多O(n)交换。冒泡排序的实现（类似下面）通常会对已经排序好的数列拙劣地运行O(n^{2})，而插入排序在这个例子只需要O(n)个运算。因此很多现代的算法教科书避免使用冒泡排序，而用插入排序取代之。冒泡排序如果能在内部循环第一次运行时，使用一个旗标来表示有无需要交换的可能，也可以把最优情况下的复杂度降低到 O(n)。在这个情况，已经排序好的数列就无交换的需要。若在每次走访数列时，把走访顺序反过来，也可以稍微地改进效率。有时候称为鸡尾酒排序，因为算法会从数列的一端到另一端之间穿梭往返。 冒泡排序算法的运作如下： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 由于它的简洁，冒泡排序通常被用来对于程序设计入门的学生介绍算法的概念。 Java代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package sort;import static sort.SortUtils.*;/** * 冒泡排序 * * @see SortAlgorithm */class BubbleSort implements SortAlgorithm &#123; /** * This method implements the Generic Bubble Sort * * @param array The array to be sorted * Sorts the array in increasing order **/ @Override public &lt;T extends Comparable&lt;T&gt;&gt; T[] sort(T[] unsorted) &#123; int n = unsorted.length; int newn; do &#123; newn = 0; for (int i = 1; i &lt; n; i++) if (unsorted[i - 1].compareTo(unsorted[i]) &gt; 0) &#123; swap(unsorted, i - 1, i); newn = i; &#125; n = newn; &#125; while (newn &gt; 0); return null; &#125; // Driver Program public static void main(String[] args) &#123; // Integer Input Integer[] integers = &#123;4, 23, 6, 78, 1, 54, 231, 9, 12&#125;; BubbleSort bubbleSort = new BubbleSort(); bubbleSort.sort(integers); // Output =&gt; 231, 78, 54, 23, 12, 9, 6, 4, 1 print(integers); // String Input String[] strings = &#123;"c", "a", "e", "b","d"&#125;; //Output =&gt; e, d, c, b, a print(bubbleSort.sort(strings)); &#125;&#125; 插入排序（InsertionSort） 使用插入排序为一列数字进行排序的过程 使用插入排序为一列数字进行排序的过程 From Wikipedia:插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 Java代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package sort;import static sort.SortUtils.less;import static sort.SortUtils.print;/** *插入排序 * */class InsertionSort implements SortAlgorithm &#123; /** * This method implements the Generic Insertion Sort * Sorts the array in increasing order * * @param array The array to be sorted * **/ @Override public &lt;T extends Comparable&lt;T&gt;&gt; T[] sort(T[] array) &#123; for (int j = 1; j &lt; array.length; j++) &#123; // Picking up the key(Card) T key = array[j]; int i = j - 1; while (i &gt;= 0 &amp;&amp; less(key, array[i])) &#123; array[i + 1] = array[i]; i--; &#125; // Placing the key (Card) at its correct position in the sorted subarray array[i + 1] = key; &#125; return array; &#125; // Driver Program public static void main(String[] args) &#123; // Integer Input Integer[] integers = &#123;4, 23, 6, 78, 1, 54, 231, 9, 12&#125;; InsertionSort sort = new InsertionSort(); sort.sort(integers); // Output =&gt; 1 4 6 9 12 23 54 78 231 print(integers); // String Input String[] strings = &#123;"c", "a", "e", "b","d"&#125;; sort.sort(strings); //Output =&gt; a b c d e print(strings); &#125;&#125; 快速排序（QuickSort） 使用快速排序法对一列数字进行排序的过程 快速排序采用“分而治之、各个击破”的观念，此为原地（In-place）分区版本。 From Wikipedia:快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序 n个项目要O(n\log n)（大O符号）次比较。在最坏状况下则需要 O(n^{2})次比较，但这种状况并不常见。事实上，快速排序 \Theta (n log n)通常明显比其他算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成。 Java代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package sort;import static sort.SortUtils.*;/** * 快排 * @see SortAlgorithm */class QuickSort implements SortAlgorithm &#123; /** * This method implements the Generic Quick Sort * * @param array The array to be sorted * Sorts the array in increasing order **/ @Override public &lt;T extends Comparable&lt;T&gt;&gt; T[] sort(T[] array) &#123; doSort(array, 0, array.length - 1); return array; &#125; /** * The sorting process * * @param left The first index of an array * @param right The last index of an array * @param array The array to be sorted **/ private static &lt;T extends Comparable&lt;T&gt;&gt; void doSort(T[] array, int left, int right) &#123; if (left &lt; right) &#123; int pivot = partition(array, left, right); doSort(array, left, pivot - 1); doSort(array, pivot, right); &#125; &#125; /** * This method finds the partition index for an array * * @param array The array to be sorted * @param left The first index of an array * @param right The last index of an array * Finds the partition index of an array **/ private static &lt;T extends Comparable&lt;T&gt;&gt; int partition(T[] array, int left, int right) &#123; int mid = (left + right) / 2; T pivot = array[mid]; while (left &lt;= right) &#123; while (less(array[left], pivot)) &#123; ++left; &#125; while (less(pivot, array[right])) &#123; --right; &#125; if (left &lt;= right) &#123;// System.out.println("pivot &gt;&gt; " + pivot + " left &gt;&gt; " + left + " right &gt;&gt; " + right + " vleft &gt;&gt; " + array[left] + " vright &gt;&gt; " + array[right]); swap(array, left, right); ++left; --right; &#125; &#125; return left; &#125; // Driver Program public static void main(String[] args) &#123; // For integer input Integer[] array = &#123;3, 4, 1, 32, 0, 1, 5, 12, 2, 5, 7, 8, 9, 2, 44, 111, 5&#125;; QuickSort quickSort = new QuickSort(); quickSort.sort(array); //Output =&gt; 0 1 1 2 2 3 4 5 5 5 7 8 9 12 32 44 111 print(array); String[] stringArray = &#123;"c", "a", "e", "b", "d"&#125;; quickSort.sort(stringArray); //Output =&gt; a b c d e print(stringArray); &#125;&#125; 归并排序（MergeSort） 归并排序 一个归并排序的例子：对一个随机点的链表进行排序 归并排序有的地方也称为合并排序。 From Wikipedia:归并排序（英语：Merge sort，或mergesort），是创建在归并操作上的一种有效的排序算法，效率为 O(n log n)（大O符号）。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。 归并操作归并操作（merge），也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。 递归法（Top-down） 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列 设定两个指针，最初位置分别为两个已经排序序列的起始位置 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 重复步骤3直到某一指针到达序列尾 将另一序列剩下的所有元素直接复制到合并序列尾 迭代法（Bottom-up）原理如下（假设序列共有n个元素）： 将序列每相邻两个数字进行归并操作，形成ceil(n/2)个序列，排序后每个序列包含两/一个元素 若此时序列数不是1个则将上述序列再次归并，形成ceil(n/4)个序列，每个序列包含四/三个元素 重复步骤2，直到所有元素排序完毕，即序列数为1 Java代码实现递归法（Top-down）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package sort;import static sort.SortUtils.print;/** * This method implements the Generic Merge Sort * 归并排序 递归方式 * @see SortAlgorithm */class MergeSort implements SortAlgorithm &#123; /** * This method implements the Generic Merge Sort * * @param unsorted the array which should be sorted * @param &lt;T&gt; Comparable class * @return sorted array */ @Override @SuppressWarnings("unchecked") public &lt;T extends Comparable&lt;T&gt;&gt; T[] sort(T[] unsorted) &#123; T[] tmp = (T[]) new Comparable[unsorted.length]; doSort(unsorted, tmp, 0, unsorted.length - 1); return unsorted; &#125; /** * @param arr The array to be sorted * @param temp The copy of the actual array * @param left The first index of the array * @param right The last index of the array * Recursively sorts the array in increasing order **/ private static &lt;T extends Comparable&lt;T&gt;&gt; void doSort(T[] arr, T[] temp, int left, int right) &#123; if (left &lt; right) &#123; int mid = left + (right - left) / 2; doSort(arr, temp, left, mid); doSort(arr, temp, mid + 1, right); merge(arr, temp, left, mid, right); &#125; &#125; /** * This method implements the merge step of the merge sort * * @param arr The array to be sorted * @param temp The copy of the actual array * @param left The first index of the array * @param mid The middle index of the array * @param right The last index of the array * merges two parts of an array in increasing order **/ private static &lt;T extends Comparable&lt;T&gt;&gt; void merge(T[] arr, T[] temp, int left, int mid, int right) &#123; System.arraycopy(arr, left, temp, left, right - left + 1); int i = left; int j = mid + 1; int k = left; while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; if (temp[i].compareTo(temp[j]) &lt;= 0) &#123; arr[k] = temp[i]; i++; &#125; else &#123; arr[k] = temp[j]; j++; &#125; k++; &#125; while (i &lt;= mid) &#123; arr[k] = temp[i]; i++; k++; &#125; while (j &lt;= right) &#123; arr[k] = temp[j]; j++; k++; &#125; &#125; // Driver program public static void main(String[] args) &#123; // Integer Input Integer[] arr = &#123;4, 23, 6, 78, 1, 54, 231, 9, 12&#125;; MergeSort mergeSort = new MergeSort(); mergeSort.sort(arr); // Output =&gt; 1 4 6 9 12 23 54 78 231 print(arr); // String Inpu String[] stringArray = &#123;"c", "a", "e", "b", "d"&#125;; mergeSort.sort(stringArray); //Output =&gt; a b c d e print(stringArray); &#125;&#125; From wikipedia，整体思路一致，区别为：👆那版本是先通过 System.arraycopy()将arr数组指定数据段复制到temp数组中后直接对arr数组进行操作。而wikipedia版的则为操作result数组后再拷贝回arr数组。 1234567891011121314151617181920212223static void merge_sort_recursive(int[] arr, int[] result, int start, int end) &#123; if (start &gt;= end) return; int len = end - start, mid = (len &gt;&gt; 1) + start; int start1 = start, end1 = mid; int start2 = mid + 1, end2 = end; merge_sort_recursive(arr, result, start1, end1); merge_sort_recursive(arr, result, start2, end2); int k = start; while (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2) result[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++]; while (start1 &lt;= end1) result[k++] = arr[start1++]; while (start2 &lt;= end2) result[k++] = arr[start2++]; for (k = start; k &lt;= end; k++) arr[k] = result[k];&#125;public static void merge_sort(int[] arr) &#123; int len = arr.length; int[] result = new int[len]; merge_sort_recursive(arr, result, 0, len - 1);&#125; 迭代法（Bottom-up）12345678910111213141516171819202122232425262728293031public static void merge_sort(int[] arr) &#123; int len = arr.length; int[] result = new int[len]; int block, start; // 原版代码的迭代次数少了一次，没有考虑到奇数列数组的情况 for(block = 1; block &lt; len; block *= 2) &#123; for(start = 0; start &lt;len; start += 2 * block) &#123; int low = start; int mid = (start + block) &lt; len ? (start + block) : len; int high = (start + 2 * block) &lt; len ? (start + 2 * block) : len; //两个块的起始下标及结束下标 int start1 = low, end1 = mid; int start2 = mid, end2 = high; //开始对两个block进行归并排序 while (start1 &lt; end1 &amp;&amp; start2 &lt; end2) &#123; result[low++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++]; &#125; while(start1 &lt; end1) &#123; result[low++] = arr[start1++]; &#125; while(start2 &lt; end2) &#123; result[low++] = arr[start2++]; &#125; &#125; int[] temp = arr; arr = result; result = temp; &#125; result = arr; &#125; 希尔排序（ShellSort） 希尔排序 希尔排序算法彩条 From Wikipedia:希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位 希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。 步长序列步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。 Donald Shell最初建议步长选择为 n/2 并且对步长取半直到步长达到1。虽然这样取可以比O(n^{2})类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如，如果一个数列以步长5进行了排序然后再以步长3进行排序，那么该数列不仅是以步长3有序，而且是以步长5有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就不会以如此短的时间完成排序了。 步长序列 最坏情况下复杂度 n/2^i O(n^2) 2^k - 1 O(n^{3/2}) (2^i)*(3^j) O(n log^2 n) 已知的最好步长序列是由Sedgewick提出的(1, 5, 19, 41, 109,…)，该序列的项来自$$9\times 4^{i}-9\times 2^{i}+1$$和$$2^{i+2}\times (2^{i+2}-3)+1$$这两个算式[1]。这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长序列的希尔排序比插入排序要快，甚至在小数组中比快速排序和堆排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。 另一个在大数组中表现优异的步长序列是（斐波那契数列除去0和1将剩余的数以黄金分区比的两倍的幂进行运算得到的数列）：(1, 9, 34, 182, 836, 4025, 19001, 90358, 428481, 2034035, 9651787, 45806244, 217378076, 1031612713,…)[2] Java代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package sort;import static sort.SortUtils.*;/** * 希尔排序 * * @see SortAlgorithm * */public class ShellSort implements SortAlgorithm &#123; /** * This method implements Generic Shell Sort. * @param array The array to be sorted */ @Override public &lt;T extends Comparable&lt;T&gt;&gt; T[] sort(T[] array) &#123; int N = array.length; int h = 1; while (h &lt; N/3) &#123; h = 3 * h + 1; &#125; while (h &gt;= 1) &#123; for (int i = h; i &lt; N; i++) &#123; for (int j = i; j &gt;= h &amp;&amp; less(array[j], array[j-h]); j -= h) &#123; swap(array, j, j - h); &#125; &#125; h /= 3; &#125; return array; &#125; public static void main(String[] args) &#123; Integer[] toSort = &#123;4, 23, 6, 78, 1, 54, 231, 9, 12&#125;; ShellSort sort = new ShellSort(); Integer[] sorted = sort.sort(toSort); print(sorted); &#125;&#125; 堆排序（HeapSort）算法说明堆排序是对简单选择排序的改进 简单选择排序是从n个记录中找出一个最小的记录，需要比较n-1次。但是这样的操作并没有把每一趟的比较结果保存下来，在后一趟的比较中，有许多比较在前一趟已经做过了，但由于前一趟排序时未保存这些比较结果，所以后一趟排序时又重复执行了这些比较操作，因而记录的比较次数较多。 二叉树: 每个结点最多有两个子树的有序树 完全二叉树：除最后一层，其他各层的节点都有2个子节点。并且最后一层从左往右有若干连续节点。 满二叉树：完全二叉树的特殊存在，即完全二叉树的最后一层都有节点。即除最后一层外，每个节点下都有2个子节点 堆里面有两个特殊的存在： 最大堆（大顶堆）：每个结点的值都大于或等于其左右孩子结点的值 最小堆（小顶堆）：每个结点的值都小于或等于其左右孩子结点的值 通过最小堆（最大堆）和完全二叉树的特性，构成了堆排序。 维基百科堆排序（英语：Heapsort）是指利用堆)这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 算法思路思路一：将数据排列成最小堆。第一项即为最小值。取出后将数据序列的最后一项移到第一项处，刷新当前最小堆从而得出当前最小堆中的最小值。以此往复得出排序。 思路二：将数据排列成最大堆。第一项即为最大值。取出后将数据序列的最后一项移到第一项处，刷新当前最大堆从而得出当前最大堆中的最大值。以此往复得出排序 思路一适用于从大到小排序，可以直接将每次的首项与当前堆的最后一节点数据置换，可以在同一个数组上操作。当然也可以新建一个数组存放从小到大的数据。 Java代码实现最大堆（维基百科-堆排序Java） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import java.util.Arrays;public class HeapSort &#123; private int[] arr; public HeapSort(int[] arr)&#123; this.arr = arr; &#125; /** * 堆排序的主要入口方法，共两步。 */ public void sort()&#123; /* * 第一步：将数组堆化 * beginIndex = 第一个非叶子节点。 * 从第一个非叶子节点开始即可。无需从最后一个叶子节点开始。 * 叶子节点可以看作已符合堆要求的节点，根节点就是它自己且自己以下值为最大。 */ int len = arr.length - 1; int beginIndex = (len - 1) &gt;&gt; 1; for(int i = beginIndex; i &gt;= 0; i--)&#123; maxHeapify(i, len); &#125; /* * 第二步：对堆化数据排序 * 每次都是移出最顶层的根节点A[0]，与最尾部节点位置调换，同时遍历长度 - 1。 * 然后从新整理被换到根节点的末尾元素，使其符合堆的特性。 * 直至未排序的堆长度为 0。 */ for(int i = len; i &gt; 0; i--)&#123; swap(0, i); maxHeapify(0, i - 1); &#125; &#125; private void swap(int i,int j)&#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; /** * 调整索引为 index 处的数据，使其符合堆的特性。 * * @param index 需要堆化处理的数据的索引 * @param len 未排序的堆（数组）的长度 */ private void maxHeapify(int index,int len)&#123; int li = (index &lt;&lt; 1) + 1; // 左子节点索引 int ri = li + 1; // 右子节点索引 int cMax = li; // 子节点值最大索引，默认左子节点。 if(li &gt; len) return; // 左子节点索引超出计算范围，直接返回。 if(ri &lt;= len &amp;&amp; arr[ri] &gt; arr[li]) // 先判断左右子节点，哪个较大。 cMax = ri; if(arr[cMax] &gt; arr[index])&#123; swap(cMax, index); // 如果父节点被子节点调换， maxHeapify(cMax, len); // 则需要继续判断换下后的父节点是否符合堆的特性。 &#125; &#125; /** * 测试用例 * * 输出： * [0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9] */ public static void main(String[] args) &#123; int[] arr = new int[]&#123;3,5,3,0,8,6,1,5,8,6,2,4,9,4,7,0,1,8,9,7,3,1,2,5,9,7,4,0,2,6&#125;; new HeapSort(arr).sort(); System.out.println(Arrays.toString(arr)); &#125; &#125; SortUtils和SortAlgorithmSortAlgorithm.java1234567891011121314151617181920public interface SortAlgorithm &#123; /** * Main method arrays sorting algorithms * @param unsorted - an array should be sorted * @return a sorted array */ &lt;T extends Comparable&lt;T&gt;&gt; T[] sort(T[] unsorted); /** * Auxiliary method for algorithms what wanted to work with lists from JCF * @param unsorted - a list should be sorted * @return a sorted list */ @SuppressWarnings("unchecked") default &lt;T extends Comparable&lt;T&gt;&gt; List&lt;T&gt; sort(List&lt;T&gt; unsorted)&#123; return Arrays.asList(sort(unsorted.toArray((T[]) new Comparable[unsorted.size()]))); &#125;&#125; SortUtils.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * The class contains util methods * 数组、打印 的一些帮助类 **/final class SortUtils &#123; /** * Helper method for swapping places in array * @param array The array which elements we want to swap * @param idx index of the first element * @param idy index of the second element */ static &lt;T&gt; boolean swap(T[] array, int idx, int idy)&#123; T swap = array[idx]; array[idx] = array[idy]; array[idy] = swap; return true; &#125; /** * This method checks if first element is less then the other element * @param v first element * @param w second element * @return true if the first element is less then the second element */ static &lt;T extends Comparable&lt;T&gt;&gt; boolean less(T v, T w) &#123; return v.compareTo(w) &lt; 0; &#125; /** * Just print list * @param toPrint - a list which should be printed */ static void print(List&lt;?&gt; toPrint)&#123; toPrint.stream() .map(Object::toString) .map(str -&gt; str + " ") .forEach(System.out::print); System.out.println(); &#125; /** * Prints an array * @param toPrint - the array which should be printed */ static void print(Object[] toPrint)&#123; System.out.println(Arrays.toString(toPrint)); &#125; /** * Swaps all position from &#123;@param left&#125; to @&#123;@param right&#125; for &#123;@param array&#125; * @param array is an array * @param left is a left flip border of the array * @param right is a right flip border of the array */ static &lt;T extends Comparable&lt;T&gt;&gt; void flip(T[] array, int left, int right) &#123; while (left &lt;= right) &#123; swap(array, left++ , right--); &#125; &#125;&#125; 参考维基百科-堆排序 Java排序算法(五)：堆排序 引用 ^Pratt, V. Shellsort and sorting networks (Outstanding dissertations in the computer sciences). Garland. 1979. ISBN 0-824-04406-1. (This was originally presented as the author’s Ph.D. thesis, Stanford University, 1971) ^ A154393 The fibonacci to the power of two times the golden ratio gap sequence 算法目录 排序算法 理论 计算复杂性理论 大O符号 全序关系 列表 稳定性 比较排序 自适应排序 排序网络 整数排序 交换排序 冒泡排序 鸡尾酒排序 奇偶排序 梳排序 侏儒排序 快速排序 臭皮匠排序 Bogo排序 选择排序 选择排序 堆排序 平滑排序 笛卡尔树排序 锦标赛排序 圈排序 插入排序 插入排序 希尔排序 伸展排序 二叉查找树排序 图书馆排序 耐心排序 归并排序 归并排序 梯级归并排序 振荡归并排序 多相归并排序 串列排序 分布排序 美国旗帜排序 珠排序 桶排序 爆炸排序 计数排序 比较计数排序 鸽巢排序 相邻图排序 基数排序 闪电排序 插值排序 并发排序 双调排序器 Batcher归并网络 两两排序网络 混合排序 块排序 Tim排序 内省排序 Spread排序 J排序 其他 拓扑排序 煎饼排序 意粉排序 算法 排序—比较排序 冒泡排序 选择排序 插入排序 希尔排序 快速排序 归并排序 堆排序 鸡尾酒排序 梳排序 侏儒排序 图书馆排序 内省排序 奇偶排序 排序—线性时间排序 鸽巢排序 基数排序 计数排序 桶排序 排序—并行排序 排序网络 Batcher归并网络 排序—不实用的 Bogo排序 臭皮匠排序 排序—图 拓扑排序 搜索—列表 线性搜索 二分搜索 搜索—树・图 广度优先搜索 最良优先搜索 均一开销搜索 A* 深度优先搜索 迭代深化深度优先搜索 深度限制搜索 双方向探索 分枝限定法 搜索—字符串 克努斯-莫里斯-普拉特算法 Boyer-Moore字符串搜索算法 AC自动机算法 Rabin-Karp算法 位图算法 最短路问题 戴克斯特拉算法 贝尔曼-福特算法 Floyd-Warshall算法 最小生成树 普林姆算法 克鲁斯克尔算法 最大流 最小割 Ford–Fulkerson算法 Edmonds–Karp算法 线性规划 单纯形法 Karmarkar算法 顺序统计量 选择算法 中位数的中位数 种类 近似算法 随机化算法 其他 分治法 动态规划 贪心法]]></content>
      <categories>
        <category>android</category>
        <category>algorithom</category>
      </categories>
      <tags>
        <tag>algorithom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View之scroll系列方法]]></title>
    <url>%2F2926030160%2F</url>
    <content type="text"><![CDATA[前言本篇的主要目的有如下几点： 记录一下scroll系列中各个方法（scrollTo，scrollBy，setScrollX，setScrollY，getScrollX，getScrollY）的作用 scroll方法中正负值代表方向的理解与记忆方式 scroll值的正负理解 个人感觉，scroll系列中各个方法的由来是因为布局有大小，但是布局内的内容可以无限大从而大于布局的大小。所以需要scroll系列方法来移动显示区域内的内容。 scroll方法针对的是view中的内容。如view.scrollTo(50,0); 表示的是针对内容的（0，0）坐标view滚动了50个像素到(50,0)。也就是将view的可视区域向右移动到（50，0）处。展现的是，内容向左边移动了50个像素。可以抽象地理解为屏幕与屏幕上的内容。 打个比方： view的内容好比是一张画，而view是画上的一个放大镜。 以画的左上角为原点，原点向右为X轴正方向，原点向下为Y轴正方向，建立坐标系。 放大镜初始位置在(0,0)处。 scrollTo(50,0)就是把放大镜向右移到(50,0)处，让放大镜显示(50,0)处的内容。 这个过程中，如果将放大镜看作是静止的，就是画左移了50个单位长度。 scroll系列方法首先来说一下scroll各方法都是对View中的两个成员变量进行修改，分别是 mScrollX 表示X轴方向（水平方向）的偏移量。正：内容向左移动，相当于手指在屏幕上从右往左拖动内容；负，则相反。 mScrollY 表示Y轴方向（垂直方向）的偏移量。正：内容向上移动，相当于手指在屏幕上从下往上拖动内容；负，则相反。 注：scroll系列各方法产生的内容移动效果都是瞬间完成的。如需实现平滑移动效果，请查看下篇文章 《自定义View之Scroller》 12345678910111213141516171819202122232425262728293031323334353637/** * The offset, in pixels, by which the content of this view is scrolled * horizontally. * &#123;@hide&#125; */@ViewDebug.ExportedProperty(category = "scrolling")protected int mScrollX;/** * The offset, in pixels, by which the content of this view is scrolled * vertically. * &#123;@hide&#125; */@ViewDebug.ExportedProperty(category = "scrolling")protected int mScrollY;/** * Return the scrolled left position of this view. This is the left edge of * the displayed part of your view. You do not need to draw any pixels * farther left, since those are outside of the frame of your view on * screen. * * @return The left edge of the displayed part of your view, in pixels. */public final int getScrollX() &#123; return mScrollX;&#125;/** * Return the scrolled top position of this view. This is the top edge of * the displayed part of your view. You do not need to draw any pixels above * it, since those are outside of the frame of your view on screen. * * @return The top edge of the displayed part of your view, in pixels. */public final int getScrollY() &#123; return mScrollY;&#125; scrollTo(int x, int y)将当前视图内容偏移至(x , y)坐标处，即显示(可视)区域位于(x , y)坐标处。 1234567891011121314151617181920/** * Set the scrolled position of your view. This will cause a call to * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be * invalidated. * @param x the x position to scroll to * @param y the y position to scroll to */public void scrollTo(int x, int y) &#123; if (mScrollX != x || mScrollY != y) &#123; int oldX = mScrollX; int oldY = mScrollY; mScrollX = x; mScrollY = y; invalidateParentCaches();//让该视图的父视图清除对该视图的缓存 onScrollChanged(mScrollX, mScrollY, oldX, oldY);//回调方法 if (!awakenScrollBars()) &#123; postInvalidateOnAnimation();//刷新 &#125; &#125;&#125; scrollBy(int x, int y)可以看到scrollBy内部调用了scrollTo方法，只是在当前mScrollX和mScrollY的基础上去偏移。 12345678910/** * Move the scrolled position of your view. This will cause a call to * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be * invalidated. * @param x the amount of pixels to scroll by horizontally * @param y the amount of pixels to scroll by vertically */public void scrollBy(int x, int y) &#123; scrollTo(mScrollX + x, mScrollY + y);&#125; setScrollX(int value)，setScrollY(int value)setScrollX，setScrollY分别是对X轴方向和Y轴方向进行偏移。 12345678910111213141516171819/** * Set the horizontal scrolled position of your view. This will cause a call to * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be * invalidated. * @param value the x position to scroll to */public void setScrollX(int value) &#123; scrollTo(value, mScrollY);&#125;/** * Set the vertical scrolled position of your view. This will cause a call to * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be * invalidated. * @param value the y position to scroll to */public void setScrollY(int value) &#123; scrollTo(mScrollX, value);&#125; Scroll方法使用示例 布局文件 activity_main.xml 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/layout" android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical" tools:context="com.nhtzj.myapplication.scroller.ScrollerActivity"&gt; &lt;Button android:id="@+id/scroll_by_btn" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="scrollBy" /&gt; &lt;Button android:id="@+id/scroll_to_btn" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="scrollTo" /&gt;&lt;/LinearLayout&gt; MainActivity代码 12345678910111213141516171819202122232425262728public class MainActivity extends AppCompatActivity &#123; private LinearLayout layout; private Button scrollToBtn; private Button scrollByBtn; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); layout = (LinearLayout) findViewById(R.id.layout); scrollToBtn = (Button) findViewById(R.id.scroll_to_btn); scrollByBtn = (Button) findViewById(R.id.scroll_by_btn); scrollToBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; layout.scrollTo(-60, -100);//从当前位置移动到(-60, -100)坐标处。 &#125; &#125;); scrollByBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; layout.scrollBy(-60, -100);//每调用一次，都会在之前的基础上往右下角移动。 &#125; &#125;); &#125;&#125;]]></content>
      <categories>
        <category>android</category>
        <category>view</category>
        <category>自定义</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>view</tag>
        <tag>scroll</tag>
        <tag>scroll系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android音频管理]]></title>
    <url>%2F968779581%2F</url>
    <content type="text"><![CDATA[获取音频焦点我们知道，一款手机可能会有多个应用去播放音频，（手机安装多款音视频播放器这个是很常见的现象、同时打开多个音视频播放器也是很正常的）。 试想如果不有效的处理应用的音频，会出现什么情况？我们在听歌的同时可能还会听到啪啪啪的声音。（注：这里的啪啪啪指观看羽毛球视频）为了防止多个音乐播放应用同时播放音频，谷歌技术团队使用音频焦点（Audio Focus）来控制音频的播放。也就是，当且仅当apk获取到音频焦点成功以后，才可以播放音频！ 通过( AudioManager 类 )这个方法获取音频焦点 public int requestAudioFocus(OnAudioFocusChangeListener l, int streamType, int durationHint) 来获取音频焦点，这个方法有三个参数，下面仔细分析下这三个参数 参数一：OnAudioFocusChangeListener（音频焦点发生改变时候的监听），这个 OnAudioFocusChangeListener 是 AudioManager 的一个内部接口，本质是监听 音频焦点的状态。 比如，是否获取了焦点、焦点是否失去、焦点暂时失去等状态 ，通过源码可以得知，它有四种状态，分别是： 状态一：AudioManager.AUDIOFOCUS_GAIN 状态二：AudioManager.AUDIOFOCUS_LOSS 状态三：AudioManager.AUDIOFOCUS_LOSS_TRANSIENT 状态四：AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK 以上四种状态分别代表的意思如下： 状态一：即应用获取了焦点，获取了焦点即正常播放音频 状态二：即应用彻底失去了焦点，不能播放音频 状态三：即应用暂时失去焦点（比如我们按下 HOME 键、电源键等） 状态四：应用暂时失去焦点，但是这个 DUCK（DUCK翻译：鸭子、闪避、躲避）状态比较特殊，这种状态意味着其它应用可以继续播放，仅仅是在这一刻降低自己应用的音量，直到重新获取到音频焦点后恢复正常音量。应用场景有，比如在播放音乐的时候突然出现一个短暂的短信提示声音，仅仅是把歌曲的音量暂时调低，使得用户能够听到短信提示声，在此之后便立马恢复正常播放；再比如语言导航等等 注意：一旦结束了播放，需要确保调用 abandonAudioFocus()方法。也就是告知系统我们不再需要获取焦点且注销 AudioManager.OnAudioFocusChangeListener 监听器。 参数二：streamType（流类型）这个上面也说了，一般设置为 STREAM_MUSIC 参数三：durationHint （持续时间） 根据源码得知有以下几种固定写法： AUDIOFOCUS_GAIN_TRANSIENT 焦点请求是临时 AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK 如果它的音频输出被暂停，那么之前成功获取焦点的就可以继续播放 AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE 临时的（语音备忘记录或语音识别） AUDIOFOCUS_GAIN 也就是焦点请求（这个用的较多） 另外源码可以得知，这个获取音频焦点的返回值只有两种： 一种是：AUDIOFOCUS_REQUEST_FAILED = 0 一种是：AUDIOFOCUS_REQUEST_GRANTED = 1，其中，AUDIOFOCUS_REQUEST_GRANTED 代表的就是获取音频焦点成功]]></content>
      <categories>
        <category>android</category>
        <category>音频</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>音频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android获得控件在屏幕中的坐标]]></title>
    <url>%2F2821410600%2F</url>
    <content type="text"><![CDATA[View.getLocationInWindow()、View.getLocationOnScreen()1234//location [0]---&gt;x坐标,location [1]---&gt;y坐标int[] location = new int[2] ;view.getLocationInWindow(location); //获取在当前窗口内的绝对坐标view.getLocationOnScreen(location);//获取在整个屏幕内的绝对坐标 View.getLocationInWindow(@Size(2) int[] outLocation)getLocationInWindow是以B为原点的C的坐标计算该视图在它所在的widnow的坐标x，y值，获取在整个窗口内的绝对坐标 View.getLocationOnScreen(@Size(2) int[] outLocation)getLocationOnScreen是以A为原点的C的坐标 计算该视图在全局坐标系中的x，y值，（注意这个值是要从屏幕顶端算起，也就是索包括了通知栏的高度）//获取在当前屏幕内的绝对坐标 以上2种方法得到绝对位置的方法只在有弹出窗时会有区别。 View.getLeft() , View.getTop(), View.getBottom(),View.getRight()获取相对父容器的坐标 MotionEvent.getX(),MotionEvent.getRawX() MotionEvent.getX():相对于自身左上角的x坐标 MotionEvent.getRawX():相对于屏幕左上角的x坐标值]]></content>
      <categories>
        <category>android</category>
        <category>view</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>view</tag>
        <tag>位置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义条目数量的底部弹框]]></title>
    <url>%2F657237467%2F</url>
    <content type="text"><![CDATA[前言什么都不说了，先上效果图 知识点该功能的实现主要依赖于以下两点 载体：DialogFragment（android.support.v4.app） Item：代码动态添加 以前写提示框大多是用Dialog，又或者是用PopupWindow。现在换个花样，用DialogFragment来实现。 这里用的是v4包内的DialogFragment，可以支持Android3.0之前的版本，而且android.app.DialogFragment 在API28被弃用了。 DialogFragment extends Fragment，其父类是Fragment,所以显示此布局的Activity必须是FragmentActivity的子类。 完整代码JavaBottomPopUpDialog.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236public class BottomPopUpDialog extends DialogFragment &#123; private TextView mCancel; private LinearLayout mContentLayout; private Builder mBuilder; private static BottomPopUpDialog getInstance(Builder builder) &#123; BottomPopUpDialog dialog = new BottomPopUpDialog(); dialog.mBuilder = builder; return dialog; &#125; @Override public void onViewCreated(View view, @Nullable Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); if (getDialog().getWindow() != null) &#123; getDialog().getWindow().setBackgroundDrawableResource(mBuilder.mBackgroundShadowColor); &#125; &#125; @Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setStyle(DialogFragment.STYLE_NORMAL, android.R.style.Theme_Holo_Light_NoActionBar); &#125; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; @SuppressLint("InflateParams") View view = inflater.inflate(R.layout.bottom_popup_dialog, null); initView(view); registerListener(view); setCancelable(true); return view; &#125; private void initView(View view) &#123; mContentLayout = view.findViewById(R.id.pop_dialog_content_layout); mCancel = view.findViewById(R.id.cancel); initItemView(); &#125; private void registerListener(View view) &#123; view.setOnTouchListener(new View.OnTouchListener() &#123; @SuppressLint("ClickableViewAccessibility") @Override public boolean onTouch(View v, MotionEvent event) &#123; if (event.getAction() == MotionEvent.ACTION_DOWN) &#123; dismiss(); &#125; return false; &#125; &#125;); mCancel.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mBuilder.mListener.onCancleClick(); dismiss(); &#125; &#125;); &#125; @Override public void show(FragmentManager manager, String tag) &#123; try &#123; super.show(manager, tag); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; private void initItemView() &#123; //循环添加item for (int i = 0; i &lt; mBuilder.mDataArray.length; i++) &#123; final PopupDialogItem dialogItem = new PopupDialogItem(getContext()); dialogItem.refreshData(mBuilder.mDataArray[i]); //最后一项隐藏分割线 if (i == mBuilder.mDataArray.length - 1) &#123; dialogItem.hideLine(); &#125; //设置字体颜色 if (mBuilder.mColorArray.size() != 0 &amp;&amp; mBuilder.mColorArray.get(i) != 0) &#123; dialogItem.setTextColor(mBuilder.mColorArray.get(i)); &#125; //设置分割线颜色 if (mBuilder.mLineColor != 0) &#123; dialogItem.setLineColor(mBuilder.mLineColor); &#125; //设置首项的字体大小，这里我写死为12sp if (i == 0) &#123; dialogItem.setTextSize(12f); &#125; mContentLayout.addView(dialogItem); //设置首项是否添加点击回调 if (i == 0 &amp;&amp; !mBuilder.firstItemClickable) &#123; continue; &#125; //设置点击回调 dialogItem.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mBuilder.mListener.onDialogClick(dialogItem.getItemContent()); if (mBuilder.mIsCallBackDismiss) &#123; dismiss(); &#125; &#125; &#125;); &#125; &#125; public static class Builder &#123; private String[] mDataArray; private SparseIntArray mColorArray = new SparseIntArray(); private BottomPopDialogOnClickListener mListener; private int mLineColor; private boolean mIsCallBackDismiss = false; private boolean firstItemClickable = false; private int mBackgroundShadowColor = R.color.transparent_70; /** * 设置item数据 */ public Builder setDialogData(String[] dataArray) &#123; mDataArray = dataArray; return this; &#125; /** * 设置监听item监听器 */ public Builder setItemOnListener(BottomPopDialogOnClickListener listener) &#123; mListener = listener; return this; &#125; /** * 设置字体颜色 * * @param index item的索引 * @param color res color */ public Builder setItemTextColor(int index, int color) &#123; mColorArray.put(index, color); return this; &#125; /** * 设置item分隔线颜色 */ public Builder setItemLineColor(int color) &#123; mLineColor = color; return this; &#125; /** * 设置是否点击回调取消dialog */ public Builder setCallBackDismiss(boolean dismiss) &#123; mIsCallBackDismiss = dismiss; return this; &#125; /** * 设置首项是否可点击 * @param firstItemClickable */ public void setFirstItemClickable(boolean firstItemClickable) &#123; this.firstItemClickable = firstItemClickable; &#125; /** * 设置dialog背景阴影颜色 */ public Builder setBackgroundShadowColor(int color) &#123; mBackgroundShadowColor = color; return this; &#125; public BottomPopUpDialog create() &#123; return BottomPopUpDialog.getInstance(this); &#125; public BottomPopUpDialog show(FragmentManager manager, String tag) &#123; BottomPopUpDialog dialog = create(); dialog.show(manager, tag); return dialog; &#125; &#125; public interface BottomPopDialogOnClickListener &#123; /** * item点击事件回调 * * @param tag item字符串 用于识别item */ void onDialogClick(String tag); /** * 点击取消 */ void onCancleClick(); &#125;&#125; BottomPopUpDialog.java 主要是一个 Builder内部类，用于获取配置参数； initItemView()方法，将 Builder内的mDataArray转换成PopupDialogItem显示。 setStyle()，设置显示样式。两个参数setStyle(@DialogStyle int style, @StyleRes int theme)。style：DialogFragment提供了4种，STYLE_NORMAL, STYLE_NO_TITLE, STYLE_NO_FRAME, STYLE_NO_INPUT。 theme：自定义样式，指定该dialog样式。当该值为0时，通过style确定具体样式。 12345678910111213141516171819202122232425262728293031323334353637383940/** * Style for &#123;@link #setStyle(int, int)&#125;: a basic, * normal dialog. * 普通的dialog样式 */public static final int STYLE_NORMAL = 0;/** * Style for &#123;@link #setStyle(int, int)&#125;: don't include * a title area. * 没有标题 */public static final int STYLE_NO_TITLE = 1;/** * Style for &#123;@link #setStyle(int, int)&#125;: don't draw * any frame at all; the view hierarchy returned by &#123;@link #onCreateView&#125; * is entirely responsible for drawing the dialog. * 直接将onCreateView()中返回的View显示 */public static final int STYLE_NO_FRAME = 2;/** * Style for &#123;@link #setStyle(int, int)&#125;: like * &#123;@link #STYLE_NO_FRAME&#125;, but also disables all input to the dialog. * The user can not touch it, and its window will not receive input focus. * 在STYLE_NO_FRAME的基础上，禁用输入 */public static final int STYLE_NO_INPUT = 3;public void setStyle(@DialogStyle int style, @StyleRes int theme) &#123; mStyle = style; if (mStyle == STYLE_NO_FRAME || mStyle == STYLE_NO_INPUT) &#123; mTheme = android.R.style.Theme_Panel; &#125; if (theme != 0) &#123; mTheme = theme; &#125;&#125; PopupDialogItem.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class PopupDialogItem extends LinearLayout &#123; private Context mContext; private TextView mContentView; private View mLineView; private String mContent; public PopupDialogItem(Context context) &#123; super(context); mContext = context; initView(); &#125; public PopupDialogItem(Context context, AttributeSet attrs) &#123; super(context, attrs); mContext = context; initView(); &#125; private void initView() &#123; LayoutInflater inflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE); assert inflater != null; View view = inflater.inflate(R.layout.item_bottom_popup_dialog, this); mContentView = view.findViewById(R.id.popup_dialog_item); mLineView = view.findViewById(R.id.popup_dialog_line); &#125; public void refreshData(String text) &#123; mContentView.setText(text); mContent = text; &#125; public void setLineColor(int color) &#123; mLineView.setBackgroundResource(color); &#125; public void hideLine() &#123; mLineView.setVisibility(GONE); &#125; public String getItemContent() &#123; return mContent; &#125; public void setTextColor(int textColor) &#123; mContentView.setTextColor(ContextCompat.getColor(mContext, textColor)); &#125; public void setTextSize(float size) &#123; mContentView.setTextSize(SP, size); &#125;&#125; MaxHeightScrollView.java1234567891011121314151617181920212223242526272829303132public class MaxHeightScrollView extends ScrollView &#123; public MaxHeightScrollView(Context context) &#123; super(context); &#125; public MaxHeightScrollView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; Context context = getContext(); if (null != context) &#123; int screenHeight = getScreenHeight(context); heightMeasureSpec = MeasureSpec.makeMeasureSpec(screenHeight * 2 / 3, MeasureSpec.AT_MOST); &#125; super.onMeasure(widthMeasureSpec, heightMeasureSpec); &#125; /** * 获取屏幕高度 */ private int getScreenHeight(Context context) &#123; DisplayMetrics metrics = context.getResources().getDisplayMetrics(); return metrics.heightPixels; &#125;&#125; 重写onMeasure方法，将高度设置为屏幕高度的 2 / 3。 resbottom_popup_dialog.xml（弹框布局）123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="@color/transparent" android:gravity="bottom"&gt; &lt;com.nhtzj.learn.widget.bottomsheet.MaxHeightScrollView android:id="@+id/sl_root" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginLeft="10dp" android:layout_marginRight="10dp" android:background="@drawable/bg_dialog" android:padding="2dp"&gt; &lt;LinearLayout android:id="@+id/pop_dialog_content_layout" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="@drawable/bg_dialog" android:orientation="vertical"&gt; &lt;/LinearLayout&gt; &lt;/com.nhtzj.learn.widget.bottomsheet.MaxHeightScrollView&gt; &lt;TextView android:id="@+id/cancel" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_below="@+id/sl_root" android:layout_marginBottom="17dp" android:layout_marginLeft="10dp" android:layout_marginRight="10dp" android:layout_marginTop="14dp" android:background="@drawable/bg_dialog" android:gravity="center" android:minHeight="55dp" android:padding="10dp" android:text="@string/cancel" android:textColor="@color/text_green" android:textSize="18sp" /&gt;&lt;/RelativeLayout&gt; ####item_bottom_popup_dialog.xml（item布局） 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/popup_dialog_item" android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center" android:minHeight="56dp" android:textColor="@color/text_green" android:textSize="18sp"/&gt; &lt;View android:id="@+id/popup_dialog_line" android:layout_width="match_parent" android:layout_height="0.5dp" android:layout_marginLeft="10dp" android:layout_marginRight="10dp" android:background="@color/line_color" /&gt;&lt;/LinearLayout&gt; bg_dialog.xml （背景）1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle"&gt; &lt;corners android:radius="8dp" /&gt; &lt;solid android:color="@android:color/white" /&gt;&lt;/shape&gt; colors.xml123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;color name="text_green"&gt;#1FC88B&lt;/color&gt; &lt;color name="text_black"&gt;#333333&lt;/color&gt; &lt;color name="text_gray"&gt;#999999&lt;/color&gt; &lt;color name="line_color"&gt;#EDEDED&lt;/color&gt; &lt;color name="transparent_70"&gt;#70000000&lt;/color&gt;&lt;/resources&gt; arrays.xml12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;string-array name="array_transfer_manager"&gt; &lt;item&gt;&lt;/item&gt; &lt;item&gt;设为管理员&lt;/item&gt; &lt;item&gt;删除&lt;/item&gt; &lt;/string-array&gt;&lt;/resources&gt; 使用12345678910111213141516new BottomPopUpDialog.Builder() .setDialogData(getResources().getStringArray(R.array.array_transfer_manager)) .setCallBackDismiss(true) .setItemTextColor(0, R.color.text_gray) .setItemOnListener(new BottomPopUpDialog.BottomPopDialogOnClickListener() &#123; @Override public void onDialogClick(String tag) &#123; //TODO 按钮点击的回调，通过tag（按钮文本）区分 &#125; @Override public void onCancleClick() &#123; //TODO 取消按钮点击的回调 &#125; &#125;) .show(getSupportFragmentManager(), BottomPopUpDialog.class.getSimpleName()); 参考 https://blog.csdn.net/lmj623565791/article/details/37815413]]></content>
      <categories>
        <category>android</category>
        <category>Fragment</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View之带删除按钮的编辑框]]></title>
    <url>%2F377683656%2F</url>
    <content type="text"><![CDATA[前言什么都不说了，先上效果图 代码主要是使用了getCompoundDrawables()方法设置删除图片,返回数据是一个数组，分别对应如下位置的4张图片：左、上、右、下。 xml中对应的设置是 左：android:drawableLeft 上：android:drawableTop 右：android:drawableRight 下：android:drawableBottom 我这边将删除图片放在了右边，所以使用getCompoundDrawables()[2]。 配合setOnFocusChangeListener()、addTextChangedListener()、onTouchEvent()实现删除图标的显示与隐藏。 完整代码如下，代码中写了详细的注释，这里就不再啰嗦了。 使用的图片下载： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131/** * &lt;pre&gt; * author : Haitao * blog : http://www.nhtzj.com * time : 2017/6/22 * desc : 带删除按钮的编辑框 * version: 1.0 * &lt;/pre&gt; */public class ClearEditText extends AppCompatEditText implements View.OnFocusChangeListener, TextWatcher &#123; //EditText右侧的删除按钮 private Drawable mClearDrawable; private boolean hasFoucs; public ClearEditText(Context context) &#123; this(context, null); &#125; public ClearEditText(Context context, AttributeSet attrs) &#123; this(context, attrs, android.R.attr.editTextStyle); &#125; public ClearEditText(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init() &#123; // 获取EditText的DrawableRight,假如没有设置我们就使用默认的图片,获取图片的顺序是左上右下（0,1,2,3,） mClearDrawable = getCompoundDrawables()[2]; if (mClearDrawable == null) &#123; mClearDrawable = getResources().getDrawable( R.drawable.edit_delete); &#125;// mClearDrawable.setBounds(0, 0, DeviceUtils.dp2px(getContext(), 20), DeviceUtils.dp2px(getContext(), 20)); mClearDrawable.setBounds(0, 0, mClearDrawable.getIntrinsicWidth(), mClearDrawable.getIntrinsicHeight()); // 默认设置隐藏图标 setClearIconVisible(false); // 设置焦点改变的监听 setOnFocusChangeListener(this); // 设置输入框里面内容发生改变的监听 addTextChangedListener(this); &#125; /* *给删除图标设置点击处理 * *@说明：isInnerWidth, isInnerHeight为ture，触摸点在删除图标之内，则视为点击了删除图标 * event.getX() 获取相对应自身左上角的X坐标 * event.getY() 获取相对应自身左上角的Y坐标 * getWidth() 获取控件的宽度 * getHeight() 获取控件的高度 * getTotalPaddingRight() 获取删除图标左边缘到控件右边缘的距离 * getPaddingRight() 获取删除图标右边缘到控件右边缘的距离 * * isInnerWidth:点击处x坐标是否在删除图标上 * getWidth() - getTotalPaddingRight() 计算删除图标左边缘到控件左边缘的距离 * getWidth() - getPaddingRight() 计算删除图标右边缘到控件左边缘的距离 * * isInnerHeight:点击处y坐标是否在删除图标上 * distance 删除图标顶部边缘到控件顶部边缘的距离 * distance + height 删除图标底部边缘到控件顶部边缘的距离 */ @Override public boolean onTouchEvent(MotionEvent event) &#123; if (event.getAction() == MotionEvent.ACTION_UP) &#123; if (getCompoundDrawables()[2] != null) &#123; int x = (int) event.getX(); int y = (int) event.getY(); Rect rect = getCompoundDrawables()[2].getBounds(); int height = rect.height(); int distance = (getHeight() - height) / 2; boolean isInnerWidth = x &gt; (getWidth() - getTotalPaddingRight()) &amp;&amp; x &lt; (getWidth() - getPaddingRight()); boolean isInnerHeight = y &gt; distance &amp;&amp; y &lt; (distance + height); if (isInnerWidth &amp;&amp; isInnerHeight) &#123; this.setText(""); &#125; &#125; &#125; return super.onTouchEvent(event); &#125; /** * 当ClearEditText焦点发生变化的时候， * 输入长度为零，隐藏删除图标，否则，显示删除图标 */ @Override public void onFocusChange(View v, boolean hasFocus) &#123; this.hasFoucs = hasFocus; if (hasFocus) &#123; setClearIconVisible(getText().length() &gt; 0); &#125; else &#123; setClearIconVisible(false); &#125; &#125; public void setHasFoucs(boolean hasFoucs) &#123; this.hasFoucs = hasFoucs; &#125; protected void setClearIconVisible(boolean visible) &#123; Drawable right = visible ? mClearDrawable : null; setCompoundDrawables(getCompoundDrawables()[0], getCompoundDrawables()[1], right, getCompoundDrawables()[3]); &#125; public void setClearIconVisibleP(boolean visible) &#123; setClearIconVisible(visible); &#125; @Override public void onTextChanged(CharSequence s, int start, int count, int after) &#123; if (hasFoucs) &#123; setClearIconVisible(s.length() &gt; 0); &#125; &#125; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void afterTextChanged(Editable s) &#123; &#125;&#125;]]></content>
      <categories>
        <category>android</category>
        <category>view</category>
        <category>自定义</category>
        <category>继承控件</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>自定义view</tag>
        <tag>继承控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[走进股神境界之股票键盘设计与实现]]></title>
    <url>%2F2918164173%2F</url>
    <content type="text"><![CDATA[前言之前一段时间，公司开始研发一款炒股软件。 如今，项目已经上线有段时间了。现在就将其中的一个功能—“股票键盘”拿出来给大家献献丑。 不说了，先上效果图： 技术点说到股票软件，股票界的泰山北斗自然是“同花顺”了。小编设计研发的股票键盘也是向“同花顺”靠齐了。 该股票键盘的技术点主要有如下几点： 屏蔽系统键盘 自定义键盘 键盘显示方式 系统底部功能按钮适配 只要理清楚了这几点，那对功能的实现是起到事半功倍的效果。 接下来就从代码实现来给大家讲解一下。 股票键盘的实现股票键盘的功能实现最主要的按钮是使用了系统提供的控件：KeyboardView和Keyboard。 KeyboardView：keyboard的容器，KeyboardView.setKeyboard()切换显示的键盘 Keyboard：键盘的具体显示 设计键盘布局键盘的布局通过xml文件方式定义。 由Keyboard、Row、Key组成。 Keyboard：Keyboard控件的根布局，用以控制按钮行、列间距，按钮Key的宽高。 属性 介绍 android:horizontalGap Default horizontal gap between keys. android:keyHeight Default height of a key, in pixels or percentage of display width. android:keyWidth Default width of a key, in pixels or percentage of display width. android:verticalGap Default vertical gap between rows of keys. Row：行，Key的容器 属性 介绍 android:horizontalGap Default horizontal gap between keys. android:keyHeight Default height of a key, in pixels or percentage of display width. android:keyWidth Default width of a key, in pixels or percentage of display width. android:keyboardMode Mode of the keyboard. android:rowEdgeFlags Row edge flags. android:verticalGap Default vertical gap between rows of keys. Key：按钮，设置按钮的属性，最常用的有 codes：OnKeyboardActionListener.onKey()中第一个参数为该值，用以区分按钮 keyLabel：按钮显示的内容 isRepeatable：按钮长按是否可重复发起回调 keyIcon：按钮显示的图标 keyEdgeFlags：按钮边的标志，left或right 属性 介绍 android:codes The unicode value or comma-separated values that this key outputs. android:horizontalGap Default horizontal gap between keys. android:iconPreview The icon to show in the popup preview. android:isModifier Whether this is a modifier key such as Alt or Shift. android:isRepeatable Whether long-pressing on this key will make it repeat. android:isSticky Whether this is a toggle key. android:keyEdgeFlags Key edge flags. android:keyHeight Default height of a key, in pixels or percentage of display width. android:keyIcon The icon to display on the key instead of the label. android:keyLabel The label to display on the key. android:keyOutputText The string of characters to output when this key is pressed. android:keyWidth Default width of a key, in pixels or percentage of display width. android:popupCharacters The characters to display in the popup keyboard. android:popupKeyboard The XML keyboard layout of any popup keyboard. 数字键盘keyboard_stock_num.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;Keyboard xmlns:android="http://schemas.android.com/apk/res/android" android:horizontalGap="1dp" android:keyHeight="@dimen/key_height" android:keyWidth="26.67%p" android:verticalGap="1dp"&gt; &lt;Row&gt; &lt;Key android:codes="8600" android:keyEdgeFlags="left" android:keyLabel="600" android:keyWidth="20%p" /&gt; &lt;Key android:codes="49" android:keyLabel="1" /&gt; &lt;Key android:codes="50" android:keyLabel="2" /&gt; &lt;Key android:codes="51" android:keyLabel="3" /&gt; &lt;/Row&gt; &lt;Row&gt; &lt;Key android:codes="8300" android:keyEdgeFlags="left" android:keyLabel="300" android:keyWidth="20%p" /&gt; &lt;Key android:codes="52" android:keyLabel="4" /&gt; &lt;Key android:codes="53" android:keyLabel="5" /&gt; &lt;Key android:codes="54" android:keyLabel="6" /&gt; &lt;/Row&gt; &lt;Row&gt; &lt;Key android:codes="8000" android:keyEdgeFlags="left" android:keyLabel="00" android:keyWidth="20%p" /&gt; &lt;Key android:codes="55" android:keyLabel="7" /&gt; &lt;Key android:codes="56" android:keyLabel="8" /&gt; &lt;Key android:codes="57" android:keyLabel="9" /&gt; &lt;/Row&gt; &lt;Row&gt; &lt;Key android:codes="8065" android:keyEdgeFlags="left" android:keyLabel="ABC" android:keyWidth="20%p" /&gt; &lt;Key android:codes="48" android:keyLabel="0" /&gt; &lt;Key android:codes="-5" android:isRepeatable="true" android:keyIcon="@drawable/icon_keyboard_del" /&gt; &lt;Key android:codes="8079" android:isRepeatable="true" android:keyEdgeFlags="right" android:keyLabel="确定" /&gt; &lt;/Row&gt;&lt;/Keyboard&gt; 字母键盘keyboard_stock_letter.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- 全键盘带数字小键盘 --&gt;&lt;Keyboard xmlns:android="http://schemas.android.com/apk/res/android" android:horizontalGap="0.3%p" android:keyHeight="@dimen/key_height" android:keyWidth="9.7%p" android:verticalGap="0.12%p"&gt; &lt;Row&gt; &lt;Key android:codes="81" android:keyEdgeFlags="left" android:keyLabel="Q" /&gt; &lt;Key android:codes="87" android:keyLabel="W" /&gt; &lt;Key android:codes="69" android:keyLabel="E" /&gt; &lt;Key android:codes="82" android:keyLabel="R" /&gt; &lt;Key android:codes="84" android:keyLabel="T" /&gt; &lt;Key android:codes="89" android:keyLabel="Y" /&gt; &lt;Key android:codes="85" android:keyLabel="U" /&gt; &lt;Key android:codes="73" android:keyLabel="I" /&gt; &lt;Key android:codes="79" android:keyLabel="O" /&gt; &lt;Key android:codes="80" android:keyEdgeFlags="right" android:keyLabel="P" /&gt; &lt;/Row&gt; &lt;Row&gt; &lt;Key android:codes="0" android:keyEdgeFlags="left" android:keyLabel="" android:keyWidth="5%p" /&gt; &lt;Key android:codes="65" android:keyLabel="A" /&gt; &lt;Key android:codes="83" android:keyLabel="S" /&gt; &lt;Key android:codes="68" android:keyLabel="D" /&gt; &lt;Key android:codes="70" android:keyLabel="F" /&gt; &lt;Key android:codes="71" android:keyLabel="G" /&gt; &lt;Key android:codes="72" android:keyLabel="H" /&gt; &lt;Key android:codes="74" android:keyLabel="J" /&gt; &lt;Key android:codes="75" android:keyLabel="K" /&gt; &lt;Key android:codes="76" android:keyLabel="L" /&gt; &lt;Key android:codes="0" android:keyEdgeFlags="right" android:keyLabel="" android:keyWidth="5%p" /&gt; &lt;/Row&gt; &lt;Row&gt; &lt;Key android:codes="-1" android:isModifier="true" android:isSticky="true" android:keyEdgeFlags="left" android:keyIcon="@drawable/icon_keyboard_shift" android:keyWidth="15%p" /&gt; &lt;Key android:codes="90" android:keyLabel="Z" /&gt; &lt;Key android:codes="88" android:keyLabel="X" /&gt; &lt;Key android:codes="67" android:keyLabel="C" /&gt; &lt;Key android:codes="86" android:keyLabel="V" /&gt; &lt;Key android:codes="66" android:keyLabel="B" /&gt; &lt;Key android:codes="78" android:keyLabel="N" /&gt; &lt;Key android:codes="77" android:keyLabel="M" /&gt; &lt;Key android:codes="-5" android:isRepeatable="true" android:keyEdgeFlags="right" android:keyIcon="@drawable/icon_keyboard_del" android:keyWidth="15%p" /&gt; &lt;/Row&gt; &lt;Row android:rowEdgeFlags="bottom"&gt; &lt;Key android:codes="8049" android:keyEdgeFlags="left" android:keyLabel="123" android:keyWidth="25%p" /&gt; &lt;Key android:codes="32" android:keyLabel="" android:keyWidth="50%p" /&gt; &lt;Key android:codes="8079" android:keyEdgeFlags="right" android:keyLabel="确定" android:keyWidth="25%p" /&gt; &lt;/Row&gt;&lt;/Keyboard&gt; 隐藏系统键盘12345678910111213141516171819202122232425262728/** * 隐藏系统键盘 * * @param editText */ public static void hideSystemSofeKeyboard(EditText editText) &#123; //Android L之后可直接设置 if (BuildUtils.isBiggerL()) &#123; editText.setShowSoftInputOnFocus(false); &#125; else if (BuildUtils.isBiggerH()) &#123;//通过反射设置 try &#123; Class&lt;EditText&gt; cls = EditText.class; Method setShowSoftInputOnFocus; setShowSoftInputOnFocus = cls.getMethod("setShowSoftInputOnFocus", boolean.class); setShowSoftInputOnFocus.setAccessible(true); setShowSoftInputOnFocus.invoke(editText, false); &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; else &#123; editText.setInputType(InputType.TYPE_NULL); &#125; &#125; Android H（11）之前设置EditText.setInputType(InputType.TYPE_NULL);屏蔽系统键盘 Android H（11）～Android L（21）通过反射设置setShowSoftInputOnFocus为false Android L（21）以及之后 直接设置EditText.setShowSoftInputOnFocus(true) 初始化1234567891011121314public StockKeyboardUtil(Activity mActivity) &#123; this.mActivity = mActivity; //初始化数字、字母键盘 this.keyboardMum = new Keyboard(mActivity, R.xml.keyboard_stock_num); this.keyboardLetter = new Keyboard(mActivity, R.xml.keyboard_stock_letter); wordClolrGray = mActivity.getResources().getColor(R.color.def_word_gray); wordClolrRed = mActivity.getResources().getColor(R.color.red_title); curKeyboardType = KEYBOARD_NUM; //判断并获取系统底部虚拟功能按钮高度，避免本键盘覆盖系统底部虚拟功能按钮 hasNav = NavigationBarUtils.checkDeviceHasNavigationBar(mActivity); if (hasNav) &#123; navHight = NavigationBarUtils.getNavigationBarHeight(mActivity); &#125;&#125; NavigationBarUtils 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * &lt;pre&gt; * author : Haitao * blog : http://www.blog.com * time : 2017/12/4 * desc : NavigationBar,系统底部虚拟按钮工具类 * version: 2.0 * &lt;/pre&gt; */public class NavigationBarUtils &#123; /** * 判断是否有NavigationBar,系统底部虚拟按钮 * @param context * @return */ public static boolean checkDeviceHasNavigationBar(Context context) &#123; boolean hasNavigationBar = false; Resources rs = context.getResources(); int id = rs.getIdentifier("config_showNavigationBar", "bool", "android"); if (id &gt; 0) &#123; hasNavigationBar = rs.getBoolean(id); &#125; try &#123; Class systemPropertiesClass = Class.forName("android.os.SystemProperties"); Method m = systemPropertiesClass.getMethod("get", String.class); String navBarOverride = (String) m.invoke(systemPropertiesClass, "qemu.hw.mainkeys"); if ("1".equals(navBarOverride)) &#123; hasNavigationBar = false; &#125; else if ("0".equals(navBarOverride)) &#123; hasNavigationBar = true; &#125; &#125; catch (Exception e) &#123; &#125; return hasNavigationBar; &#125; /** * 获取NavigationBar的高度 * @param context * @return */ public static int getNavigationBarHeight(Context context) &#123; int navigationBarHeight = 0; Resources rs = context.getResources(); int id = rs.getIdentifier("navigation_bar_height", "dimen", "android"); if (id &gt; 0 &amp;&amp; checkDeviceHasNavigationBar(context)) &#123; navigationBarHeight = rs.getDimensionPixelSize(id); &#125; return navigationBarHeight; &#125;&#125; 初始化 两个Keyboard:keyboardMum、keyboardLetter； 色值：灰、红； 系统底部虚拟按钮：hasNav-是否有，navHight-高度 NavigationBarUtils为NavigationBar的工具类，用以判断是否有NavigationBar（系统底部虚拟按钮），获取NavigationBar的高度。 绑定EditText123456789101112131415161718192021222324252627282930313233343536/** * 绑定EditText * * @param editText * @param isAuto 当前是否显示股票键盘 */public void attachTo(EditText editText, boolean isAuto) &#123; this.editText = editText; //隐藏系统键盘 hideSystemSofeKeyboard(this.editText); setAutoShowOnFocs(isAuto);&#125;/** * editText 是否设置焦点改变（OnFocusChangeListener）后隐藏/显示 本股票键盘 * * @param enable */public void setAutoShowOnFocs(boolean enable) &#123; if (editText == null) return; if (enable) editText.setOnFocusChangeListener(onFocusChangeListener1); else editText.setOnFocusChangeListener(null);&#125;//焦点改变回调，用以监听本股票键盘绑定的EditText的焦点，以控制该键盘的隐藏/显示View.OnFocusChangeListener onFocusChangeListener1 = new View.OnFocusChangeListener() &#123; @Override public void onFocusChange(View v, boolean hasFocus) &#123; if (hasFocus) showSoftKeyboard(); else hideSoftKeyboard(); &#125;&#125;; 初始化 完成后调用attachTo(),绑定传入的EditText。内部hideSystemSofeKeyboard()隐藏系统键盘，setAutoShowOnFocs()设置焦点改变监听，用以控制本股票键盘的隐藏/显示。股票键盘的隐藏/显示见下章节。 股票键盘显示/隐藏123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * 显示股票键盘 */public void showSoftKeyboard() &#123; //处理系统键盘问题 if (curKeyboardType == KEYBOARD_CH) &#123; curKeyboardType = KEYBOARD_NUM; &#125; isShown = true; //根据viewContainer，避免重复初始化 if (viewContainer == null) &#123; viewContainer = mActivity.getLayoutInflater().inflate(R.layout.view_keyboardview, null); tvNum = (TextView) viewContainer.findViewById(R.id.tv_num); tvLetter = (TextView) viewContainer.findViewById(R.id.tv_letter); tvCh = (TextView) viewContainer.findViewById(R.id.tv_chinese); tvSlash = (TextView) viewContainer.findViewById(R.id.tv_slash); flHide = (FrameLayout) viewContainer.findViewById(R.id.fl_hide); vHolder = viewContainer.findViewById(R.id.v_holder); //keyboardView是keyboard的容器，KeyboardView.setKeyboard()切换键盘 keyboardView = (KeyboardView) viewContainer.findViewById(R.id.keyboard_view); keyboardView.setEnabled(true); keyboardView.setPreviewEnabled(false); //设置键盘按钮回调 keyboardView.setOnKeyboardActionListener(new OnKeyboardActionListener() &#123; @Override public void swipeUp() &#123; &#125; @Override public void swipeRight() &#123; &#125; @Override public void swipeLeft() &#123; &#125; @Override public void swipeDown() &#123; &#125; @Override public void onText(CharSequence text) &#123; &#125; @Override public void onRelease(int primaryCode) &#123; &#125; @Override public void onPress(int primaryCode) &#123; &#125; @Override public void onKey(int primaryCode, int[] keyCodes) &#123; if (editText != null) &#123; //处理点击的按钮， // primaryCode即：键盘布局文件中Key中的android:codes值， // 该值为ASCII表中的十进制列， // 比如：48-&gt;0,97-&gt;a, // 这样表示方便将int型转换成字符 keyCode_delect(primaryCode, editText); &#125; keyboardView.postInvalidate(); &#125; &#125;); &#125; else &#123; if (viewContainer.getParent() != null) return; &#125; tvNum.setOnClickListener(this); tvLetter.setOnClickListener(this); tvCh.setOnClickListener(this); tvSlash.setOnClickListener(this); flHide.setOnClickListener(this); vHolder.setOnClickListener(this); changeKeyboard(curKeyboardType); //直接操作Activity的DecorView，将本股票布局填上去 FrameLayout frameLayout = (FrameLayout) mActivity.getWindow().getDecorView(); FrameLayout.LayoutParams lp = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.WRAP_CONTENT); lp.gravity = Gravity.BOTTOM; if (hasNav) &#123; lp.setMargins(0, 0, 0, navHight); &#125; frameLayout.addView(viewContainer, lp); viewContainer.setAnimation(AnimationUtils.loadAnimation(mActivity, R.anim.down_to_up));&#125; down_to_up.xml 123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;translate android:duration="600" android:fromYDelta="100%p" /&gt;&lt;/set&gt; 如果是首次显示，则初始化各种按钮和keyboardView，并给keyboardView注册监听，用以获取股票键盘的按钮回调。 frameLayout为当前Activity的DecorView，直接将本股票布局填到该frameLayout上进行显示。并添加了一个从底部向上移动的View动画。 按钮数据处理123456789101112131415161718192021222324252627282930313233343536373839404142/** * 处理按钮， * 删除、数字字母切换、确定 * * @param primaryCode * @param edText */ private void keyCode_delect(int primaryCode, EditText edText) &#123; Editable editable = edText.getText(); int start = edText.getSelectionStart(); if (primaryCode == Keyboard.KEYCODE_DELETE) &#123;// 回退 if (edText.hasFocus()) &#123; if (!TextUtils.isEmpty(editable)) &#123; if (start &gt; 0) &#123; editable.delete(start - 1, start); &#125; &#125; &#125; &#125; else if (primaryCode == 8600) &#123;// 600 editable.insert(start, "600"); &#125; else if (primaryCode == 8300) &#123;// 300 editable.insert(start, "300"); &#125; else if (primaryCode == 8000) &#123;// 00 editable.insert(start, "00"); &#125; else if (primaryCode == 8079) &#123;// ok if (mListener != null) &#123; mListener.onOkClick(); &#125; &#125; else if (primaryCode == 8065) &#123;// ABC changeKeyboard(KEYBOARD_LETTER); &#125; else if (primaryCode == 8049) &#123;// 123 changeKeyboard(KEYBOARD_NUM); &#125; else if (primaryCode == -1 || primaryCode == 32) &#123;// shift、空格，不处理 &#125; else &#123; if (edText.hasFocus()) &#123; //int和char是可以互转的，这里将int转成char editable.insert(start, Character.toString((char) primaryCode)); &#125; &#125; &#125; 根据传入的primaryCode进行判断处理。 primaryCode为设计键盘布局中数字键盘或字母键盘中Key中的android:codes属性值。通过该值来判断当前点击的是哪个键盘按钮。该值必须唯一。 editable.insert()：primaryCode转成char类型后再调用Character.toString()转成字符串插入editable中。因为int和char是可以互转的。两者间的关系可查询ASCII表 changeKeyboard()用以切换当前显示的键盘，总共有3种，这在下章节中介绍。 切换键盘1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * 修改键盘类型 * * @param keyboardType，3种键盘类型：KEYBOARD_NUM、KEYBOARD_LETTER、KEYBOARD_CH */ private void changeKeyboard(@KeyboardType int keyboardType) &#123; curKeyboardType = keyboardType; switch (keyboardType) &#123; case KEYBOARD_NUM: change2Num();//切换为数字键盘 break; case KEYBOARD_LETTER: change2Letter();//切换为字母键盘 break; case KEYBOARD_CH: change2Ch();//切换为系统键盘 break; &#125; &#125; /** * 切换为字母键盘 */ private void change2Letter() &#123; curKeyboardType = KEYBOARD_LETTER; //修改股票键盘头部标志及样式 tvNum.setTextColor(wordClolrGray); tvNum.setTextSize(12);//12表示12sp tvLetter.setTextColor(wordClolrRed); tvLetter.setTextSize(18); //切换为字母键盘 keyboardView.setKeyboard(keyboardLetter); &#125; /** * 切换为数字键盘 */ private void change2Num() &#123; curKeyboardType = KEYBOARD_NUM; tvLetter.setTextColor(wordClolrGray); tvLetter.setTextSize(12); tvNum.setTextColor(wordClolrRed); tvNum.setTextSize(18); keyboardView.setKeyboard(keyboardMum); &#125; /** * 切换为系统键盘 */ private void change2Ch() &#123; hideSoftKeyboard(); showSystemSofeKeyboard(editText); SoftKeyboardUtil.showSoftKeyboard(mActivity, editText); editText.postDelayed(new Runnable() &#123; @Override public void run() &#123; hideSystemSofeKeyboard(editText); &#125; &#125;, 250); &#125; public void hideSoftKeyboard() &#123; isShown = false; if (viewContainer != null &amp;&amp; viewContainer.getParent() != null) &#123; ((ViewGroup) viewContainer.getParent()).removeView(viewContainer); &#125; &#125; /** * 显示系统键盘 * @param editText */ public static void showSystemSofeKeyboard(EditText editText) &#123; if (BuildUtils.isBiggerL()) &#123; editText.setShowSoftInputOnFocus(true); &#125; else if (BuildUtils.isBiggerH()) &#123; try &#123; Class&lt;EditText&gt; cls = EditText.class; Method setShowSoftInputOnFocus; setShowSoftInputOnFocus = cls.getMethod("setShowSoftInputOnFocus", boolean.class); setShowSoftInputOnFocus.setAccessible(true); setShowSoftInputOnFocus.invoke(editText, true); &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; else &#123; editText.setInputType(InputType.TYPE_CLASS_TEXT); &#125; &#125; SoftKeyboardUtil123456789 public static void showSoftKeyboard(Context context, View view) &#123; if (view.requestFocus()) &#123; InputMethodManager imm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE); if (imm != null) &#123;// imm.showSoftInput(view, InputMethodManager.SHOW_IMPLICIT); imm.toggleSoftInput(InputMethodManager.SHOW_FORCED, InputMethodManager.HIDE_NOT_ALWAYS); &#125; &#125; &#125; 数字键盘和字母键盘的切换主要是调用 KeyboardView.setKeyboard()方法进行切换。 中文键盘设置比较复杂： 先隐藏当前股票键盘 再将之前屏蔽掉的系统键盘属性还原 显示系统键盘 延迟250毫秒后重新将系统键盘屏蔽掉，是为了下次显示股票键盘做准备 完整代码所涉及到的其他代码这里就不再陈述了，上面的介绍中都有涉及到。 演示示例之后抽空补上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406/** * &lt;pre&gt; * author : Haitao * blog : http://blog.nhtzj.com * time : 2017/12/1 * desc : 股票键盘 * version: 2.0 * &lt;/pre&gt; */public class StockKeyboardUtil implements View.OnClickListener &#123; //键盘类型，3种 public static final int KEYBOARD_NUM = 0; //数字键盘 public static final int KEYBOARD_LETTER = 1; //字母键盘 public static final int KEYBOARD_CH = 2; // 系统键盘 @IntDef(&#123;KEYBOARD_NUM, KEYBOARD_LETTER, KEYBOARD_CH&#125;) @Retention(RetentionPolicy.SOURCE) public @interface KeyboardType &#123; &#125; private int curKeyboardType; //当前显示的键盘类型 private Activity mActivity; //当前持有该键盘的Activity private View viewContainer; //自定义键盘根View private KeyboardView keyboardView; //keyboardView是keyboard的容器，KeyboardView.setKeyboard()切换键盘 private Keyboard keyboardMum;// 全键盘包括数字和字母 private Keyboard keyboardLetter;// 全键盘包括数字和字母 private TextView tvNum, tvLetter, tvCh, tvSlash; private FrameLayout flHide; private View vHolder; private EditText editText; //键盘绑定的EditText，接收本键盘的输入 private boolean isShown; //本键盘是否显示中 private int wordClolrGray, wordClolrRed; //键盘标题颜色：灰、红 private OnViewClick mListener; //键盘"确定"按钮点击回调 private boolean hasNav; //系统是否有底部虚拟功能按钮 private int navHight; //系统底部虚拟功能按钮的高度 @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.tv_num: case R.id.tv_letter: case R.id.tv_slash: switch (curKeyboardType) &#123; case KEYBOARD_NUM: changeKeyboard(KEYBOARD_LETTER);//修改为字母键盘 break; case KEYBOARD_LETTER: changeKeyboard(KEYBOARD_NUM);//修改为数字键盘 break; &#125; break; case R.id.tv_chinese: changeKeyboard(KEYBOARD_CH);//修改为中文键盘 break; case R.id.fl_hide: case R.id.v_holder: hideSoftKeyboard();//隐藏键盘 break; &#125; &#125; public StockKeyboardUtil(Activity mActivity) &#123; this.mActivity = mActivity; //初始化数字、字母键盘 this.keyboardMum = new Keyboard(mActivity, R.xml.keyboard_stock_num); this.keyboardLetter = new Keyboard(mActivity, R.xml.keyboard_stock_letter); wordClolrGray = mActivity.getResources().getColor(R.color.def_word_gray); wordClolrRed = mActivity.getResources().getColor(R.color.red_title); curKeyboardType = KEYBOARD_NUM; //判断并获取系统底部虚拟功能按钮高度，避免本键盘覆盖系统底部虚拟功能按钮 hasNav = NavigationBarUtils.checkDeviceHasNavigationBar(mActivity); if (hasNav) &#123; navHight = NavigationBarUtils.getNavigationBarHeight(mActivity); &#125; &#125; /** * 绑定EditText * * @param editText * @param isAuto 当前是否显示股票键盘 */ public void attachTo(EditText editText, boolean isAuto) &#123; this.editText = editText; //隐藏系统键盘 hideSystemSofeKeyboard(this.editText); setAutoShowOnFocs(isAuto); &#125; /** * editText 是否设置焦点改变（OnFocusChangeListener）后隐藏/显示 本股票键盘的监听 * * @param enable */ public void setAutoShowOnFocs(boolean enable) &#123; if (editText == null) return; if (enable) editText.setOnFocusChangeListener(onFocusChangeListener1); else editText.setOnFocusChangeListener(null); &#125; //焦点改变回调，用以监听本股票键盘绑定的EditText的焦点，以控制该键盘的隐藏/显示 View.OnFocusChangeListener onFocusChangeListener1 = new View.OnFocusChangeListener() &#123; @Override public void onFocusChange(View v, boolean hasFocus) &#123; if (hasFocus) showSoftKeyboard(); else hideSoftKeyboard(); &#125; &#125;; /** * 显示股票键盘 */ public void showSoftKeyboard() &#123; //处理系统键盘问题 if (curKeyboardType == KEYBOARD_CH) &#123; curKeyboardType = KEYBOARD_NUM; &#125; isShown = true; //根据viewContainer，避免重复初始化 if (viewContainer == null) &#123; viewContainer = mActivity.getLayoutInflater().inflate(R.layout.view_keyboardview, null); tvNum = (TextView) viewContainer.findViewById(R.id.tv_num); tvLetter = (TextView) viewContainer.findViewById(R.id.tv_letter); tvCh = (TextView) viewContainer.findViewById(R.id.tv_chinese); tvSlash = (TextView) viewContainer.findViewById(R.id.tv_slash); flHide = (FrameLayout) viewContainer.findViewById(R.id.fl_hide); vHolder = viewContainer.findViewById(R.id.v_holder); //keyboardView是keyboard的容器，KeyboardView.setKeyboard()切换键盘 keyboardView = (KeyboardView) viewContainer.findViewById(R.id.keyboard_view); keyboardView.setEnabled(true); keyboardView.setPreviewEnabled(false); //设置键盘按钮回调 keyboardView.setOnKeyboardActionListener(new OnKeyboardActionListener() &#123; @Override public void swipeUp() &#123; &#125; @Override public void swipeRight() &#123; &#125; @Override public void swipeLeft() &#123; &#125; @Override public void swipeDown() &#123; &#125; @Override public void onText(CharSequence text) &#123; &#125; @Override public void onRelease(int primaryCode) &#123; &#125; @Override public void onPress(int primaryCode) &#123; &#125; @Override public void onKey(int primaryCode, int[] keyCodes) &#123; if (editText != null) &#123; //处理点击的按钮， // primaryCode即：键盘布局文件中Key中的android:codes值， // 该值为ASCII表中的十进制列， // 比如：48-&gt;0,97-&gt;a, // 这样表示方便将int型转换成字符 keyCode_delect(primaryCode, editText); &#125; keyboardView.postInvalidate(); &#125; &#125;); &#125; else &#123; if (viewContainer.getParent() != null) return; &#125; tvNum.setOnClickListener(this); tvLetter.setOnClickListener(this); tvCh.setOnClickListener(this); tvSlash.setOnClickListener(this); flHide.setOnClickListener(this); vHolder.setOnClickListener(this); changeKeyboard(curKeyboardType); //直接操作Activity的DecorView，将本股票布局填上去 FrameLayout frameLayout = (FrameLayout) mActivity.getWindow().getDecorView(); FrameLayout.LayoutParams lp = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.WRAP_CONTENT); lp.gravity = Gravity.BOTTOM; if (hasNav) &#123; lp.setMargins(0, 0, 0, navHight); &#125; frameLayout.addView(viewContainer, lp); viewContainer.setAnimation(AnimationUtils.loadAnimation(mActivity, R.anim.down_to_up)); &#125; public void hideSoftKeyboard() &#123; isShown = false; if (viewContainer != null &amp;&amp; viewContainer.getParent() != null) &#123; ((ViewGroup) viewContainer.getParent()).removeView(viewContainer); &#125; &#125; public boolean isShowing() &#123; return isShown; &#125; /** * 隐藏系统键盘 * * @param editText */ public static void hideSystemSofeKeyboard(EditText editText) &#123; //Android L以及之后可直接设置 if (BuildUtils.isBiggerL()) &#123; editText.setShowSoftInputOnFocus(false); &#125; else if (BuildUtils.isBiggerH()) &#123;//通过反射设置 try &#123; Class&lt;EditText&gt; cls = EditText.class; Method setShowSoftInputOnFocus; setShowSoftInputOnFocus = cls.getMethod("setShowSoftInputOnFocus", boolean.class); setShowSoftInputOnFocus.setAccessible(true); setShowSoftInputOnFocus.invoke(editText, false); &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; else &#123; editText.setInputType(InputType.TYPE_NULL); &#125; &#125; /** * 显示系统键盘 * @param editText */ public static void showSystemSofeKeyboard(EditText editText) &#123; if (BuildUtils.isBiggerL()) &#123; editText.setShowSoftInputOnFocus(true); &#125; else if (BuildUtils.isBiggerH()) &#123; try &#123; Class&lt;EditText&gt; cls = EditText.class; Method setShowSoftInputOnFocus; setShowSoftInputOnFocus = cls.getMethod("setShowSoftInputOnFocus", boolean.class); setShowSoftInputOnFocus.setAccessible(true); setShowSoftInputOnFocus.invoke(editText, true); &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; else &#123; editText.setInputType(InputType.TYPE_CLASS_TEXT); &#125; &#125; /** * 处理按钮， * 删除、数字字母切换、确定 * * @param primaryCode * @param edText */ private void keyCode_delect(int primaryCode, EditText edText) &#123; Editable editable = edText.getText(); int start = edText.getSelectionStart(); if (primaryCode == Keyboard.KEYCODE_DELETE) &#123;// 回退 if (edText.hasFocus()) &#123; if (!TextUtils.isEmpty(editable)) &#123; if (start &gt; 0) &#123; editable.delete(start - 1, start); &#125; &#125; &#125; &#125; else if (primaryCode == 8600) &#123;// 600 editable.insert(start, "600"); &#125; else if (primaryCode == 8300) &#123;// 300 editable.insert(start, "300"); &#125; else if (primaryCode == 8000) &#123;// 00 editable.insert(start, "00"); &#125; else if (primaryCode == 8079) &#123;// ok if (mListener != null) &#123; mListener.onOkClick(); &#125; &#125; else if (primaryCode == 8065) &#123;// ABC changeKeyboard(KEYBOARD_LETTER); &#125; else if (primaryCode == 8049) &#123;// 123 changeKeyboard(KEYBOARD_NUM); &#125; else if (primaryCode == -1 || primaryCode == 32) &#123;// shift、空格，不处理 &#125; else &#123; if (edText.hasFocus()) &#123; //int和char是可以互转的，这里将int转成char editable.insert(start, Character.toString((char) primaryCode)); &#125; &#125; &#125; /** * 修改键盘类型 * * @param keyboardType，3种键盘类型：KEYBOARD_NUM、KEYBOARD_LETTER、KEYBOARD_CH */ private void changeKeyboard(@KeyboardType int keyboardType) &#123; curKeyboardType = keyboardType; switch (keyboardType) &#123; case KEYBOARD_NUM: change2Num();//切换为数字键盘 break; case KEYBOARD_LETTER: change2Letter();//切换为字母键盘 break; case KEYBOARD_CH: change2Ch();//切换为系统键盘 break; &#125; &#125; /** * 切换为字母键盘 */ private void change2Letter() &#123; curKeyboardType = KEYBOARD_LETTER; //修改股票键盘头部标志及样式 tvNum.setTextColor(wordClolrGray); tvNum.setTextSize(12);//12表示12sp tvLetter.setTextColor(wordClolrRed); tvLetter.setTextSize(18); //切换为字母键盘 keyboardView.setKeyboard(keyboardLetter); &#125; /** * 切换为数字键盘 */ private void change2Num() &#123; curKeyboardType = KEYBOARD_NUM; tvLetter.setTextColor(wordClolrGray); tvLetter.setTextSize(12); tvNum.setTextColor(wordClolrRed); tvNum.setTextSize(18); keyboardView.setKeyboard(keyboardMum); &#125; /** * 切换为系统键盘 */ private void change2Ch() &#123; hideSoftKeyboard(); showSystemSofeKeyboard(editText); SoftKeyboardUtil.showSoftKeyboard(mActivity, editText); editText.postDelayed(new Runnable() &#123; @Override public void run() &#123; hideSystemSofeKeyboard(editText); &#125; &#125;, 250); &#125; /** * 设置 确定 按钮回调 * * @param listener */ public void setListener(OnViewClick listener) &#123; this.mListener = listener; &#125; public interface OnViewClick &#123; void onOkClick(); &#125;&#125;]]></content>
      <categories>
        <category>android</category>
        <category>股票</category>
        <category>键盘</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>股票</tag>
        <tag>股票键盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从源码角度彻底搞懂String、StringBuffer、StringBuilder]]></title>
    <url>%2F337496567%2F</url>
    <content type="text"><![CDATA[转自：https://blog.csdn.net/xfhy_/article/details/80019618 引言在之前,我知道的关于String,StringBuffer,StringBuilder的知识点大概如下 String是不可变的（修改String时，不会在原有的内存地址修改，而是重新指向一个新对象），String用final修饰，不可继承，String本质上是个final的char[]数组，所以char[]数组的内存地址不会被修改，而且String 也没有对外暴露修改char[]数组的方法.不可变性可以保证线程安全以及字符串串常量池的实现.频繁的增删操作是不建议使用String的. StringBuffer是线程安全的,多线程建议使用这个. StringBuilder是非线程安全的,单线程使用这个更快. 对于上面这些结论,我也不知道从哪里来的,,,,感觉好像是前辈的经验吧,,,好了,废话不多说,直接上代码吧. String源码分析看下继承结构源码: 123456public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; ...&#125; 可以看到String是final的,不允许继承.里面用来存储value的是一个final数组,也是不允许修改的.String有很多方法,下面就String类常用方法进行分析. 构造方法1234567891011public String() &#123; this.value = "".value;&#125;public String(String original) &#123; this.value = original.value; this.hash = original.hash;&#125;public String(char value[]) &#123; this.value = Arrays.copyOf(value, value.length);&#125;... 可以看到默认的构造器是构建的空字符串,其实所有的构造器就是给value数组赋初值. 字符串长度返回该字符串的长度,这太简单了,就是返回value数组的长度. 123public int length() &#123; return value.length;&#125; 字符串某一位置字符返回字符串中指定位置的字符； 12345678public char charAt(int index) &#123; //1. 首先判断是否越界 if ((index &lt; 0) || (index &gt;= value.length)) &#123; throw new StringIndexOutOfBoundsException(index); &#125; //2. 返回相应位置的值 return value[index];&#125; 提取子串用String类的substring方法可以提取字符串中的子串，简单分析一下substring(int beginIndex, int endIndex)吧,该方法从beginIndex位置起，从当前字符串中取出到endIndex-1位置的字符作为一个 新的字符串(重新new了一个String) 返回. 方法内部是将数组进行部分复制完成的,所以该方法不会对原有的数组进行更改. 12345678910111213141516171819202122232425262728293031323334353637383940414243public String substring(int beginIndex, int endIndex) &#123; //1.验证入参是否越界 if (beginIndex &lt; 0) &#123; throw new StringIndexOutOfBoundsException(beginIndex); &#125; if (endIndex &gt; value.length) &#123; throw new StringIndexOutOfBoundsException(endIndex); &#125; //2. 记录切割长度 int subLen = endIndex - beginIndex; //3. 入参合法性 if (subLen &lt; 0) &#123; throw new StringIndexOutOfBoundsException(subLen); &#125; //4. 如果开始切割处是0,结束切割处是value数组长度,那么相当于没有切割嘛,就直接返回原字符串;如果是其他情况:则重新新建一个String对象 return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this : new String(value, beginIndex, subLen);&#125;/*** 通过一个char数组复制部分内容生成一个新数组,复制区间:从offset到offset+count处.*/public String(char value[], int offset, int count) &#123; if (offset &lt; 0) &#123; throw new StringIndexOutOfBoundsException(offset); &#125; if (count &lt;= 0) &#123; if (count &lt; 0) &#123; throw new StringIndexOutOfBoundsException(count); &#125; //count==0 if (offset &lt;= value.length) &#123; this.value = "".value; return; &#125; &#125; // Note: offset or count might be near -1&gt;&gt;&gt;1. if (offset &gt; value.length - count) &#123; throw new StringIndexOutOfBoundsException(offset + count); &#125; //复制一部分 this.value = Arrays.copyOfRange(value, offset, offset+count);&#125; 字符串比较 compareTo(String anotherString) 该方法是对字符串内容按字典顺序进行大小比较，通过返回的整数值指明当前字符串与参数字符串的大小关系.若当前对象比参数大则返回正整数，反之返回负整数，相等返回0. 主要是挨个字符进行比较 123456789101112131415161718192021222324public int compareTo(String anotherString) &#123; //1. 记录长度 int len1 = value.length; int len2 = anotherString.value.length; //2. 最短长度 int lim = Math.min(len1, len2); char v1[] = value; char v2[] = anotherString.value; int k = 0; //3. 循环逐个字符进行比较,如果不相等则返回字符之差 //这里只需要循环lim次就行了 while (k &lt; lim) &#123; char c1 = v1[k]; char c2 = v2[k]; if (c1 != c2) &#123; //可能是正数或负数 return c1 - c2; &#125; k++; &#125; //4. 最后返回长度之差 这里可能是0,即相等 return len1 - len2;&#125; compareToIgnore(String anotherString) 与compareTo()方法相似，但忽略大小写. 实现:从下面的源码可以看出,最终实现是通过一个内部类CaseInsensitiveComparator,它实现了Comparator和Serializable接口,并实现了compare()方法,里面的实现方法和上面的compareTo()方法差不多,只不过忽略大小写. 123456789101112131415161718192021222324252627282930313233343536public int compareToIgnoreCase(String str) &#123; return CASE_INSENSITIVE_ORDER.compare(this, str);&#125;public static final Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER = new CaseInsensitiveComparator();private static class CaseInsensitiveComparator implements Comparator&lt;String&gt;, java.io.Serializable &#123; // use serialVersionUID from JDK 1.2.2 for interoperability private static final long serialVersionUID = 8575799808933029326L; public int compare(String s1, String s2) &#123; int n1 = s1.length(); int n2 = s2.length(); int min = Math.min(n1, n2); for (int i = 0; i &lt; min; i++) &#123; char c1 = s1.charAt(i); char c2 = s2.charAt(i); if (c1 != c2) &#123; c1 = Character.toUpperCase(c1); c2 = Character.toUpperCase(c2); if (c1 != c2) &#123; c1 = Character.toLowerCase(c1); c2 = Character.toLowerCase(c2); if (c1 != c2) &#123; // No overflow because of numeric promotion return c1 - c2; &#125; &#125; &#125; &#125; return n1 - n2; &#125; /** Replaces the de-serialized object. */ private Object readResolve() &#123; return CASE_INSENSITIVE_ORDER; &#125;&#125; equals(Object anotherObject) 比较当前字符串和参数字符串，在两个字符串相等的时候返回true，否则返回false. 大体实现思路: 先判断引用是否相同 再判断该Object对象是否是String的实例 再判断两个字符串的长度是否一致 最后挨个字符进行比较 1234567891011121314151617181920212223242526public boolean equals(Object anObject) &#123; //1. 引用相同 if (this == anObject) &#123; return true; &#125; //2. 是String的实例? if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; //3. 长度 if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; //4. 挨个字符进行比较 while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; equalsIgnoreCase(String anotherString) 与equals方法相似，但忽略大小写.但是这里要稍微复杂一点,因为牵连到另一个方法regionMatches(),没关系,下面跟着我一起慢慢分析. 在equalsIgnoreCase()方法里面首先是校验引用值是否一致,再判断否为空,紧接着判断长度是否一致,最后通过regionMatches()方法测试两个字符串每个字符是否相等(忽略大小写). 在regionMatches()方法中其实还是比较简单的,就是逐字符进行比较,当需要进行忽略大小写时,如果遇到不相等的2字符,先统一转成大写进行比较,如果相同则继续比较下一个,不相同则转成小写再判断是否一致. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public boolean equalsIgnoreCase(String anotherString) &#123; return (this == anotherString) ? true : (anotherString != null) &amp;&amp; (anotherString.value.length == value.length) &amp;&amp; regionMatches(true, 0, anotherString, 0, value.length);&#125;public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) &#123; char ta[] = value; int to = toffset; char pa[] = other.value; int po = ooffset; // Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1. if ((ooffset &lt; 0) || (toffset &lt; 0) || (toffset &gt; (long)value.length - len) || (ooffset &gt; (long)other.value.length - len)) &#123; return false; &#125; while (len-- &gt; 0) &#123; //循环校验每个字符是否相等,相等则继续校验下一个字符 char c1 = ta[to++]; char c2 = pa[po++]; if (c1 == c2) &#123; continue; &#125; //如果遇到不相等的2字符,再判断是否忽略大小写. //先统一转成大写进行比较,如果相同则继续比较下一个,不相同则转成小写再判断是否一致 if (ignoreCase) &#123; // If characters don't match but case may be ignored, // try converting both characters to uppercase. // If the results match, then the comparison scan should // continue. char u1 = Character.toUpperCase(c1); char u2 = Character.toUpperCase(c2); if (u1 == u2) &#123; continue; &#125; // Unfortunately, conversion to uppercase does not work properly // for the Georgian alphabet, which has strange rules about case // conversion. So we need to make one last check before // exiting. if (Character.toLowerCase(u1) == Character.toLowerCase(u2)) &#123; continue; &#125; &#125; return false; &#125; return true; &#125; 字符串连接将指定字符串联到此字符串的结尾，效果等价于”+”. 实现思路:构建一个新数组,先将原来的数组复制进新数组里面,再将需要连接的字符串复制进新数组里面(存放到后面). 123456789101112131415161718192021222324252627public String concat(String str) &#123; //1. 首先获取传入字符串长度 咦,居然没有对入参合法性进行判断?万一是null呢 int otherLen = str.length(); //2. 如果传入字符串长度为0,就没必要往后面走了 if (otherLen == 0) &#123; return this; &#125; //3. 记录当前数组长度 int len = value.length; //4. 搞一个新数组(空间大小为len + otherLen),前面len个空间用来存放value数组 char buf[] = Arrays.copyOf(value, len + otherLen); //5. 将str存入buf数组的后面otherLen个空间里面 str.getChars(buf, len); //6. new一个String将新建的buf数组传入 return new String(buf, true);&#125;//将des数组复制进value数组中,dstBegin:目的数组放置的起始位置void getChars(char dst[], int dstBegin) &#123; System.arraycopy(value, 0, dst, dstBegin, value.length);&#125;//这里的share参数貌似总是为true 所以是暂时没用咯??String(char[] value, boolean share) &#123; // assert share : "unshared not supported"; this.value = value;&#125; 字符串中单个字符查找 indexOf(int ch/String str) 返回指定字符在此字符串中第一次出现处的索引,在该对象表示的字符序列中第一次出现该字符的索引，如果未出现该字符，则返回 -1。 其实该方法最后是调用的indexOf(ch/str, 0); 该方法放到下面进行分析. indexOf(int ch/String str, int fromIndex) 该方法与第一种类似，区别在于该方法从fromIndex位置向后查找. 先分析indexOf(int ch, int fromIndex),该方法是查找ch在fromIndex索引之后第一次出现的索引.主要就是逐个字符进行比较,相同则返回索引.如果未找到则返回-1. 12345678910111213141516171819202122232425262728public int indexOf(int ch, int fromIndex) &#123; final int max = value.length; //1. 边界 if (fromIndex &lt; 0) &#123; fromIndex = 0; &#125; else if (fromIndex &gt;= max) &#123; // Note: fromIndex might be near -1&gt;&gt;&gt;1. return -1; &#125; //2. 是否是罕见字符 if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123; // handle most cases here (ch is a BMP code point or a // negative value (invalid code point)) //在这里其实已经处理了大多数情况 final char[] value = this.value; //3. 从fromIndex开始,循环,找到第一个与ch相等的进行返回 for (int i = fromIndex; i &lt; max; i++) &#123; if (value[i] == ch) &#123; return i; &#125; &#125; return -1; &#125; else &#123; //4. 罕见字符处理 return indexOfSupplementary(ch, fromIndex); &#125;&#125; 再来分析indexOf(String str, int fromIndex),该方法功能是从指定的索引处开始，返回第一次出现的指定子字符串在此字符串中的索引. 大体思路: 有点类似于字符串查找子串,先在当前字符串中找到与目标字符串的第一个字符相同的索引处 再从此索引出发循环遍历目标字符串后面的字符. 如果全部相同,则返回下标;如果不全部相同,则重复步骤1 文字可能描述不清楚,上图片 我们要在beautifulauful中查找ful,那么步骤是首先找到f,再匹配后面的ul部分,找到则返回索引,未找到则继续查找. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public int indexOf(String str, int fromIndex) &#123; return indexOf(value, 0, value.length, str.value, 0, str.value.length, fromIndex);&#125;//在source数组中查找target数组static int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) &#123; //1. 校验参数合法性 if (fromIndex &gt;= sourceCount) &#123; return (targetCount == 0 ? sourceCount : -1); &#125; if (fromIndex &lt; 0) &#123; fromIndex = 0; &#125; if (targetCount == 0) &#123; return fromIndex; &#125; //2. 记录第一个需要匹配的字符 char first = target[targetOffset]; //3. 这一次匹配的能到达的最大索引 int max = sourceOffset + (sourceCount - targetCount); //4. 循环遍历后面的数组 for (int i = sourceOffset + fromIndex; i &lt;= max; i++) &#123; /* Look for first character. */ //5. 循环查找,直到查找到第一个和目标字符串第一个字符相同的索引 if (source[i] != first) &#123; while (++i &lt;= max &amp;&amp; source[i] != first); &#125; /* Found first character, now look at the rest of v2 */ //6. 找到了第一个字符,再来看看目标字符串剩下的部分 if (i &lt;= max) &#123; int j = i + 1; int end = j + targetCount - 1; //7. 匹配一下目标字符串后面的字符串是否相等 不相等的时候就跳出循环 for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j] == target[k]; j++, k++); //8. 如果全部相等,则返回索引 if (j == end) &#123; /* Found whole string. */ return i - sourceOffset; &#125; &#125; &#125; return -1;&#125; lastIndexOf(int ch/String str) 该方法与第一种类似，区别在于该方法从字符串的末尾位置向前查找. 实现方法也与第一种是类似的,只不过是从后往前查找. 1234567891011121314151617181920212223public int lastIndexOf(int ch) &#123; return lastIndexOf(ch, value.length - 1);&#125;public int lastIndexOf(int ch, int fromIndex) &#123; //1. 判断是否是罕见字符 if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123; // handle most cases here (ch is a BMP code point or a // negative value (invalid code point)) final char[] value = this.value; //2. 从fromIndex(从哪个索引开始), value.length - 1(数组最后一个索引)中小一点的往前找,这里之所以这样做是因为fromIndex可能比value.length-1大.这里求最小值就可以覆盖所有情况,不管fromIndex和value.length-1谁大. int i = Math.min(fromIndex, value.length - 1); //3. 循环 逐个字符进行比较,找到则返回索引 for (; i &gt;= 0; i--) &#123; if (value[i] == ch) &#123; return i; &#125; &#125; return -1; &#125; else &#123; //4. 罕见字符处理 return lastIndexOfSupplementary(ch, fromIndex); &#125;&#125; lastIndexOf(int ch/String str, int fromIndex) 该方法与第二种方法类似，区别在于该方法从fromIndex位置向前查找. 实现思路:这里要稍微复杂一点,相当于从后往前查找指定子串.上图吧 图画的有点丑,哈哈. 假设我们需要在StringBuffer中查找ABuff中的子串Buff,因为Buff的长度是4,所以我们最大的索引可能值是图中的rightIndex.然后我们就开始在source数组中匹配目标字符串的最后一个字符,匹配到后,再逐个字符进行比较剩余的字符,如果全部匹配,则返回索引.未全部匹配,则再次在source数组中寻找与目标字符串最后一个字符相等的字符,然后找到后继续匹配除去最后一个字符剩余的字符串. 唉~叙述的不是特别清晰,看代码吧,代码比我说的清晰.. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public int lastIndexOf(String str, int fromIndex) &#123; return lastIndexOf(value, 0, value.length, str.value, 0, str.value.length, fromIndex);&#125;static int lastIndexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) &#123; /* * Check arguments; return immediately where possible. For * consistency, don't check for null str. */ //1. 最大索引的可能值 int rightIndex = sourceCount - targetCount; //2. 参数合法性检验 if (fromIndex &lt; 0) &#123; return -1; &#125; if (fromIndex &gt; rightIndex) &#123; fromIndex = rightIndex; &#125; /* Empty string always matches. */ if (targetCount == 0) &#123; return fromIndex; &#125; //3. 记录目标字符串最后一个字符索引处和该字符内容 int strLastIndex = targetOffset + targetCount - 1; char strLastChar = target[strLastIndex]; //4. 只需要遍历到min处即可停止遍历了,因为在min前面的字符数量已经小于目标字符串的长度了 int min = sourceOffset + targetCount - 1; //5. strLastChar在source中的最大索引 int i = min + fromIndex;//这里的语法不是很常见,有点类似于goto,平时我们在使用时尽量不采用这种方式,这种方式容易降低代码的可读性,而且容易出错.startSearchForLastChar: while (true) &#123; //6. 在有效遍历区间内,循环查找第一个与目标字符串最后一个字符相等的字符,如果找到,则跳出循环,该字符的索引是i while (i &gt;= min &amp;&amp; source[i] != strLastChar) &#123; i--; &#125; //7. 如果已经小于min了,那么说明没找到,直接返回-1 if (i &lt; min) &#123; return -1; &#125; //8. 找到了,则再进行查找目标字符串除去最后一个字符剩下的子串 //从最后一个字符的前一个字符开始查找 int j = i - 1; //9. 目标字符串除去最后一个字符剩下的子串长度是targetCount - 1,此处start是此次剩余子串查找能到达的最小索引处 int start = j - (targetCount - 1); //10. 记录目标字符串的倒数第二个字符所在target中的索引 int k = strLastIndex - 1; //11. 循环查找剩余子串是否全部字符相同 //不相同则直接跳出继续第6步 //全部相同则返回索引 while (j &gt; start) &#123; if (source[j--] != target[k--]) &#123; i--; continue startSearchForLastChar; &#125; &#125; return start - sourceOffset + 1; &#125;&#125; 字符串中字符的替换 replace(char oldChar, char newChar) 功能:用字符newChar替换当前字符串中所有的oldChar字符，并返回一个新的字符串.大体思路: 首先判断oldChar与newChar是否相同,相同的话就没必要进行后面的操作了 从最前面开始匹配与oldChar相匹配的字符,记录索引为i 如果上面的i是正常范围内(小于len),新建一个数组,长度为len(原来的字符串的长度),将i索引前面的字符逐一复制进新数组里面,然后循环 i&lt;=x&lt;len 的字符,将字符逐一复制进新数组,但是这次的复制有规则,即如果那个字符与oldChar相同那么新数组对应索引处就放newChar. 最后通过新建的数组new一个String对象返回 思考:一开始我觉得第二步好像没什么必要性,没有第二步其实也能实现.但是,仔细想想,假设原字符串没有查找到与oldChar匹配的字符,那么我们就可以规避去新建一个数组,从而节约了不必要的开销.可以,很棒,我们就是要追求极致的性能,减少浪费资源. 小细节:源码中有一个小细节,注释中有一句avoid getfield opcode,意思是避免getfield操作码?感觉那句代码就是拷贝了一个引用副本啊,有什么高大上的作用?查阅文章https://blog.csdn.net/gaopu12345/article/details/52084218 后发现答案:在一个方法中需要大量引用实例域变量的时候，使用方法中的局部变量代替引用可以减少getfield操作的次数，提高性能。 123456789101112131415161718192021222324252627282930313233public String replace(char oldChar, char newChar) &#123; //1. 如果两者相同,那么就没必要进行比较了 if (oldChar != newChar) &#123; int len = value.length; int i = -1; char[] val = value; /* avoid getfield opcode */ //2. 从最前面开始,循环遍历,找到与oldChar相同的字符 while (++i &lt; len) &#123; if (val[i] == oldChar) &#123; break; &#125; &#125; //3. 如果找到了与oldChar相同的字符才进入if if (i &lt; len) &#123; //4. 新建一个数组,用于存放新数据 char buf[] = new char[len]; //5. 将i前面的全部复制进新数组里面去 for (int j = 0; j &lt; i; j++) &#123; buf[j] = val[j]; &#125; //6. 在i后面的字符,我们将其一个一个地放入新数组中,当然在放入时需要比对是否和oldChar相同,相同则存放newChar while (i &lt; len) &#123; char c = val[i]; buf[i] = (c == oldChar) ? newChar : c; i++; &#125; //7. 最终重新new一个String return new String(buf, true); &#125; &#125; return this;&#125; 其他类方法 trim() 功能:截去字符串两端的空格，但对于中间的空格不处理大体实现:记录前面有st个空格,最后有多少个空格,那么长度就减去多少个空格,最后根据上面的这2个数据去切割字符串. 12345678910111213141516public String trim() &#123; int len = value.length; int st = 0; char[] val = value; /* avoid getfield opcode */ //1. 记录前面有多少个空格 while ((st &lt; len) &amp;&amp; (val[st] &lt;= ' ')) &#123; st++; &#125; //2. 记录后面有多少个空格 while ((st &lt; len) &amp;&amp; (val[len - 1] &lt;= ' ')) &#123; len--; &#125; //3. 切割呗,注意:切割里面具体实现是重新new了一个String return ((st &gt; 0) || (len &lt; value.length)) ? substring(st, len) : this;&#125; startsWith(String prefix)或endsWith(String suffix) 功能:用来比较当前字符串的起始字符或子字符串prefix和终止字符或子字符串suffix是否和当前字符串相同，重载方法中同时还可以指定比较的开始位置offset. 思路:比较简单,就直接看代码了,有详细注释. 12345678910111213141516171819202122public boolean startsWith(String prefix) &#123; return startsWith(prefix, 0);&#125;public boolean startsWith(String prefix, int toffset) &#123; char ta[] = value; int to = toffset; char pa[] = prefix.value; int po = 0; int pc = prefix.value.length; // Note: toffset might be near -1&gt;&gt;&gt;1. //1. 入参检测合法性 if ((toffset &lt; 0) || (toffset &gt; value.length - pc)) &#123; return false; &#125; //2. 循环进行逐个字符遍历,有不相等的就直接返回false,遍历完了还没发现不相同的,那么就是true while (--pc &gt;= 0) &#123; if (ta[to++] != pa[po++]) &#123; return false; &#125; &#125; return true;&#125; contains(String str) 功能:判断参数s是否被包含在字符串中，并返回一个布尔类型的值.思路:其实就是利用已经实现好的indexOf()去查找是否包含.源码中对于已实现的东西利用率还是非常高的.我们要多学习. 123public boolean contains(CharSequence s) &#123; return indexOf(s.toString()) &gt; -1;&#125; 基本类型转换为字符串类型 这部分代码一看就懂,都是一句代码解决. 12345678910111213141516171819202122232425262728293031323334public static String valueOf(Object obj) &#123; return (obj == null) ? "null" : obj.toString();&#125;public static String valueOf(char data[]) &#123; return new String(data);&#125;public static String valueOf(char data[], int offset, int count) &#123; return new String(data, offset, count);&#125;public static String copyValueOf(char data[], int offset, int count) &#123; return new String(data, offset, count);&#125;public static String copyValueOf(char data[]) &#123; return new String(data);&#125;public static String valueOf(boolean b) &#123; return b ? "true" : "false";&#125;public static String valueOf(char c) &#123; char data[] = &#123;c&#125;; return new String(data, true);&#125;public static String valueOf(int i) &#123; return Integer.toString(i);&#125;public static String valueOf(long l) &#123; return Long.toString(l);&#125;public static String valueOf(float f) &#123; return Float.toString(f);&#125;public static String valueOf(double d) &#123; return Double.toString(d);&#125; 注意事项最后注意一下:Android 6.0（23） 源码中，String类的实现被替换了，具体调用的时候，会调用一个StringFactory来生成一个String.来看下Android源码中String,,我擦,,这…..直接抛错误UnsupportedOperationException,可能是因为Oracle告Google的原因吧.. 123456public String() &#123; throw new UnsupportedOperationException("Use StringFactory instead.");&#125;public String(String original) &#123; throw new UnsupportedOperationException("Use StringFactory instead.");&#125; 我们平时开发APP时都是使用的java.lang包下面的String,上面的问题一般不会遇到,但是作为Android开发者还是要了解一下. AbstractStringBuilder源码分析先看看类StringBuffer和StringBuilder的继承结构 可以看到StringBuffer和StringBuilder都是继承了AbstractStringBuilder.所以这里先分析一下AbstractStringBuilder. 在这基类里面真实的保存了StringBuffer和StringBuilder操作的实际数据内容,数据内容其实是一个char[] value;数组,在其构造方法中其实就是初始化该字符数组. 123456char[] value;AbstractStringBuilder() &#123;&#125;AbstractStringBuilder(int capacity) &#123; value = new char[capacity];&#125; 扩容既然数据内容(上面的value数组)是在AbstractStringBuilder里面的,那么很多操作我觉得应该也是在父类里面,比如扩容,下面我们看看源码 123456789101112131415161718192021222324252627282930313233343536373839404142public void ensureCapacity(int minimumCapacity) &#123; if (minimumCapacity &gt; 0) ensureCapacityInternal(minimumCapacity);&#125;/*** 确保value字符数组不会越界.重新new一个数组,引用指向value*/ private void ensureCapacityInternal(int minimumCapacity) &#123; // overflow-conscious code if (minimumCapacity - value.length &gt; 0) &#123; value = Arrays.copyOf(value, newCapacity(minimumCapacity)); &#125;&#125;/*** 扩容:之前的大小的2倍+2*/ private int newCapacity(int minCapacity) &#123; // overflow-conscious code 扩大2倍+2 //小知识点:这里可能会溢出,溢出后是负数哈,注意 int newCapacity = (value.length &lt;&lt; 1) + 2; if (newCapacity - minCapacity &lt; 0) &#123; newCapacity = minCapacity; &#125; //MAX_ARRAY_SIZE的值是Integer.MAX_VALUE - 8,先判断一下预期容量(newCapacity)是否在0&lt;x&lt;MAX_ARRAY_SIZE之间,在这区间内就直接将数值返回,不在这区间就去判断一下是否溢出 return (newCapacity &lt;= 0 || MAX_ARRAY_SIZE - newCapacity &lt; 0) ? hugeCapacity(minCapacity) : newCapacity;&#125;/*** 判断大小 是否溢出*/private int hugeCapacity(int minCapacity) &#123; if (Integer.MAX_VALUE - minCapacity &lt; 0) &#123; // overflow throw new OutOfMemoryError(); &#125; return (minCapacity &gt; MAX_ARRAY_SIZE) ? minCapacity : MAX_ARRAY_SIZE;&#125; 可以看到这里的扩容方式是 = 以前的大小*2+2,其他的细节方法中已给出详细注释. 追加举一个比较有代表性的添加,详细注释在代码中 1234567891011121314151617181920212223/*** 追加:从指定字符串的片段*/public AbstractStringBuilder append(CharSequence s, int start, int end) &#123; //1. 如果是空,则添加字符串"null" if (s == null) s = "null"; //2. 判断是否越界 if ((start &lt; 0) || (start &gt; end) || (end &gt; s.length())) throw new IndexOutOfBoundsException( "start " + start + ", end " + end + ", s.length() " + s.length()); //3. 记录添加字符串长度 int len = end - start; //4. 判断一下 当前数组长度+需要添加的字符串长度 是否够装,不够装就扩容(扩容时还有复制原内容到新数组中) ensureCapacityInternal(count + len); //5. 追加内容到value数组最后 for (int i = start, j = count; i &lt; end; i++, j++) value[j] = s.charAt(i); //6. 更新数组长度 count += len; return this;&#125; 增加这里的大体思想是和以前大一的时候用C语言在数组中插入数据是一样的. 这里假设需要插入的字符串s,插入在目标字符串desOffset处,插入的长度是len.首先将需要插入处的desOffset~desOffset+len往后挪,挪到desOffset+len处,然后在desOffset处插入目标字符串. 大体思想就是这样,是不是觉得很熟悉?? ヽ(￣▽￣)ﾉ 下面这个方法是上面思路的具体实现,详细的逻辑分析已经放到代码注释中. 1234567891011121314151617181920212223242526272829//插入字符串,从dstOffset索引处开始插入,插入内容为s中的[start,end]字符串public AbstractStringBuilder insert(int dstOffset, CharSequence s, int start, int end) &#123; //1. 空处理 if (s == null) s = "null"; //2. 越界判断 if ((dstOffset &lt; 0) || (dstOffset &gt; this.length())) throw new IndexOutOfBoundsException("dstOffset "+dstOffset); //3. 入参检测是否合法 if ((start &lt; 0) || (end &lt; 0) || (start &gt; end) || (end &gt; s.length())) throw new IndexOutOfBoundsException( "start " + start + ", end " + end + ", s.length() " + s.length()); //4. 长度记录 int len = end - start; //5. 判断一下 当前数组长度+需要添加的字符串长度 是否够装,不够装就扩容(扩容时还有复制原内容到新数组中) ensureCapacityInternal(count + len); //6. 将原数组中dstOffset开始的count - dstOffset个字符复制到dstOffset + len处,,,,这里其实就是腾出一个len长度的区间,用用户存放目标字符串,这个区间就是dstOffset到dstOffset + len System.arraycopy(value, dstOffset, value, dstOffset + len, count - dstOffset); //7. 存放目标字符串 for (int i=start; i&lt;end; i++) value[dstOffset++] = s.charAt(i); //8. 记录字符串长度 count += len; //9. 返回自身引用 方便链式调用 return this;&#125; 删除源码里面的删除操作实际上是复制,比如下面这个方法删除start到end之间的字符,实际是将以end开始的字符复制到start处,并且将数组的长度记录count减去len个 1234567891011121314151617//删除从start到end索引区间( [start,end)前闭后开区间 )内内容public AbstractStringBuilder delete(int start, int end) &#123; if (start &lt; 0) throw new StringIndexOutOfBoundsException(start); if (end &gt; count) end = count; if (start &gt; end) throw new StringIndexOutOfBoundsException(); int len = end - start; //当start==end时不会改变 if (len &gt; 0) &#123; //将value数组的start+len位置开始的count-end个字符复制到value数组的start位置处. 注意,并且将数组count减去len个. System.arraycopy(value, start+len, value, start, count-end); count -= len; &#125; return this;&#125; 切割我擦,,,,原来StringBuffer的切割效率并不高嘛,其实就是new了一个String…. 123456789public String substring(int start, int end) &#123; if (start &lt; 0) throw new StringIndexOutOfBoundsException(start); if (end &gt; count) throw new StringIndexOutOfBoundsException(end); if (start &gt; end) throw new StringIndexOutOfBoundsException(end - start); return new String(value, start, end - start);&#125; 改改其实就是对其替换,而在源码中替换最终的实现其实是复制(还是复制..(￣▽￣)~*). 大体思路: 假设需要将字符串str替换value数组中的start-end中,这时只需将end后面的字符往后移动,在中间腾出一个坑,用于存放需要替换的str字符串.最后将str放到value数组中start索引处. 12345678910111213141516171819202122232425public AbstractStringBuilder replace(int start, int end, String str) &#123; //1. 入参检测合法性 if (start &lt; 0) throw new StringIndexOutOfBoundsException(start); if (start &gt; count) throw new StringIndexOutOfBoundsException("start &gt; length()"); if (start &gt; end) throw new StringIndexOutOfBoundsException("start &gt; end"); if (end &gt; count) end = count; //2. 目标String长度 int len = str.length(); //3. 计算新的数组的长度 int newCount = count + len - (end - start); //4. 判断一下是否需要扩容 ensureCapacityInternal(newCount); //5. 将value数组的end位置开始的count - end个字符复制到value数组的start+len处. 相当于把end之后的字符移到最后去,然后中间留个坑,用来存放str(需要替换成的值) System.arraycopy(value, end, value, start + len, count - end); //6. 这是String的一个方法,用于将str复制到value中start处 其最底层实现是native方法(getCharsNoCheck() ) str.getChars(value, start); //7. 更新count count = newCount; return this;&#125; 查询查询是最简单的,就是返回数组中相应索引处的值. 12345public char charAt(int index) &#123; if ((index &lt; 0) || (index &gt;= count)) throw new StringIndexOutOfBoundsException(index); return value[index];&#125; StringBuffer源码分析定义 123public final class StringBuffer extends AbstractStringBuilder implements java.io.Serializable, CharSequence StringBuffer和StringBuilder都是相同的继承结构.都是继承了AbstractStringBuilder. StringBuffer和StringBuilder构造方法,可以看到默认大小是16, 123456public StringBuffer() &#123; super(16);&#125;public StringBuffer(int capacity) &#123; super(capacity);&#125; 1. 我们先来看看StringBuffer的append方法啥,不就是调用父类的append方法嘛.. 但是,请 注意:前面说了StringBuffer是线程安全的,为什么,源码里面使用了synchronized给方法加锁了. 12345678910111213141516171819public synchronized StringBuffer append(boolean b) &#123; toStringCache = null; super.append(b); return this;&#125;@Overridepublic synchronized StringBuffer append(char c) &#123; toStringCache = null; super.append(c); return this;&#125;@Overridepublic synchronized StringBuffer append(int i) &#123; toStringCache = null; super.append(i); return this;&#125; StringBuffer的其他方法几乎都是所有方法都加了synchronized,几乎都是调用的父类的方法. 1234567891011121314public synchronized StringBuffer delete(int start, int end) &#123; toStringCache = null; super.delete(start, end); return this;&#125;public synchronized StringBuffer replace(int start, int end, String str) &#123; toStringCache = null; super.replace(start, end, str); return this;&#125;public synchronized int indexOf(String str, int fromIndex) &#123; return super.indexOf(str, fromIndex);&#125;... StringBuilder分析定义 123public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence 我们先来看看StringBuilder的append方法啥,还是调用父类的append方法嘛.. 但是,请 注意:前面说了StringBuilder不是线程安全的,为什么,源码里面没有使用synchronized进行加锁. 12345678910111213141516public StringBuilder append(boolean b) &#123; super.append(b); return this;&#125;@Overridepublic StringBuilder append(char c) &#123; super.append(c); return this;&#125;@Overridepublic StringBuilder append(int i) &#123; super.append(i); return this;&#125; StringBuilder的其他方法也是全部调用的父类方法. 但是是没有加锁的. 123456789101112public StringBuilder delete(int start, int end) &#123; super.delete(start, end); return this;&#125;public StringBuilder replace(int start, int end, String str) &#123; super.replace(start, end, str); return this;&#125;public int indexOf(String str) &#123; return super.indexOf(str);&#125;... 总结 String,StringBuffer,StringBuilder最终底层存储与操作的都是char数组.但是String里面的char数组是final的,而StringBuffer,StringBuilder不是,也就是说,String是不可变的,想要新的字符串只能重新生成String.而StringBuffer和StringBuilder只需要修改底层的char数组就行.相对来说,开销要小很多. String的大多数方法都是重新new一个新String对象返回,频繁重新生成容易生成很多垃圾. 还是那句古话,StringBuffer是线程安全的,StringBuilder是线程不安全的.因为StringBuffer的方法是加了synchronized锁起来了的,而StringBuilder没有. 增删比较多时用StringBuffer或StringBuilder（注意单线程与多线程）。实际情况按需而取吧，既然已经知道了里面的原理。 学习源码我们能从中收获什么 Java的源码都是经过上千万(我乱说的..哈哈)的程序员校验过的,不管是算法、命名、doc文档、写作风格等等都非常规范，值得我们借鉴与深思。还有很多很多的小技巧。 下次在使用时能按需而取，追求性能。 避免项目中的很多错误的发生。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从源码角度彻底搞懂ArrayList]]></title>
    <url>%2F4288408729%2F</url>
    <content type="text"><![CDATA[转自：https://blog.csdn.net/xfhy_/article/details/80193648 ArrayList的基本特点 快速随机访问 允许存放多个null元素 底层是Object数组 增加元素个数可能很慢(可能需要扩容),删除元素可能很慢(可能需要移动很多元素),改对应索引元素比较快 ArrayList的继承关系 来看下源码中的定义 12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 可以看到继承了AbstractList,此类提供 List 接口的骨干实现，以最大限度地减少实现”随机访问”数据存储（如数组）支持的该接口所需的工作.对于连续的访问数据（如链表），应优先使用 AbstractSequentialList，而不是此类. 实现了List接口,意味着ArrayList元素是有序的,可以重复的,可以有null元素的集合. 实现了RandomAccess接口标识着其支持随机快速访问,实际上,我们查看RandomAccess源码可以看到,其实里面什么都没有定义.因为ArrayList底层是数组,那么随机快速访问是理所当然的,访问速度O(1). 实现了Cloneable接口,标识着可以它可以被复制.注意,ArrayList里面的clone()复制其实是浅复制(不知道此概念的赶快去查资料,这知识点非常重要). 实现了Serializable 标识着集合可被序列化。 ArrayList 的构造方法在说构造方法之前我们要先看下与构造参数有关的几个全局变量： 12345678910111213141516171819202122/** * ArrayList 默认的数组容量 */ private static final int DEFAULT_CAPACITY = 10;/** * 用于空实例的共享空数组实例 */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;/** * 另一个共享空数组实例，用的不多,用于区别上面的EMPTY_ELEMENTDATA */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;/** * ArrayList底层的容器 */transient Object[] elementData; // non-private to simplify nested class access//当前存放了多少个元素 并非数组大小private int size; 注意到,底层容器数组的前面有一个transient关键字,啥意思?? 查阅资料后,大概知道:transient标识之后是不被序列化的 但是ArrayList实际容器就是这个数组为什么标记为不序列化??那岂不是反序列化时会丢失原来的数据? 其实是ArrayList在序列化的时候会调用writeObject()，直接将size和element写入ObjectOutputStream；反序列化时调用readObject()，从ObjectInputStream获取size和element，再恢复到elementData。 原因在于elementData是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上诉的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间。 无参构造方法123456/** * 构造一个初始容量为10的空列表。 */public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 命名里面讲elementData指向了一个空数组，为什么注释却说初始容量为10。这里先卖个关子，稍后分析。 指定初始容量的构造方法123456789101112public ArrayList(int initialCapacity) &#123; //容量&gt;0 -&gt; 构建数组 if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; //容量==0 指向空数组 this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; //容量&lt;0 报错呗 throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125; &#125; 如果我们预先知道一个集合元素的容纳的个数的时候推荐使用这个构造方法，避免使用ArrayList默认的扩容机制而带来额外的开销. 使用另一个集合 Collection 的构造方法1234567891011121314/** * 构造一个包含指定集合元素的列表，元素的顺序由集合的迭代器返回。 */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray 可能(错误地)不返回 Object[]类型的数组 参见 jdk 的 bug 列表(6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // 如果集合大小为空将赋值为 EMPTY_ELEMENTDATA 空数组 this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 增加元素+扩容机制添加单个元素add(E e) 方法作用: 添加指定元素到末尾 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/*** 添加指定元素到末尾*/public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123; //如果是以ArrayList()构造方法初始化,那么数组指向的是DEFAULTCAPACITY_EMPTY_ELEMENTDATA.第一次add()元素会进入if内部, //且minCapacity为1,那么最后minCapacity肯定是10,所以ArrayList()构造方法上面有那句很奇怪的注释. if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; //列表结构被修改的次数,用于保证线程安全,如果在迭代的时候该值意外被修改,那么会报ConcurrentModificationException错 modCount++; // 溢出? if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;//扩容private void grow(int minCapacity) &#123; // overflow-conscious code //1. 记录之前的数组长度 int oldCapacity = elementData.length; //2. 新数组的大小=老数组大小+老数组大小的一半 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //3. 判断上面的扩容之后的大小newCapacity是否够装minCapacity个元素 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //4.判断新数组容量是否大于最大值 //如果新数组容量比最大值(Integer.MAX_VALUE - 8)还大,那么交给hugeCapacity()去处理,该抛异常则抛异常 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: //5. 复制数组,注意,这里是浅复制 elementData = Arrays.copyOf(elementData, newCapacity);&#125;//巨大容量,,,666,这个名字取得好private static int hugeCapacity(int minCapacity) &#123; //溢出啦,扔出一个小错误 if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 大体思路: 首先判断如果新添加一个元素是否会导致数组溢出 判断是否溢出:如果原数组是空的,那么第一次添加元素时会给数组一个默认大小10.接着是判断是否溢出,如果溢出则去扩容,扩容规则: 新数组大小是原来数组大小的1.5倍,最后通过Arrays.copyOf()去浅复制. 添加元素到末尾 2. 添加元素到指定位置add(int index, E element) 方法作用:添加元素到指定位置 123456789101112131415161718192021222324/*** 添加元素在index处,对应索引处元素(如果有)和后面的元素往后移一位,腾出坑*/public void add(int index, E element) &#123; //1. 入参合法性检查 rangeCheckForAdd(index); //2. 是否需要扩容 ensureCapacityInternal(size + 1); // Increments modCount!! //3. 将elementData从index开始的size - index个元素复制到elementData的`index + 1`处 //相当于index处以及后面的往后移动了一位 System.arraycopy(elementData, index, elementData, index + 1, size - index); //4. 将元素放到index处 填坑 elementData[index] = element; //5. 记录当前真实数据个数 size++;&#125;//index不合法时,抛IndexOutOfBoundsExceptionprivate void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; 大体思路: 这里理解了上面的扩容之后,这里是比较简单的.其实就是在数组的某一个位置插入元素,那么我们将该索引处往后移动一位,腾出一个坑,最后将该元素放到此索引处(填坑)就行啦. 添加集合到末尾addAll(Collection 1234567891011121314public boolean addAll(Collection&lt;? extends E&gt; c) &#123; //1. 生成一个包含集合c所有元素的数组a Object[] a = c.toArray(); //2. 记录需要插入的数组长度 int numNew = a.length; //3. 判断一下是否需要扩容 ensureCapacityInternal(size + numNew); // Increments modCount //4. 将a数组全部复制到elementData末尾处 System.arraycopy(a, 0, elementData, size, numNew); //5. 标记当前elementData已有元素的个数 size += numNew; //6. 是否插入成功:c集合不为空就行 return numNew != 0;&#125; 大体思路: 代码思路是非常清晰的,很简单,就是将需要插入的集合转成数组a,再将a数组插入到当前elementData的末尾(其中还判断了一下是否需要扩容). 添加集合到指定位置addAll(int index, Collection 12345678910111213141516171819202122232425262728public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; //1. 首先检查一下下标是否越界 rangeCheckForAdd(index); //2. 生成一个包含集合c所有元素的数组a Object[] a = c.toArray(); //3. 记录需要插入的数组长度 int numNew = a.length; //4. 判断是否需要扩容 ensureCapacityInternal(size + numNew); // Increments modCount //5. 需要往后移的元素个数 int numMoved = size - index; if (numMoved &gt; 0) //后面有元素才需要复制哈,否则相当于插入到末尾 //6. 将elementData的从index开始的numMoved个元素复制到index + numNew处 System.arraycopy(elementData, index, elementData, index + numNew, numMoved); //7. 将a复制到elementData的index处 System.arraycopy(a, 0, elementData, index, numNew); //8. 标记当前elementData已有元素的个数 size += numNew; //9. 是否插入成功:c集合不为空就行 return numNew != 0;&#125;private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; 大体思路: 其实就是一个先挖坑,再填坑的故事.首先判断一下添加了集合之后是否需要扩容,因为需要将集合插入到index处,所以需要将index后面的元素往后挪动,需要挪动的元素个数为:size - index,挪动的间隔是index + numNew(因为需要留出一个坑,用来存放需要插入的集合).有了上面的步骤后就可以安全的将集合复制到elementData的index,也就完成了集合的插入. 其实我们可以看到,源码中对于细节的处理很细致,值得学习. 删除元素移除指定位置元素remove(int index)方法作用:移除指定位置元素,可能会抛出IndexOutOfBoundsException或ArrayIndexOutOfBoundsException 1234567891011121314151617181920212223242526public E remove(int index) &#123; //1. 检查参数是否合法 rangeCheck(index); modCount++; //2. 记录下需要移除的元素 E oldValue = elementData(index); //3. 需要往前面挪动1个单位的元素个数 int numMoved = size - index - 1; if (numMoved &gt; 0) //后面有元素才挪动 //4. 将index后面的元素(不包含index)往前"挪动"(复制)一位 System.arraycopy(elementData, index+1, elementData, index, numMoved); //5. 这里处理得很巧妙,首先将size-1,然后将elementData原来的最后那个元素赋值为null(方便GC回收) elementData[--size] = null; // clear to let GC do its work //6. 将旧值返回 return oldValue;&#125;//检查参数是否合法 参数&gt;size抛出IndexOutOfBoundsException 参数小于0则抛出ArrayIndexOutOfBoundsExceptionprivate void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; 大体思路: 首先将旧值取出来,保存起来 然后将数组的index后面的元素往前挪动一位 将数组的末尾元素赋值为null,方便GC回收.因为已经将index后面的元素往前挪动了一位,所以最后一位是多余的,及时清理掉. 移除指定元素remove(Object o)方法作用:移除指定元素,只移除第一个集合中与指定元素相同(通过equals()判断)的元素.移除成功了则返回true,未移除任何元素则返回false 如果传入的是null,则移除第一个null元素 如果传入的是非null元素,则移除第一个相同的元素,通过equals()进行比较.所以,如果是自己写的类,则需要重写equals()方法.一般需要用到元素比较的,都需要实现equals()方法,有时候还需要重写hashCode()方法. 1234567891011121314151617181920212223242526272829303132public boolean remove(Object o) &#123; //1. 是否为null if (o == null) &#123; //2. 循环遍历第一个为null的元素 for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; //3. 移除 移除之后就返回true fastRemove(index); return true; &#125; &#125; else &#123; //4. 循环遍历第一个与o equals()的元素 for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; //5. 移除指定位置元素 fastRemove(index); return true; &#125; &#125; return false;&#125;/*私有的方法,移除指定位置元素,其实和remove(int index)是一样的.不同的是没有返回值*/private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125; 大体思路: 首先判断需要移除的元素是否为null 如果为null,则循环遍历数组,移除第一个为null的元素 如果非null,则循环遍历数组,移除第一个与指定元素相同(equals() 返回true)的元素 可以看到最后都是移除指定位置的元素,源码中为了追求最佳的性能,加了一个fastRemove(int index)方法,次方法的实现与remove(int index)是几乎是一样的,就是少了返回index索引处元素的值. 从此列表中删除所有包含在给定集合中的元素removeAll(Collection 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public boolean removeAll(Collection&lt;?&gt; c) &#123; //判空 Objects.requireNonNull(c); return batchRemove(c, false);&#125;//complement是true 则移除elementData中除了c以外的其他元素//complement是false 则移除c和elementData(当前列表的数组)都含有的元素private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; //1. 引用不可变 final Object[] elementData = this.elementData; //r 是记录整个数组下标的, w是记录有效元素索引的 int r = 0, w = 0; boolean modified = false; try &#123; //2. 循环遍历数组 for (; r &lt; size; r++) //3. 如果complement为false 相当于是取c在elementData中的补集,c包含则不记录,c不包含则记录 //如果complement为true 相当于是取c和elementData的交集,c包含则记录,c不包含则不记录 if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; //r是正在遍历的位置 w是用于记录有效元素的 在w之前的全是有效元素,w之后的会被"删除" &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. //4. 如果上面在遍历的过程中出错了,那么r肯定不等于size,于是源码就将出错位置r后面的元素全部放到w后面 if (r != size) &#123; System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; //5. 如果w是不等于size,那么说明是需要删除元素的 否则不需要删除任何元素 if (w != size) &#123; // clear to let GC do its work //6. 将w之后的元素全部置空 因为这些已经没用了,置空方便GC回收 for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; //7. 记录当前有效元素 size = w; //8. 标记已修改 modified = true; &#125; &#125; return modified;&#125; 大体思路: 首先我们进行c集合检查,判断是否为null 然后我们调用batchRemove()方法去移除 c集合与当前列表的交集 循环遍历当前数组,记录c集合中没有的元素,放在前面(记录下标为w),w前面的是留下来的元素,w后面的是需要删除的数据 第3步可能会出错,出错的情况下,则将出错位置的后面的全部保留下来,不删除 然后就是将w之后的元素全部置空(方便GC回收),然后将size(标记当前数组有效元素)的值赋值为w,即完成了删除工作 再笼统一点说吧,其实就是将当前数组(elementData)中未包含在c中的元素,全部放在elementData数组的最前面,假设为w个,最后再统一置空后面的元素,并且记录当前数组有效元素个数为w.即完成了删除工作. 清空列表clear() 方法作用:清空当前集合的所有元素 这个方法非常简单,就是将数组所有元素都置为null,然后GC就有机会去把它回收了 123456789public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0;&#125; 移除相应区间内的所有元素(protected)removeRange(int fromIndex, int toIndex)方法作用:移除指定区间内的所有元素,注意这是protected方法,既然是移除元素,那么就拿出来欣赏欣赏. 123456789101112131415161718//这是protected方法 移除相应区间内的所有元素protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; //1. toIndex后面的元素需要保留下来,记录一下toIndex后面的元素个数 int numMoved = size - toIndex; //2. 将toIndex后面的元素复制到fromIndex处 System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // clear to let GC do its work //3. 将有效元素后面的元素置空 int newSize = size - (toIndex-fromIndex); for (int i = newSize; i &lt; size; i++) &#123; elementData[i] = null; &#125; //4. 记录当前有效元素个数为size - (toIndex-fromIndex) ,即减去那个区间内的元素个数 size = newSize;&#125; 大体思路: 假设需要移除(fromIndex,toIndex)区间内的元素,那么将toIndex后面的元素复制到fromIndex处 将有效元素后面的元素置空 改动元素替换指定下标的元素内容set(int index, E element):替换index索引处的元素为element,可能会抛出IndexOutOfBoundsException 这里比较简单,就是将index处的元素替换成element 12345678910public E set(int index, E element) &#123; //1. 入参检测 rangeCheck(index); //2. 记录原来该index处的值 E oldValue = elementData(index); //3. 替换 elementData[index] = element; return oldValue;&#125; 查询元素返回指定位置处元素这个非常简单,就是将index索引处的数组的值返回 123456789101112E elementData(int index) &#123; return (E) elementData[index];&#125;/*** 返回指定位置处元素*/public E get(int index) &#123; rangeCheck(index); return elementData(index);&#125; 通过iterator()遍历 这也是查询的一种,哈哈 首先我们了解一下fail-fast,fail-fast 机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。 要了解fail-fast机制，我们首先要对ConcurrentModificationException 异常有所了解。当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常。同时需要注意的是，该异常不会始终指出对象已经由不同线程并发修改，如果单线程违反了规则，同样也有可能会抛出该异常。 我们先来看看iterator()方法,它new了一个Itr(ArrayList的内部类)进行返回. 12345678910/*** Returns an iterator over the elements in this list in proper sequence.* &lt;p&gt;The returned iterator is &lt;a href="#fail-fast"&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.* @return an iterator over the elements in this list in proper sequence以适当的顺序返回此列表中元素的迭代器。 fail-fast:快速失败?*/public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125; 接下来我们来看看这个内部类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return 下一个元素的索引 int lastRet = -1; // index of last element returned; -1 if no such 当前访问的最后一个元素的索引 int expectedModCount = modCount; //是否有下一个元素 public boolean hasNext() &#123; //就是比一下cursor与size的大小 但是为什么是!=,而不是cursor&lt;=size,这里有点蒙 return cursor != size; &#125; @SuppressWarnings("unchecked") public E next() &#123; //判断一下该列表是否被其他线程改过(在迭代过程中) 修改过则抛异常 checkForComodification(); //第一次的时候是等于0 从0开始往后取数据 int i = cursor; //如果越界 则抛异常 if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; //不能访问超出elementData.length的索引 可能是被其他线程改动了 if (i &gt;= elementData.length) throw new ConcurrentModificationException(); //往后挪一位 下一次就能访问下一位元素 cursor = i + 1; //将需要访问的元素返回 return (E) elementData[lastRet = i]; &#125; //移除当前访问到的最后一位元素 public void remove() &#123; //入参检测 if (lastRet &lt; 0) throw new IllegalStateException(); //判断一下该列表是否被其他线程改过(在迭代过程中) 修改过则抛异常 checkForComodification(); try &#123; //移除当前访问到的最后一位元素 ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; //快速遍历列表 @Override @SuppressWarnings("unchecked") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; //入参检测 Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; //遍历完成 不用继续了 if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; //可能是被其他线程改动了 if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; //循环遍历 不断回调consumer.accept() 将elementData每个元素都回调一次 while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; //判断一下该列表是否被其他线程改过(在迭代过程中) 修改过则抛异常 final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125; 总结这是我第二次看源码,分析,鉴赏,学到了不少东西,相信各位认真看完的同学也多多少少有些感触.源码对于细节方面想的很周到,很谨慎. 下面我们来总结一下ArrayList的关键点 ArrayList关键点 底层是Object数组存储数据 扩容机制:默认大小是10,扩容是扩容到之前的1.5倍的大小,每次扩容都是将原数组的数据复制进新数组中. 我的领悟:如果是已经知道了需要创建多少个元素,那么尽量用new ArrayList&lt;&gt;(13)这种明确容量的方式创建ArrayList.避免不必要的浪费. 添加:如果是添加到数组的指定位置,那么可能会挪动大量的数组元素,并且可能会触发扩容机制;如果是添加到末尾的话,那么只可能触发扩容机制. 删除:如果是删除数组指定位置的元素,那么可能会挪动大量的数组元素;如果是删除末尾元素的话,那么代价是最小的. ArrayList里面的删除元素,其实是将该元素置为null. 查询和改某个位置的元素是非常快的( O(1) ).]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>ArrayList</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从源码角度彻底搞懂LinkedList]]></title>
    <url>%2F351309786%2F</url>
    <content type="text"><![CDATA[转自：https://blog.csdn.net/xfhy_/article/details/80355028 概述 LinkedList，相对于ArrayList，大家可能平时使用LinkedList要少一些，其实有时候使用LinkedList比ArrayList效率高很多，当然，这得视情况而定。 本文将带大家深入LinkedList源码，分析其背后的实现原理，以便以后在合适的情况下进行使用。 之前我所知道的LinkedList的知识： LinkedList底层是链表结构 插入和删除比较快（O(1)），查询则相对慢一些（O(n)） 因为是链表结构，所以分配的空间不要求是连续的 链表 因为LinkedList源码中很多地方是进行链表操作,所以先带大家复习一下链表的基础知识.以前用C语言实现的链表,大家可以去看一下,地址:https://github.com/xfhy/dataStructure 单链表 一个节点中包含数据和下一个节点的指针(注意,是下一个节点的指针,而不是下一个节点数据的指针),尾节点没有下一个节点,所以指向null.访问某个节点只能从头节点开始查找,然后依次往后遍历. 单向循环链表 单向循环链表比单链表多了一个尾节点的指针指向的是头结点. 双向链表 双向链表的每个节点包含以下数据:上一个节点的指针,自己的数据,下一个节点的指针.尾节点没有下一个节点,所以指向null.这样的结构,比如我拿到链表中间的一个节点,即可以往前遍历,也可以往后遍历. 双向循环链表 双向循环链表的尾节点的下一个节点是头结点,头节点的上一个节点是尾节点. LinkedList的继承关系 源码中的定义: 123public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable AbstractSequentialList这个类提供了List的一个骨架实现接口，以尽量减少实现此接口所需的工作量由“顺序访问”数据存储（如链接列表）支持。对于随机访问数据（如数组），应使用AbstractList优先于此类。 实现了List接口,意味着LinkedList元素是有序的,可以重复的,可以有null元素的集合. Deque是Queue的子接口,Queue是一种队列形式,而Deque是双向队列,它支持从两个端点方向检索和插入元素. 实现了Cloneable接口,标识着可以它可以被复制.注意,ArrayList里面的clone()复制其实是浅复制(不知道此概念的赶快去查资料,这知识点非常重要). 实现了Serializable 标识着集合可被序列化。 查看LinkedList源码前的准备节点定义1234567891011private static class Node&lt;E&gt; &#123; E item; //该节点的数据 Node&lt;E&gt; next; //指向下一个节点的指针 Node&lt;E&gt; prev; //指向上一个节点的指针 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; Node是LinkedList的静态内部类. 为什么是静态内部类?我觉得可能原因如下:普通内部类会有外部类的强引用,而静态内部类就没有.有外部类的强引用的话,很容易造成内存泄漏,写成静态内部类可以避免这种情况的发生. 成员变量看构造方法之前先看看几个属性: 123456789101112131415//链表长度transient int size = 0;/*** 头结点* Invariant: (first == null &amp;&amp; last == null) ||* (first.prev == null &amp;&amp; first.item != null)*/transient Node&lt;E&gt; first;/*** 尾节点* Invariant: (first == null &amp;&amp; last == null) ||* (last.next == null &amp;&amp; last.item != null)*/transient Node&lt;E&gt; last; 这里为什么要存在一个成员变量尾节点? 为了方便查找（可以想一下二分查找）, 比如查找相应索引处元素+插入元素到最后.查找相应索引处元素时,先判断索引是在前半段还是在后半段,如果是在后半段,那么直接从尾节点出发,从后往前进行查找,这样速度更快.在插入元素到最后时,可以直接通过尾节点方便的进行插入. 123456789101112131415Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 构造方法下面是构造方法源码: 12345678910111213/*** 构造一个空列表*/public LinkedList() &#123;&#125;/*** 构造列表通过指定的集合*/public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; 两个构造方法都比较简单,就是构造一个列表,其中的addAll()方法待会儿放到后面分析. 思考:为什么LinkedList没有提供public LinkedList(int initialCapacity)这种构建指定大小列表的构造方式? 因为ArrayList有这种构造方法public ArrayList(int initialCapacity),ArrayList提供这种构造方法的好处在于在知道需要多大的空间的情况下,可以按需构造列表,无需浪费多余的空间和不必要的生成新数组的操作.而LinkedList可以很轻松动态的增加元素(O(1)),所以没必要一开始就构造一个有很多元素的列表,到时需要的时候再按需加上去就行了. 添加元素add(E e)方法作用:将e添加到链表末尾,返回是否添加成功 12345678910111213141516171819202122232425262728/*** 添加指定元素到链表尾部*/public boolean add(E e) &#123; linkLast(e); return true;&#125;/*** Links e as last element.将e添加到尾部*/void linkLast(E e) &#123; //1. 暂记尾节点 final Node&lt;E&gt; l = last; //2. 构建节点 前一个节点是之前的尾节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); //3. 新建的节点是尾节点了 last = newNode; //4. 判断之前链表是否为空 //为空则将新节点赋给头结点(相当于空链表插入第一个元素,头结点等于尾节点) //非空则将之前的尾节点指向新节点 if (l == null) first = newNode; else l.next = newNode; //5. 链表长度增加 size++; modCount++;&#125; 大体思路: 构建一个新的节点 将该新节点作为新的尾节点.如果是空链表插入第一个元素,那么头结点=尾节点=新节点;如果不 是,那么将之前的尾节点指向新节点. 增加链表长度 小细节 boolean add(E e)添加成功返回true,添加失败返回false.我们在代码中没有看到有返回false的情况啊,直接在代码中写了个返回true,什么判断条件都没有,啊?? 仔细想想,分配内存空间不是必须是连续的,所以只要是还能给它分配空间,就不会添加失败.当空间不够分配时(内存溢出),会抛出OutOfMemory. addLast(E e)方法作用:添加元素到末尾. 内部实现和add(E e)一样. 123public void addLast(E e) &#123; linkLast(e);&#125; addFirst(E e)方法作用:添加元素到链表头部 123456789101112131415161718192021222324public void addFirst(E e) &#123; linkFirst(e);&#125;/*** 添加元素到链表头部*/private void linkFirst(E e) &#123; //1. 记录头结点 final Node&lt;E&gt; f = first; //2. 创建新节点 next指针指向之前的头结点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); //3. 新建的节点就是头节点了 first = newNode; //4. 判断之前链表是否为空 //为空则将新节点赋给尾节点(相当于空链表插入第一个元素,头结点等于尾节点) //非空则将之前的头结点的prev指针指向新节点 if (f == null) last = newNode; else f.prev = newNode; //5. 链表长度增加 size++; modCount++;&#125; 大体思路: 构建一个新的节点 将该新节点作为新的头节点.如果是空链表插入第一个元素,那么头结点=尾节点=新节点;如果不是,那么将之前的头节点的prev指针指向新节点. 增加链表长度 push(E e)方法作用:添加元素到链表头部 这里的意思比拟压栈.和pop(出栈:移除链表第一个元素)相反. 内部实现是和addFirst()一样的. 123public void push(E e) &#123; addFirst(e);&#125; offer(),offerFirst(E e),offerLast(E e)方法作用:添加元素到链表头部. 内部实现其实就是add(e) 123456789101112131415public boolean offer(E e) &#123; return add(e);&#125;public boolean offerFirst(E e) &#123; addFirst(e); return true;&#125;/*** 添加元素到末尾*/public boolean offerLast(E e) &#123; addLast(e); return true;&#125; add(int index, E element)方法作用:添加元素到指定位置,可能会抛出IndexOutOfBoundsException 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//添加元素到指定位置public void add(int index, E element) &#123; //1. 越界检查 checkPositionIndex(index); //2. 判断一下index大小 //如果是和list大小一样,那么就插入到最后 //否则插入到index处 if (index == size) linkLast(element); else linkBefore(element, node(index));&#125;//检查是否越界private void checkPositionIndex(int index) &#123; if (!isPositionIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;//判断index是否超出范围private boolean isPositionIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt;= size;&#125;/*** Returns the (non-null) Node at the specified element index.返回指定元素索引处的（非空）节点。*/Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); /** * 这里的思想非常巧妙,如果index在链表的前半部分,那么从first开始往后查找 否则,从last往前面查找 */ //1. 如果index&lt;size/2 ,即index在链表的前半部分 if (index &lt; (size &gt;&gt; 1)) &#123; //2. 记录下第一个节点 Node&lt;E&gt; x = first; //3. 循环从第一个节点开始往后查,直到到达index处,返回index处的元素 for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; //index在链表的后半部分 //4. 记录下最后一个节点 Node&lt;E&gt; x = last; //5. 循环从最后一个节点开始往前查,直到到达index处,返回index处的元素 for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125;/*** Links e as last element.将e链接到list最后一个元素*/void linkLast(E e) &#123; //1. 记录最后一个元素l final Node&lt;E&gt; l = last; //2. 构建一个新节点,数据为e,前一个是l,后一个是null final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); //3. 现在新节点是最后一个元素了,所以需要记录下来 last = newNode; //4. 如果之前list为空,那么first=last=newNode,只有一个元素 if (l == null) first = newNode; else //5. 非空的话,那么将之前的最后一个指向新的节点 l.next = newNode; //6. 链表长度+1 size++; modCount++;&#125;/*** Inserts element e before non-null Node succ.在非null节点succ之前插入元素e。*/void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; //1. 记录succ的前一个节点 final Node&lt;E&gt; pred = succ.prev; //2. 构建一个新节点,数据是e,前一个节点是pred,下一个节点是succ final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); //3. 将新节点作为succ的前一个节点 succ.prev = newNode; //4. 判断pred是否为空 //如果为空,那么说明succ是之前的头节点,现在新节点在succ的前面,所以新节点是头节点 if (pred == null) first = newNode; else //5. succ的前一个节点不是空的话,那么直接将succ的前一个节点指向新节点就可以了 pred.next = newNode; //6. 链表长度+1 size++; modCount++;&#125; 大体思路: 首先判断一下插入的位置是在链表的最后还是在链表中间. 如果是插入到链表末尾,那么将之前的尾节点指向新节点 如果是插入到链表中间 需要先找到链表中index索引处的节点. 将新节点赋值为index处节点的前一个节点 将index处节点的前一个节点的next指针赋值为新节点 哇,这里描述起来有点困难,,,,不知道我描述清楚没有.如果没看懂我的描述,看一下代码+再结合代码注释+画一下草图应该更清晰一些. addAll(int index, Collection123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//将指定集合的所有元素插入到末尾位置public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c);&#125;//将指定集合的所有元素插入到index位置public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; //1. 入参合法性检查 checkPositionIndex(index); //2. 将集合转成数组 Object[] a = c.toArray(); //3. 记录需要插入的集合元素个数 int numNew = a.length; //4. 如果个数为0,那么插入失败,不继续执行了 if (numNew == 0) return false; //5. 判断一下index与size是否相等 //相等则插入到链表末尾 //不相等则插入到链表中间 index处 Node&lt;E&gt; pred, succ; if (index == size) &#123; succ = null; pred = last; &#125; else &#123; //找到index索引处节点 这样就可以方便的拿到该节点的前后节点信息 succ = node(index); //记录index索引处节点前一个节点 pred = succ.prev; &#125; //6. 循环将集合中所有元素连接到pred后面 for (Object o : a) &#123; @SuppressWarnings("unchecked") E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); //如果前一个是空,那么将新节点作为头结点 if (pred == null) first = newNode; else //指向新节点 pred.next = newNode; pred = newNode; &#125; //7. 判断succ是否为空 //为空的话,那么集合的最后一个元素就是尾节点 //非空的话,那么将succ连接到集合的最后一个元素后面 if (succ == null) &#123; last = pred; &#125; else &#123; pred.next = succ; succ.prev = pred; &#125; //8. 链表长度+numNew size += numNew; modCount++; return true;&#125; 大体思路: 将需要添加的集合转成数组a 判断需要插入的位置index是否等于链表长度size,如果相等则插入到链表最后;如果不相等,则插入到链表中间,还需要找到index处节点succ,方便拿到该节点的前后节点信息. 记录index索引处节点的前一个节点pred,循环将集合中所有元素连接到pred的后面 将集合最后一个元素的next指针指向succ,将succ的prev指针指向集合的最后一个元素 删除元素remove(),removeFirst()方法作用: 移除链表第一个元素 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*** 移除链表第一个节点*/public E remove() &#123; return removeFirst();&#125;/*** 移除链表第一个节点*/public E removeFirst() &#123; final Node&lt;E&gt; f = first; //注意:如果之前是空链表,移除是要报错的哟 if (f == null) throw new NoSuchElementException(); return unlinkFirst(f);&#125;/*** Unlinks non-null first node f.* 将第一个节点删掉*/private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; //1. 记录第一个节点的数据值 final E element = f.item; //2. 记录下一个节点 final Node&lt;E&gt; next = f.next; //3. 将第一个节点置空 帮助GC回收 f.item = null; f.next = null; // help GC //4. 记录头节点 first = next; //5. 如果下一个节点为空,那么链表无节点了 如果不为空,将头节点的prev指针置为空 if (next == null) last = null; else next.prev = null; //6. 链表长度-1 size--; modCount++; //7. 返回删除的节点的数据值 return element;&#125; 大体思路: 其实就是将第一个节点移除并置空,然后将第二个节点作为头节点.思路还是非常清晰的,主要是对细节的处理. remove(int index)方法作用:移除指定位置元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//移除指定位置元素public E remove(int index) &#123; //检查入参是否合法 checkElementIndex(index); //node(index)找到index处的节点 return unlink(node(index));&#125;//移除节点xE unlink(Node&lt;E&gt; x) &#123; // assert x != null; //1. 记录该节点数据值,前一个节点prev,后一个节点next final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; //2. 判断前一个节点是否为空 if (prev == null) &#123; //为空的话,那么说明之前x节点是头节点 这时x的下一个节点成为头节点 first = next; &#125; else &#123; //非空的话,将前一个节点的next指针指向x的下一个节点 prev.next = next; //x的prev置为null x.prev = null; &#125; //3. 判断x后一个节点是否为空 if (next == null) &#123; //为空的话,那么说明之前x节点是尾节点,这时x的前一个节点成为尾节点 last = prev; &#125; else &#123; //为空的话,将x的下一个节点的prev指针指向prev(x的前一个节点) next.prev = prev; //x的next指针置空 x.next = null; &#125; //4. x节点数据值置空 x.item = null; //5. 链表长度-1 size--; modCount++; //6. 将x节点的数据值返回 return element;&#125; 大体思路: 首先找到index索引处的节点(这样就可以方便的获取该节点的前后节点),记为x 记录x的前(prev)后(next)节点 将x的前一个节点prev节点的next指针指向next,将x节点的后一个节点的prev指针指向prev节点. 将x节点置空,链表长度-1 remove(Object o)方法作用:从此链表中删除第一次出现的指定元素o 1234567891011121314151617181920212223public boolean remove(Object o) &#123; //1. 判断o是否为空 if (o == null) &#123; //为null 循环,找第一个数据值为null的节点 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; //删除该节点 unlink(x); return true; &#125; &#125; &#125; else &#123; //非空 循环,找第一个与o的数据值相等的节点 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; //删除该节点 unlink(x); return true; &#125; &#125; &#125; return false;&#125; 大体思路: 首先判断入参是否为null 如果为null,那么循环遍历链表,从头节点开始往后查找,找到第一个节点的数据值为null的,直接删除该节点. 如果非null,那么循环遍历链表,从头节点开始往后查找,找到第一个节点的数据值为o的,直接删除该节点. 这里的循环遍历链表的代码,我觉得还是比较通用的,从头节点开始,通过不断的将x赋值为下一个元素,直到遍历到为null的地方结束,这样就完美的遍历完了链表所有节点. removeFirstOccurrence(Object o)方法作用:从此链表中删除第一次出现的指定元素o. 内部其实就是上面的remove(o); 123public boolean removeFirstOccurrence(Object o) &#123; return remove(o);&#125; removeLast()方法作用:移除最后一个元素并返回 123456789101112131415161718192021222324252627282930313233343536public E removeLast() &#123; final Node&lt;E&gt; l = last; //如果链表是空的,那么就要抛出一个错误 if (l == null) throw new NoSuchElementException(); return unlinkLast(l);&#125;/*** Unlinks non-null last node l.移除链表最后一个元素*/private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; //1. 记录尾节点数据值 final E element = l.item; //2. 找到尾节点的前一个节点prev final Node&lt;E&gt; prev = l.prev; //3. 将尾节点置空 方便GC l.item = null; l.prev = null; // help GC //4. 将last赋值为prev last = prev; //5. 判断prev是否为null //为空的话,说明之前链表就只有1个节点,现在删了之后,头节点和尾节点都为null了 //非空,直接将新任尾节点的next指针指向null if (prev == null) first = null; else prev.next = null; //6. 链表长度-1 size--; modCount++; //7. 返回之前尾节点数据值 return element;&#125; 大体思路: 判断链表是否有节点, 没有节点直接抛错误…. 首先找到倒数第二个节点(可能没有哈,没有的话,说明链表只有一个节点)prev 然后将尾节点置空,prev的next指针指向null removeLastOccurrence(Object o)方法作用:从此链表中删除最后一次出现的指定元素o. 实现:其实和上面的remove(o)是一样的,只不过这里遍历时是从尾节点开始往前查找的. 123456789101112131415161718public boolean removeLastOccurrence(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125; poll()方法作用:获取第一个元素的同时删除第一个元素,当链表无节点时,不会报错. 这里的unlinkFirst()上面已分析过. 1234public E poll() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f);&#125; pop()方法作用:获取第一个元素的同时删除第一个元素,当链表无节点时,会报错. 123456789public E pop() &#123; return removeFirst();&#125;public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f);&#125; 修改元素set(int index, E element)方法作用:设置index处节点数据值为element 123456789101112public E set(int index, E element) &#123; //1. 入参检测 checkElementIndex(index); //2. 找到index处节点,上面已分析该方法 Node&lt;E&gt; x = node(index); //3. 保存该节点旧值 E oldVal = x.item; //4. 替换为新值 x.item = element; //5. 将旧值返回 return oldVal;&#125; 大体思路: 非常简单,就是首先找到index处节点,替换该节点数据值 查询元素element()方法作用:获取链表第一个元素. 方法比较简单,就是将链表头节点数据值进行返回 123456789public E element() &#123; return getFirst();&#125;public E getFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item;&#125; get(int index)方法作用:获取指定索引处元素. 方法比较简单,就是通过node(index)找到index索引处节点,然后返回其数据值 123456public E get(int index) &#123; //1. 入参检测 checkElementIndex(index); //2. 获取指定索引处节点数据值 return node(index).item;&#125; getFirst()方法作用:获取链表第一个元素. 非常简单,就是将first的数据值返回 123456public E getFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item;&#125; getLast()方法作用:获取链表最后一个元素. 非常简单,就是将last的数据值返回 123456public E getLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item;&#125; 通过listIterator()遍历 这也是查询的一种,哈哈 我们先来看看listIterator(int index)方法,就是new了一个ListItr进行返回.ListItr是LinkedList的内部类. 1234public ListIterator&lt;E&gt; listIterator(int index) &#123; checkPositionIndex(index); return new ListItr(index);&#125; 接下来,我们看看这个内部类: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131private class ListItr implements ListIterator&lt;E&gt; &#123; //上一次返回的节点 private Node&lt;E&gt; lastReturned; //下一个节点 private Node&lt;E&gt; next; //下一个节点索引 private int nextIndex; private int expectedModCount = modCount; ListItr(int index) &#123; // assert isPositionIndex(index); //如果是最后一个节点,那么返回next是null //如果不是最后一个节点,那么找到该index索引处节点 next = (index == size) ? null : node(index); nextIndex = index; &#125; public boolean hasNext() &#123; //判断是否还有下一个元素 return nextIndex &lt; size; &#125; //获取下一个元素 public E next() &#123; checkForComodification(); //1. 如果没有下一个元素 抛异常 if (!hasNext()) throw new NoSuchElementException(); //2. 记录上一次遍历到的节点 lastReturned = next; //3. 往后移 next = next.next; //4. 索引+1 nextIndex++; //5. 将遍历到的节点数据值返回 return lastReturned.item; &#125; public boolean hasPrevious() &#123; //判断是否还有前一个元素 return nextIndex &gt; 0; &#125; //获取前一个元素 public E previous() &#123; checkForComodification(); //1. 如果没有前一个元素,则抛异常 if (!hasPrevious()) throw new NoSuchElementException(); //2. 当next是null的时候,赋值为last //不是null的时候,往前移动 lastReturned = next = (next == null) ? last : next.prev; //3. index-1 因为是往前 nextIndex--; //4. 将遍历到的节点数据值返回 return lastReturned.item; &#125; public int nextIndex() &#123; return nextIndex; &#125; public int previousIndex() &#123; return nextIndex - 1; &#125; //移除当前遍历到的元素 public void remove() &#123; checkForComodification(); //1. 移除当前遍历到的元素为null,直接抛错误 if (lastReturned == null) throw new IllegalStateException(); //2. 记录当前节点的下一个节点 Node&lt;E&gt; lastNext = lastReturned.next; //3. 删除当前节点 unlink(lastReturned); //4. 如果next == lastReturned,说明当前是从前往后遍历的,那么将next赋值为下一个节点 //如果不相等,那么说明是从后往前遍历的,这时只需要将index-1就行了 if (next == lastReturned) next = lastNext; else nextIndex--; //5. 将移除的节点置空 lastReturned = null; expectedModCount++; &#125; //设置当前正在遍历的节点的值 啥?用ListIterator居然可以在遍历的时候修改值,,666 public void set(E e) &#123; if (lastReturned == null) throw new IllegalStateException(); checkForComodification(); //设置当前遍历的节点的值 lastReturned.item = e; &#125; //添加一个值 public void add(E e) &#123; checkForComodification(); lastReturned = null; //如果next为null,那么添加到最后 //否则,将e元素添加到next的前面 if (next == null) linkLast(e); else linkBefore(e, next); nextIndex++; expectedModCount++; &#125; public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); //循环 往后遍历 没遍历一个节点就回调当前节点的数据值 while (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) &#123; action.accept(next.item); lastReturned = next; next = next.next; nextIndex++; &#125; checkForComodification(); &#125; //判断一下该列表是否被其他线程改过(在迭代过程中) 修改过则抛异常 final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125; 这里的ListIterator有点强 ListIterator只能用于List及其子类型。 有add()方法,可以往链表中添加对象 可以通过hasNext()和next()往后顺序遍历,也可以通过hasPrevious()和previous()实现往前遍历 可以通过nextIndex()和previousIndex()返回当前索引处的位置 可以通过set()实现当前遍历对象的修改 总结好了,又到了总结的时候,相信各位认真看完的应该对链表的基本操作非常熟悉了. 下面我们来总结一下LinkedList的关键点 LinkedList关键点 底层是双向链表存储数据,并且记录了头节点和尾节点 添加元素非常快,如果是添加到头部和尾部的话更快,因为已经记录了头节点和尾节点,只需要链接一下就行了. 如果是添加到链表的中间部分的话,那么多一步操作,需要先找到添加索引处的元素(因为需要链接到这里),才能进行添加. 遍历的时候,建议采用forEach()进行遍历,这样可以在每次获取下一个元素时都非常轻松(next = next.next;). 然后如果是通过fori和get(i)的方式进行遍历的话,效率是极低的,每次get(i)都需要从最前面(或者最后面)开始往后查找i索引处的元素,效率很低. 删除也是非常快,只需要改动一下指针就行了,代价很小. 本文有写的不对地方,还请多多包涵,欢迎批评指正.这是我的笔记的其中一篇，需要看其他笔记的请移步 https://github.com/xfhy/notes，欢迎star、fork.]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[神奇的TextView-实现富文本]]></title>
    <url>%2F361989272%2F</url>
    <content type="text"><![CDATA[前言本篇介绍一下在Android开发过程中使用最多的一个控件-TextView,实现简单的图片加载显示及链接处理。如果你说：没有用过ConstraintLayout、FloatingActionButton、TabLayout等等，那也没多大事。但是如果说你没有用过TextView，那就得佩服你了。 先上效果： TextView 家族 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657TargetsTextViewImplementations of TextViewActionMenuItemView.javapublic class ActionMenuItemView extends AppCompatTextViewAppCompatAutoCompleteTextView.javapublic class AppCompatAutoCompleteTextView extends AutoCompleteTextView implementsAppCompatButton.javapublic class AppCompatButton extends Button implements TintableBackgroundView,AppCompatCheckBox.javapublic class AppCompatCheckBox extends CheckBox implements TintableCompoundButton &#123;AppCompatCheckedTextView.javapublic class AppCompatCheckedTextView extends CheckedTextView &#123;AppCompatEditText.javapublic class AppCompatEditText extends EditText implements TintableBackgroundView &#123;AppCompatMultiAutoCompleteTextView.javapublic class AppCompatMultiAutoCompleteTextView extends MultiAutoCompleteTextViewAppCompatRadioButton.javapublic class AppCompatRadioButton extends RadioButton implements TintableCompoundButton &#123;AppCompatTextView.javapublic class AppCompatTextView extends TextView implements TintableBackgroundView,AutoCompleteTextView.javapublic class AutoCompleteTextView extends EditText implements Filter.FilterListener &#123;Button.javapublic class Button extends TextView &#123;CheckBox.javapublic class CheckBox extends CompoundButton &#123;CheckedTextView.javapublic class CheckedTextView extends TextView implements Checkable &#123;Chronometer.javapublic class Chronometer extends TextView &#123;CompoundButton.javapublic abstract class CompoundButton extends Button implements Checkable &#123;DialogTitle.javapublic class DialogTitle extends TextView &#123;DigitalClock.javapublic class DigitalClock extends TextView &#123;EditText.javapublic class EditText extends TextView &#123;ExtractEditText.javapublic class ExtractEditText extends EditText &#123;MultiAutoCompleteTextView.javapublic class MultiAutoCompleteTextView extends AutoCompleteTextView &#123;RadioButton.javapublic class RadioButton extends CompoundButton &#123;SearchView.java public static class SearchAutoComplete extends AppCompatAutoCompleteTextView &#123;Switch.javapublic class Switch extends CompoundButton &#123;SwitchCompat.javapublic class SwitchCompat extends CompoundButton &#123;TextClock.javapublic class TextClock extends TextView &#123;TextView.javapublic class TextView extends View implements ViewTreeObserver.OnPreDrawListener &#123;ToggleButton.javapublic class ToggleButton extends CompoundButton &#123; 与TextView有着直接或间接继承关系的有27个，如上述所示。 TextView的父类为View。 TextView常用的xml属性及相关方法TextView的属性有许多，下表展示了部分属性。 xml属性 相关方法 说明 android:autoLink setAutoLinkMask(int) 是否将符合指定格式的文本转换为可单击的超链接形式 android:autoText setKeyLinstener(KeyLinstener) 控制是否将的URL、email等地址自动转换为可单击的链接 android:linksClickable setLinksClickable(boolean) 控制该文本框的URL、email等链接是否具可以点击 android:capitalize setKeyLinstener(KeyLinstener) 控制是否将用户输入的文本转换为大写字母 android:cursorVisible setCursorVisiblek(boolean) 设置该文本框的光标是否可见 android:drawableBottom setCompoundDrawablesWithIntrinsicBounds(Drawable,Drawable,Drawable,Drawable) 在文本框底端处绘制图像 android:drawableTop setCompoundDrawablesWithIntrinsicBounds(Drawable,Drawable,Drawable,Drawable) 在文本框顶端处绘制图像 android:drawableEnd setCompoundDrawablesWithIntrinsicBounds(Drawable,Drawable,Drawable,Drawable) 在文本框结尾处绘制图像 android:drawableLeft setCompoundDrawablesWithIntrinsicBounds(Drawable,Drawable,Drawable,Drawable) 在文本框左边处绘制图像 android:drawableRight setCompoundDrawablesWithIntrinsicBounds(Drawable,Drawable,Drawable,Drawable) 在文本框右边处绘制图像 android:drawablePadding setCompoundDrawablesWithIntrinsicBounds(Drawable,Drawable,Drawable,Drawable) 设置文本框内文本与图形的间距 android:drawableStart setCompoundDrawablesWithIntrinsicBounds(Drawable,Drawable,Drawable,Drawable) 在文本框开始处绘制图像 android:editable 设置文本框是否允许被编辑 android:ellipsize setEllipsize(TextUitls,TruncateAt) 当显示文本超过了TextView的宽度时，如何处理文本 android:ems setEms(int) 设置文本框的宽度 android:height setHeight(int) 设置文本框的高度 android:fontFamily setTypeface(Typeface) 设置文本框内文本的字体 android:gravity setGravity(int) 设置文本框内文本的对齐方式 android:hint setHint(int) 设置文本框内容为空时，文本框内默认显示的提示文字 android:inputType setRawInputType(int) 设置文本框输入方式 android:lines setLines(int) 设置文本框默认占几行 android:maxEms setMaxEms(int) 设置文本框最大宽度 android:maxHeight setMaxHeight(int) 设置文本框最大高度 android:maxLenghth setMaxLenghth(int) 设置文本框最大字符长度 android:maxWidth setMaxWidth(int) 设置文本框最大宽度 android:maxLines setMaxLines(int) 设置文本框最多占几行 android:maxEms setMaxEms(int) 设置文本框最小宽度 android:minHeight setMinHeight(int) 设置文本框最小高度 android:minLenghth setMinxLenghth(int) 设置文本框最小长度 android:minWidth setMinWidth(int) 设置文本框最小宽度 android:minLines setMinLines(int) 设置文本框最少占几行 android:passwordd setTransformatinMethod(TransformatinMethod) 设置文本框是一个密码框 android:phoneNumber setKeyListener(KeyListener) 设置文本框只接受电话号码 android:scrollHorizontally setHorizontallyScrolling(boolean) 设置文本框不够显示全部内容时是否允许水平滚动 android:selectAllOnFocus setSelectAllOnFocus(boolean) 如果文本框内的内容可选择，设置是否当它获得焦点时自动选择所有文本 android:shawdowColor setshadowLayer(float,float,float,int) 设置文本框内文本的阴影的颜色 android:shawdowDx setshadowLayer(float,float,float,int) 设置文本框内文本的阴影在水平方向的偏移 android:shawdowDy setshadowLayer(float,float,float,int) 设置文本框内文本的阴影在垂直方向的偏移 android:shawdowRadius setshadowLayer(float,float,float,int) 设置文本框内文本的阴影的模糊程度，值越大，阴影越模糊 android:singleLine setTransformationMethod() 设置文本框是否为单行模式 android:text setText(CharSequence) 设置是否将文本框文本的内容 android:textAllCaps setAllCaps(boolean) 设置是否将文本框中所有字幕显示为大写字母 android:textAppearance 设置文本框的颜色、字体、大小等样式 android:textColor setTextColor(ColorStateList) 设置文本框中文本的颜色 android:textColorHighlight setHighlightColor(int) 设置文本框被选中时的颜色 android:textColorHint setHintTextColor(int) 设置文本框中提示文本的颜色 android:textColorLink setLinkTextColor(int) 设置文本框中链接的颜色 android:textIsSelectable setTextSelectedable() 设置该文本框不能编辑时，文本框内的文本是否可以被选中 android:textSize setTextSize(float) 设置文本框的字体大小 android:textStyle setTypeface(Typeface) 设置文本框内字体风格，如粗体、斜体等 android:width setWidth(int) 设置该文本框的宽度 加载图片1TextView.setText(CharSequence text) 由于TextView.setText传入的是CharSequence类型，那就可以配合CharSequence的子类Spanned及Html.fromHtml方法实现图片加载显示的功能。 具体的代码也很简单 123//使用Html.fromHtml解析标签， //asyncImageGetter用于加载img标签图片资源 Spanned spanned = Html.fromHtml(text, asyncImageGetter, null); 123public interface OnImageClickListener &#123; void imageClicked(List&lt;String&gt; imageUrls, int position); &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172 /** * 加载图片资源 */ private Html.ImageGetter asyncImageGetter = new Html.ImageGetter() &#123; @Override public Drawable getDrawable(String source) &#123; final URLDrawable urlDrawable = new URLDrawable(getContext()); if (source.contains("storage/emulated") || source.toLowerCase().contains("/sdcard/")) &#123; source = "file://" + source; &#125; else if (source.startsWith("http://")) &#123;// source = source; &#125; else &#123; source = "http://www.nhtzj.com" + source; &#125; mLoader.loadImage(source, options, new SimpleImageLoadingListener() &#123; @Override public void onLoadingStarted(String imageUri, View view) &#123; urlDrawable.setBounds(placeHolder.getBounds()); urlDrawable.setDrawable(placeHolder); &#125; @Override public void onLoadingFailed(String imageUri, View view, FailReason failReason) &#123; urlDrawable.setBounds(errorImage.getBounds()); urlDrawable.setDrawable(errorImage); &#125; @Override public void onLoadingComplete(String imageUri, View view, Bitmap loadedImage) &#123; super.onLoadingComplete(imageUri, view, loadedImage); int width; int height; //Bitmap转成Drawable Drawable drawable = new BitmapDrawable(getContext().getResources(), loadedImage); float imgH = (float) loadedImage.getHeight(); float imgW = (float) loadedImage.getWidth(); //根据需求调整图片大小， //我这边是将图片调整为适应屏幕宽度// if (imgW &gt; viewWidth) &#123; width = viewWidth; height = (int) (width * (imgH / imgW));// &#125; else &#123;// width = (int) imgW;// height = (int) imgH;// &#125; drawable.setBounds(0, 0, width, height); urlDrawable.setBounds(0, 0, screenWidth, height + 5); urlDrawable.setDrawable(drawable); RichText.this.setText(getText()); &#125; @Override public void onLoadingCancelled(String imageUri, View view) &#123; super.onLoadingCancelled(imageUri, view); urlDrawable.setBounds(errorImage.getBounds()); urlDrawable.setDrawable(errorImage); &#125; &#125;); return urlDrawable; &#125; &#125;; asyncImageGetter为Html.ImageGetter 接口的一个实例，用于加载文本中的图片。 实现其中getDrawable方法，该方法的参数String source为img标签上的图片地址。 我这边使用了Universal Image Loader去加载图片。 设置图片点击回调这个有点问题，请大家帮忙解决下。 就是点击图片的位置position不正确。 代码如下： 123456SpannableStringBuilder spannableStringBuilder; if (spanned instanceof SpannableStringBuilder) &#123; spannableStringBuilder = (SpannableStringBuilder) spanned; &#125; else &#123; spannableStringBuilder = new SpannableStringBuilder(spanned); &#125; 12345678910111213141516171819202122232425262728293031//获取img标签，设置图片的点击事件及回调 ImageSpan[] imageSpans = spannableStringBuilder.getSpans(0, spannableStringBuilder.length(), ImageSpan.class); final List&lt;String&gt; imageUrls = new ArrayList&lt;&gt;(); for (int i = 0, size = imageSpans.length; i &lt; size; i++) &#123; ImageSpan imageSpan = imageSpans[i]; final String imageUrl = imageSpan.getSource(); int start = spannableStringBuilder.getSpanStart(imageSpan); int end = spannableStringBuilder.getSpanEnd(imageSpan); imageUrls.add(imageUrl); final int iFinal = i; ClickableSpan clickableSpan = new ClickableSpan() &#123; @Override public void onClick(View widget) &#123; if (onImageClickListener != null) &#123; onImageClickListener.imageClicked(imageUrls, iFinal); &#125; &#125; &#125;; //去除在图片间默认的点击效果 ClickableSpan[] clickableSpans = spannableStringBuilder.getSpans(start, end, ClickableSpan.class); if (clickableSpans != null &amp;&amp; clickableSpans.length != 0) &#123; for (ClickableSpan cs : clickableSpans) &#123; spannableStringBuilder.removeSpan(cs); &#125; &#125; spannableStringBuilder.setSpan(clickableSpan, start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); &#125; 先将加载图片-fromHtml中返回的spanned转成SpannableStringBuilder，用以添加点击回调ClickableSpan。之后便是从spannableStringBuilder中获取img标签，设置图片的点击事件及回调。代码中也写了部分注释，便于理解。 这段代码就是会产生点击图片回调的position会错位，请大神们帮忙看看。 设置链接点击事件及回调123public interface OnUrlClickListener &#123; void urlClicked(String url);&#125; 1234567891011121314151617181920212223242526 //获取a标签，设置点击事件及回调 URLSpan[] urls = spannableStringBuilder.getSpans(0, spannableStringBuilder.length(), URLSpan.class); for (URLSpan span : urls) &#123; setLinkClickable(spannableStringBuilder, span); &#125;/** * 设置链接点击回调 * * @param clickableHtmlBuilder * @param urlSpan */ private void setLinkClickable(SpannableStringBuilder clickableHtmlBuilder, URLSpan urlSpan) &#123; int start = clickableHtmlBuilder.getSpanStart(urlSpan); int end = clickableHtmlBuilder.getSpanEnd(urlSpan); int flags = clickableHtmlBuilder.getSpanFlags(urlSpan); final String url = urlSpan.getURL(); ClickableSpan clickableSpan = new ClickableSpan() &#123; public void onClick(View view) &#123; onUrlClickListener.urlClicked(url); &#125; &#125;; //将原有链接点击效果去除，因为TextView会调用URLSpan.onClick()方法进行网页跳转 clickableHtmlBuilder.removeSpan(urlSpan); clickableHtmlBuilder.setSpan(clickableSpan, start, end, flags); &#125; URLSpan源码 1234567891011121314151617public class URLSpan extends ClickableSpan implements ParcelableSpan &#123; ··· @Override public void onClick(View widget) &#123; Uri uri = Uri.parse(getURL()); Context context = widget.getContext(); Intent intent = new Intent(Intent.ACTION_VIEW, uri); intent.putExtra(Browser.EXTRA_APPLICATION_ID, context.getPackageName()); try &#123; context.startActivity(intent); &#125; catch (ActivityNotFoundException e) &#123; Log.w("URLSpan", "Actvity was not found for intent, " + intent.toString()); &#125; &#125;&#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314&lt;pre&gt; * author : Haitao * blog : https://www.nhtzj.com * time : 2018/5/21 * desc : 简单富文本 * version: 2.0 * &lt;/pre&gt; */public class RichText extends AppCompatTextView &#123; private ImageLoader mLoader; private DisplayImageOptions options; private int screenWidth; private int viewWidth; private int widthExp; private Drawable placeHolder, errorImage;//占位图、出错图 private OnImageClickListener onImageClickListener;//图片点击回调 private OnUrlClickListener onUrlClickListener;//URL点击回调 public RichText(Context context) &#123; this(context, null); &#125; public RichText(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public RichText(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context, attrs); &#125; private void init(Context context, AttributeSet attrs) &#123; TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.RichText); placeHolder = typedArray.getDrawable(R.styleable.RichText_placeHolder); errorImage = typedArray.getDrawable(R.styleable.RichText_errorImage); if (placeHolder == null) &#123; placeHolder = new ColorDrawable(Color.GRAY); &#125; if (errorImage == null) &#123; errorImage = new ColorDrawable(Color.GRAY); &#125; typedArray.recycle(); mLoader = ImageLoader.getInstance(); options = new DisplayImageOptions.Builder() .showImageForEmptyUri(R.drawable.icon_pic_rec) .showImageOnFail(R.drawable.icon_pic_rec) .resetViewBeforeLoading(true) .cacheOnDisc(true) .imageScaleType(ImageScaleType.IN_SAMPLE_INT) .bitmapConfig(Bitmap.Config.RGB_565) .displayer(new FadeInBitmapDisplayer(300)) .build(); screenWidth = (int) TDevice.getScreenWidth(); viewWidth = (int) (screenWidth - TDevice.dp2px(15)); screenWidth = (int) (screenWidth - TDevice.dp2px(25)); //设置Textview内的链接可点击，且Textview可滑动 setMovementMethod(LinkMovementMethod.getInstance()); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int widthMode = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); if (widthMode == MeasureSpec.EXACTLY) &#123; // Parent has told us how big to be. So be it. widthExp = widthSize; &#125; else &#123; widthExp = widthSize; &#125; &#125; @Override protected void onDetachedFromWindow() &#123; super.onDetachedFromWindow(); this.setText(null); &#125; /** * 设置要显示的富文本内容 * * @param text 内容 */ public void setRichText(String text) &#123; //使用Html.fromHtml解析标签， //asyncImageGetter用于加载img标签图片资源 Spanned spanned = Html.fromHtml(text, asyncImageGetter, null); SpannableStringBuilder spannableStringBuilder; if (spanned instanceof SpannableStringBuilder) &#123; spannableStringBuilder = (SpannableStringBuilder) spanned; &#125; else &#123; spannableStringBuilder = new SpannableStringBuilder(spanned); &#125; //获取a标签，设置点击事件及回调 URLSpan[] urls = spannableStringBuilder.getSpans(0, spannableStringBuilder.length(), URLSpan.class); for (URLSpan span : urls) &#123; setLinkClickable(spannableStringBuilder, span); &#125; //获取img标签，设置图片的点击事件及回调 ImageSpan[] imageSpans = spannableStringBuilder.getSpans(0, spannableStringBuilder.length(), ImageSpan.class); final List&lt;String&gt; imageUrls = new ArrayList&lt;&gt;(); for (int i = 0, size = imageSpans.length; i &lt; size; i++) &#123; ImageSpan imageSpan = imageSpans[i]; final String imageUrl = imageSpan.getSource(); int start = spannableStringBuilder.getSpanStart(imageSpan); int end = spannableStringBuilder.getSpanEnd(imageSpan); imageUrls.add(imageUrl); final int iFinal = i; ClickableSpan clickableSpan = new ClickableSpan() &#123; @Override public void onClick(View widget) &#123; if (onImageClickListener != null) &#123; onImageClickListener.imageClicked(imageUrls, iFinal); &#125; &#125; &#125;; //去除在图片间默认的点击效果 ClickableSpan[] clickableSpans = spannableStringBuilder.getSpans(start, end, ClickableSpan.class); if (clickableSpans != null &amp;&amp; clickableSpans.length != 0) &#123; for (ClickableSpan cs : clickableSpans) &#123; spannableStringBuilder.removeSpan(cs); &#125; &#125; spannableStringBuilder.setSpan(clickableSpan, start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); &#125; super.setText(spanned); &#125; /** * 设置链接点击回调 * * @param clickableHtmlBuilder * @param urlSpan */ private void setLinkClickable(SpannableStringBuilder clickableHtmlBuilder, URLSpan urlSpan) &#123; int start = clickableHtmlBuilder.getSpanStart(urlSpan); int end = clickableHtmlBuilder.getSpanEnd(urlSpan); int flags = clickableHtmlBuilder.getSpanFlags(urlSpan); final String url = urlSpan.getURL(); ClickableSpan clickableSpan = new ClickableSpan() &#123; public void onClick(View view) &#123; onUrlClickListener.urlClicked(url); &#125; &#125;; //将原有链接点击效果去除，因为TextView会调用URLSpan.onClick()方法进行网页跳转 clickableHtmlBuilder.removeSpan(urlSpan); clickableHtmlBuilder.setSpan(clickableSpan, start, end, flags); &#125; /** * 加载图片资源 */ private Html.ImageGetter asyncImageGetter = new Html.ImageGetter() &#123; @Override public Drawable getDrawable(String source) &#123; final URLDrawable urlDrawable = new URLDrawable(getContext()); if (source.contains("storage/emulated") || source.toLowerCase().contains("/sdcard/")) &#123; source = "file://" + source; &#125; else if (source.startsWith("http://")) &#123;// source = source; &#125; else &#123; source = "http://www.nhtzj.com" + source; &#125; mLoader.loadImage(source, options, new SimpleImageLoadingListener() &#123; @Override public void onLoadingStarted(String imageUri, View view) &#123; urlDrawable.setBounds(placeHolder.getBounds()); urlDrawable.setDrawable(placeHolder); &#125; @Override public void onLoadingFailed(String imageUri, View view, FailReason failReason) &#123; urlDrawable.setBounds(errorImage.getBounds()); urlDrawable.setDrawable(errorImage); &#125; @Override public void onLoadingComplete(String imageUri, View view, Bitmap loadedImage) &#123; super.onLoadingComplete(imageUri, view, loadedImage); int width; int height; //Bitmap转成Drawable Drawable drawable = new BitmapDrawable(getContext().getResources(), loadedImage); float imgH = (float) loadedImage.getHeight(); float imgW = (float) loadedImage.getWidth(); //根据需求调整图片大小， //我这边是将图片调整为适应屏幕宽度// if (imgW &gt; viewWidth) &#123; width = viewWidth; height = (int) (width * (imgH / imgW));// &#125; else &#123;// width = (int) imgW;// height = (int) imgH;// &#125; drawable.setBounds(0, 0, width, height); urlDrawable.setBounds(0, 0, screenWidth, height + 5); urlDrawable.setDrawable(drawable); RichText.this.setText(getText()); &#125; @Override public void onLoadingCancelled(String imageUri, View view) &#123; super.onLoadingCancelled(imageUri, view); urlDrawable.setBounds(errorImage.getBounds()); urlDrawable.setDrawable(errorImage); &#125; &#125;); return urlDrawable; &#125; &#125;; /** * 缩放图片 * @param bitmap * @param scale * @return */ private static Bitmap small(Bitmap bitmap, float scale) &#123; Matrix matrix = new Matrix(); matrix.postScale(scale, scale); //长和宽放大缩小的比例 return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true); &#125; public static class URLDrawable extends BitmapDrawable &#123; private Drawable drawable; public URLDrawable(Context context) &#123;// drawable = context.getResources().getDrawable(R.drawable.icon_pic_rec); &#125; @Override public void draw(Canvas canvas) &#123; if (drawable != null) drawable.draw(canvas); &#125; public void setDrawable(Drawable drawable) &#123; this.drawable = drawable; &#125; &#125; /** * 设置加载等待图 * * @param placeHolder */ public void setPlaceHolder(Drawable placeHolder) &#123; this.placeHolder = placeHolder; &#125; /** * 设置加载错误图 * * @param errorImage */ public void setErrorImage(Drawable errorImage) &#123; this.errorImage = errorImage; &#125; /** * 设置图片点击回调 * * @param onImageClickListener */ public void setOnImageClickListener(OnImageClickListener onImageClickListener) &#123; this.onImageClickListener = onImageClickListener; &#125; /** * 设置链接点击回调 * * @param onUrlClickListener */ public void setOnUrlClickListenerListener(OnUrlClickListener onUrlClickListener) &#123; this.onUrlClickListener = onUrlClickListener; &#125; public interface OnImageClickListener &#123; void imageClicked(List&lt;String&gt; imageUrls, int position); &#125; public interface OnUrlClickListener &#123; void urlClicked(String url); &#125; 代码RichText 点击查看源码 推荐最后推荐一个不错的富文本框架 RichText Android平台下的富文本解析器，支持Html和Markdown]]></content>
      <categories>
        <category>android</category>
        <category>view</category>
        <category>TextView</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>TextView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android获取应用是否开启通知栏及跳转到设置界面]]></title>
    <url>%2F310044164%2F</url>
    <content type="text"><![CDATA[判断通知权限方式一在代码中通过NotificationManagerCompat包获取是否打开了通知显示权限： 12NotificationManagerCompat manager = NotificationManagerCompat.from(App.getInstance().getContext());boolean isOpened = manager.areNotificationsEnabled(); NotificationManagerCompat位于v4包内，所以需要引入v4包。 要注意的是，areNotificationsEnabled方法的有效性官方只最低支持到API 19，低于19的仍可调用此方法不过只会返回true，即默认为用户已经开启了通知。 查了各种资料，目前暂时没有办法获取19以下的系统是否开启了某个App的通知显示权限。 方式二通过反射获取通知栏是否显示 最低支持到API 19，android8.0上返回的都是true 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 获取通知栏权限是否开启 * */public class NotificationsUtils &#123; private static final String CHECK_OP_NO_THROW = "checkOpNoThrow"; private static final String OP_POST_NOTIFICATION = "OP_POST_NOTIFICATION"; @SuppressLint("NewApi") public static boolean isNotificationEnabled(Context context) &#123; AppOpsManager mAppOps = (AppOpsManager) context.getSystemService(Context.APP_OPS_SERVICE); ApplicationInfo appInfo = context.getApplicationInfo(); String pkg = context.getApplicationContext().getPackageName(); int uid = appInfo.uid; Class appOpsClass = null; /* Context.APP_OPS_MANAGER */ try &#123; appOpsClass = Class.forName(AppOpsManager.class.getName()); Method checkOpNoThrowMethod = appOpsClass.getMethod(CHECK_OP_NO_THROW, Integer.TYPE, Integer.TYPE, String.class); Field opPostNotificationValue = appOpsClass.getDeclaredField(OP_POST_NOTIFICATION); int value = (Integer) opPostNotificationValue.get(Integer.class); return ((Integer) checkOpNoThrowMethod.invoke(mAppOps, value, uid, pkg) == AppOpsManager.MODE_ALLOWED); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; return false; &#125;&#125; 打开应用详情界面123456// 根据isOpened结果，判断是否需要提醒用户跳转AppInfo页面，去打开App通知权限Intent intent = new Intent();intent.setAction(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);Uri uri = Uri.fromParts("package", App.getInstance().getApplication().getPackageName(), null);intent.setData(uri);startActivity(intent); 打开应用通知设置界面12345678910111213if (android.os.Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; Intent intent = new Intent(); intent.setAction("android.settings.APP_NOTIFICATION_SETTINGS"); intent.putExtra("app_package", getActivity().getPackageName()); intent.putExtra("app_uid", getActivity().getApplicationInfo().uid); startActivity(intent);&#125; else if (android.os.Build.VERSION.SDK_INT == Build.VERSION_CODES.KITKAT) &#123; Intent intent = new Intent(); intent.setAction(Settings.ACTION_APPLICATION_DETAILS_SETTINGS); intent.addCategory(Intent.CATEGORY_DEFAULT); intent.setData(Uri.parse("package:" + getActivity().getPackageName())); startActivity(intent);&#125;]]></content>
      <categories>
        <category>android</category>
        <category>通知</category>
      </categories>
      <tags>
        <tag>通知栏</tag>
        <tag>设置</tag>
        <tag>通知设置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIUI神隐模式讲解及使用]]></title>
    <url>%2F567145189%2F</url>
    <content type="text"><![CDATA[神隐模式介绍神隐模式 是MIUI7上正式推出的一项功能，位于 设置-电量和性能中。该入口界面如下所示：可以看到MIUI对该功能做了简单描述：控制后台行为，大幅节约电量其实就是限制app在后台的行为。分别介绍一下神隐模式各界面。 神隐模式 主界面。打开/关闭神隐模式 神隐模式 应用配置界面安装的App列表 神隐模式 具体App配置界面配置App后台模式，共4种 无限制 智能限制后台运行 后台运行超过10分钟后关闭 禁止后台运行 代码控制跳转用代码直接跳转到神隐模式的指定界面 跳转到神隐模式-应用配置列表12345678910111213141516/** * 跳转到神隐模式-应用配置列表 * * @param context &#123;@link Context&#125; * @return &#123;@code true&#125; 跳转成功，&#123;@code false&#125; 跳转失败 */public static boolean toHiddenAppList(Context context) &#123; try &#123; Intent intent = new Intent("miui.intent.action.POWER_HIDE_MODE_APP_LIST"); context.startActivity(intent); return true; &#125; catch (Exception ex) &#123; ex.printStackTrace(); return false; &#125;&#125; 跳转到神隐模式-应用配置123456789101112131415161718192021222324252627282930313233/** * 跳转到神隐模式-应用配置-给定包名应用详细配置界面 * 本方法不适合用&#123;@link android.app.Activity#startActivityForResult(Intent, int)&#125;方法，因为无论 * 用户如何选择，返回结果均为-1。 * 测试机型红米4X，MIUI 9 7.11.2开发板 * * @param context &#123;@link Context&#125; * @param packageName 包名 * @param label 应用名 * @return &#123;@code true&#125; 跳转成功，&#123;@code false&#125; 跳转失败 */public static boolean toConfigApp(Context context, String packageName, String label) &#123; try &#123; Intent intent = new Intent("miui.intent.action.HIDDEN_APPS_CONFIG_ACTIVITY"); intent.putExtra("package_name", packageName); intent.putExtra("package_label", label); context.startActivity(intent); return true; &#125; catch (Exception ex) &#123; ex.printStackTrace(); return false; &#125;&#125;/** * 跳转到神隐模式-当前应用配置 * * @param context * @return */public static boolean toConfigApp(Context context) &#123; return toConfigApp(context, BuildConfig.APPLICATION_ID, context.getResources().getString(R.string.app_name));&#125; ROM判断由于神隐模式是MIUI定制的功能，所以只有在MIUI系统上有该功能，且需要MIUI7及以上版本。 接下来介绍使用shell命令获取当前ROM是否为MIUI 主要是使用了系统的Runtime.getRuntime().exec()方法。 判断ROM是否是MIUI的命令为：getprop ro.miui.ui.version.name 如果是MIUI版本，则会返回MIUI版本号。 比如，我的设备上的MIUI为：MIUI 8 7.4.27|开发版，则上述命令返回：V8 。 关于Shell的工具类已上传，可自行查看ShellUtils源码 参考跳转MIUI神隐模式列表以及具体设置界面AndroidUtilCode 检测ROM类型]]></content>
      <categories>
        <category>系统</category>
        <category>MIUI</category>
      </categories>
      <tags>
        <tag>MIUI</tag>
        <tag>神隐模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo使用NexT主题及配置]]></title>
    <url>%2F2345860311%2F</url>
    <content type="text"><![CDATA[前言前篇Hexo初次使用及部署到云服务器详细指南介绍了Hexo相关的一些配置。本篇就趁热打铁，整理介绍一下Hexo上热度非常高的一款主题NexT。 NexT安装Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。主题文件的下载主要有两种： NexT主题zip文件下载，解压到站点目录的 themes 目录下 Git 克隆最新版本 小编使用的安装方式是第二种。 进入本地博客根目录 小编的博客根目录为/Users/nht/WorkSpace/blog/hexo 该目录下有如下文件 123456➜ hexo pwd/Users/nht/WorkSpace/blog/hexo➜ hexo ls_config.yml node_modules public themesdb.json package-lock.json scaffoldsdebug.log package.json source 前往 NexT 版本 页面 下载最新稳定版 12$ mkdir themes/next$ curl -s https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest | grep tarball_url | cut -d '"' -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1 这样，NexT的最新稳定版代码就通过Git下载到themes/next 目录下了。 如果想要切换NexT的版本，可以按如下步骤： 1. 进入NexT主题文件目录，`cd themes/next` 2. 查看当前有哪些版本，`git tag` 3. 切换至指定tag代码，比如切换至最新版`v5.1.4` ,`git checkout tags/v5.1.4` 修改 站点配置文件_config.yml 1theme: next 配置完成，运行博客站点查看 1hexo g &amp;&amp; hexo s NexT主题配置在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。 选择 SchemeScheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。目前 NexT 支持三种 Scheme，他们是： Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 Gemini-双栏 Scheme，另一种样式 小编当前使用的是Gemini123456789# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes# scheme: Muse# scheme: Mist# scheme: Piscesscheme: Gemini 设置 「语言」编辑 站点配置文件， 将 language 设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下： 1language: zh-Hans 目前 NexT 支持的语言如以下表格所示： 语言 代码 设定示例 English en language: en 简体中文 zh-Hans language: zh-Hans Français fr-FR language: fr-FR Português pt language: pt or language: pt-BR 繁體中文 zh-hk 或者 zh-tw language: zh-hk Русский язык ru language: ru Deutsch de language: de 日本語 ja language: ja Indonesian id language: id Korean ko language: ko 设置 「菜单」点击查看官方文档 设置 「菜单」 设置 「侧栏」点击查看官方文档 设置 「侧栏」 设置 「头像」点击查看官方文档 设置 「头像」 设置 「作者昵称」点击查看官方文档 设置 「作者昵称」 设置 「站点描述」点击查看官方文档 设置 「站点描述」 进阶&amp;修改设置摘录默认情况下，首页上显示的是文章的所有内容，可以将NexT主题的_config.yml文件中的auto_excerpt字段下的enable改为true。 12345# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150 阅读次数统计（LeanCloud）在注册完成LeanCloud帐号并验证邮箱之后，我们就可以登录我们的LeanCloud帐号，进行一番配置之后拿到AppID以及AppKey 这两个参数即可正常使用文章阅读量统计的功能了。 配置LeanCloud 创建应用。输入应用名称，选择应用计价方案（开发版） 进入刚创建的应用 点击最左侧存储 标签 点击数据 项 点击创建 Class项 输入Class 名称 Counter ，设置数据条目的默认 ACL 权限 为无限制 点击创建 按钮创建完成之后，左侧数据栏应该会多出一栏名为Counter的栏目 点击最左侧设置 标签 点击应用Key 项可以看到App ID、App Key、App ID 三项复制App ID以及App Key并在NexT主题的_config.yml文件中我们相应的位置填入即可，正确配置之后文件内容像这个样子: 123456# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: gaKW5SWAvf7NBolU9wFbxN8O-gzGxoHsz app_key: susRJyHS8Fq1SyKXg0r9ad65 这个时候重新生成部署Hexo博客，应该就可以正常使用文章阅读量统计的功能了。需要特别说明的是：记录文章访问量的唯一标识符是文章的发布日期以及文章的标题，因此请确保这两个数值组合的唯一性，如果你更改了这两个数值，会造成文章阅读数值的清零重计。 后台管理当你配置部分完成之后，初始的文章统计量显示为0，但是这个时候我们LeanCloud对应的应用的Counter表中并没有相应的记录，只是单纯的显示为0而已，当博客文章在配置好阅读量统计服务之后第一次打开时，便会自动向服务器发送数据来创建一条数据，该数据会被记录在对应的应用的Counter表中。 我们可以修改其中的time字段的数值来达到修改某一篇文章的访问量的目的（博客文章访问量快递提升人气的装逼利器）。双击具体的数值，修改之后回车即可保存。 url字段被当作唯一ID来使用，因此如果你不知道带来的后果的话请不要修改。 title字段显示的是博客文章的标题，用于后台管理的时候区分文章之用，没有什么实际作用。 其他字段皆为自动生成，具体作用请查阅LeanCloud官方文档，如果你不知道有什么作用请不要随意修改。 Web安全因为AppID以及AppKey是暴露在外的，因此如果一些别用用心之人知道了之后用于其它目的是得不偿失的，为了确保只用于我们自己的博客，建议开启Web安全选项，这样就只能通过我们自己的域名才有权访问后台的数据了，可以进一步提升安全性。 选择应用的设置的安全中心选项卡 在Web 安全域名中填入我们自己的博客域名，来确保数据调用的安全 添加评论系统NexT 支持多款评论系统，包括Disqus，Facebook Comments，HyperComments ，网易云跟帖，来必力，Valine 等 如需取消某个 页面/文章 的评论，在 md 文件的 front-matter 中增加 comments: false 小编由于阅读次数统计用了LearnCloud，所以评论系统使用了Valine。 Valine一款快速、简洁且高效的无后端评论系统。 如需集成其他评论系统，请查阅官方文档 评论系统。 具体操作 登录LeanCloud，获取之前创建好的app的App ID和App Key 修改 主题配置文件，将App ID和App Key 填入，enable改为true 。具体代码如下： 12345678910111213# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: true appid: gaKW5SWAvf7NBolU9wFbxN8O-gzGxoHsz appkey: susRJyHS8Fq1SyKXg0r9ad65 notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: 您的评论可以一针见血 (*^ω^*)~~ # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size 隐藏 Powered By ValineValine默认样式如下： 其中Code 403 是因为给LeanCloud添加了Web 安全域名，而本地调试无法加进去，这个在正式平台上是不会有的。 对于有些许强迫症的小编而言，怎么能忍受这个呢！必须隐藏掉！必须隐藏掉！必须隐藏掉！ 查看Elements可以看到这个div，那么我只要移除这个div下的所有子节点，就可以去掉这个Powered By了。修改对应的文件valine.swig（路径：站点跟路径/themes/next/layout/_third-party/comments/valine.swig），直接上代码： 12345678910111213141516 ··· new Valine(&#123; ··· pageSize:&apos;&#123;&#123; theme.valine.pageSize &#125;&#125;&apos; || 10, &#125;);//新增以下代码即可，可以移除.info下所有子节点。var infoEle = document.querySelector(&apos;#comments .info&apos;);if (infoEle &amp;&amp; infoEle.childNodes &amp;&amp; infoEle.childNodes.length &gt; 0)&#123; infoEle.childNodes.forEach(function(item) &#123; item.parentNode.removeChild(item); &#125;);&#125; &lt;/script&gt;&#123;% endif %&#125; Ok~大功告成 赶紧去看看效果吧～ 修改页面底部显示内容隐藏”NexT.Pisces v5.1.4”修改主题配置文件。 将footer内的theme内的enable改为false即可。 添加备案号我的备案号为浙ICP备17020869号 大家可以替换为你们的备案号。 打开文件博客根目录/themes/next/layout/_partials/footer.swig 替换{ % if theme.footer.powered %}和{ % endif %}之间的显示内容为如下 12345&#123;% if theme.footer.powered %&#125; &lt;div class=&quot;powered-by&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;http://www.miitbeian.gov.cn/&quot; rel=&quot;external nofollow&quot; title=&quot;工业和信息化部ICP/IP地址/域名信息备案管理系统&quot;&gt;浙ICP备17020869号&lt;/a&gt;&apos;) &#125;&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125; 显示返回顶部和当前阅读进度修改 主题配置文件，将b2t和scrollpercent两个字段设为true即可。 b2t的功能只适用于 Pisces 和Gemini这两个NexT的主题样式。 由于scrollpercent是显示在b2t按钮上面的，所以如果需要显示scrollpercent就必须将b2t也同时设为true。 12345# Back to top in sidebar (only for Pisces | Gemini).b2t: true# Scroll percent label in b2t button.scrollpercent: true 添加css样式可以看到上文中的站点配置文件和 主题配置文件使用了自己编写的css样式。 这里就和大家简单说明一下如何实现添加自定义的css样式。 其实很简单，NexT主题已经给我们做好了准备，您只需要到本地博客地址/themes/next/source/css/_custom/打开custom.styl文件，编写css样式就OK了。之后就可以在博客文章中使用了。 custom.styl 123456789101112131415161718192021// Custom styles..label &#123; display: inline; padding: .2em .6em .3em; font-size: 75%; font-weight: 700; line-height: 1; color: #fff; text-align: center; white-space: nowrap; vertical-align: baseline; border-radius: 0;&#125;.label-primary &#123; background-color: #2780e3;&#125;.label-info &#123; background-color: #9954bb;&#125; 使用： 12&lt;span class=&quot;label label-primary&quot;&gt;站点配置文件&lt;/span&gt;&lt;span class=&quot;label label-info&quot;&gt;主题配置文件&lt;/span&gt; 效果：站点配置文件主题配置文件 提交Baidu和Google收录一个网站的SEO对一个网站非常重要，SEO指的是搜索引擎优化。通过搜索引擎优化，可以提高网站的网站关键词排名以及博客文章的曝光度。一般来说，我们针对百度和Google这两个搜索引擎进行优化，提高对网站资源的索引量，使我们的文章更容易被发现。虽然我的博客的主要读者是我自己，但也不妨碍我做些优化，对吧！接下来向大家展示如何使博客被百度和Google收录。 搜索引擎收录本站点若未被搜索引擎收录，则需进行以下配置，首先要让搜索引擎先验证我们对网站的所有权，Google和Baidu搜索引擎提交的入口分别为： Google Search Console 百度站长平台 这两个搜索引擎支持多种验证方式，这里介绍其中的两种： HTML 文件上传 HTML 标记 这里就以Google为例，Baidu配置也一样的。 HTML 文件上传 第一步之后，将下载的HTML验证文件放入站点/source/路径下，并打开此验证文件，在其最上面添加以下代码： 12layout: false--- 以告诉Hexo不要将此文件加入到生成的sitemap中。 发布之后，再继续进行第3步。 HTML 标记小编当前的Next版本为5.1.4，该版本已经集成了HTML 标记的验证方式。 查看原标记,将其中content字段引号内的内容拷贝出来 修改主题配置文件。搜索google_site_verification,将上述拷贝的内容复制在该值后面。 123# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/google_site_verification: uW8bwgMGUwIA01nPfItoty1rmtmmuVkOVTeS9O0nAUg 发布后点击该页面上的确认按钮以验证。 Baidu 添加HTML标记关于添加Baidu的HTML标记，NexT主题也集成了,可以在站点跟路径/themes/next/layout/_partials/head.swig文件中看到百度的字段 123&#123;% if theme.baidu_site_verification %&#125; &lt;meta name=&quot;baidu-site-verification&quot; content=&quot;&#123;&#123; theme.baidu_site_verification &#125;&#125;&quot; /&gt;&#123;% endif %&#125; 但是没有在 主题配置文件中添加baidu_site_verification字段。 所以需要自己添加该字段 1baidu_site_verification: NeR7tPD3G2 站点地图站点地图即sitemap， 是一个页面，上面放置了网站上需要搜索引擎抓取的所有页面的链接。站点地图可以告诉搜索引擎网站上有哪些可供抓取的网页，以便搜索引擎可以更加智能地抓取网站。 生成站点地图 安装插件 12cnpm install hexo-generator-sitemap --savecnpm install hexo-generator-baidu-sitemap --save hexo-generator-sitemap:Google站点地图生成插件 hexo-generator-baidu-sitemap：Baidu站点地图生成插件 修改主题配置文件若没有搜到sitemap、baidusitemap 两个字段，则在文件末尾填上如下内容：用于指定站点地图 12345# Google sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 运行本地站点。可发现 站点/public/ 文件夹下生成了sitemap.xml和baidusitemap.xml 两个文件。 发布站点。 1hexo g -d 添加robots.txtrobots.txt（统一小写）是一种存放于网站根目录下的ASCII编码的文本文件，它的作用是告诉搜索引擎此网站中哪些内容是可以被爬取的，哪些是禁止爬取的。 在 source 目录下增加 rebots.txt 文件，网站生成后在网站的根目录(站点目录/public/)下。 （请将域名改为自己的网站） 123456789101112131415User-agent: *Allow: /Allow: /archives/Allow: /tags/Allow: /categories/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: http://www.nhtzj.com/sitemap.xmlSitemap: http://www.nhtzj.com/baidusitemap.xml 搜索引擎添加站点地图添加站点地图，方便搜索引擎抓取站点内容。 以添加到Google为例。 进入站点地图 点击添加/测试站点地图 输入sitemap.xml 点击提交 在提交前可以先测试一下，看看站点地图有没有问题。之后再提交 。 此刻，点击robots.txt测试工具，会发现我们的robots.txt文件也被上传到Google了。并且可以对站点下的网页进行 拦截/抓取 的测试。 Baidu添加sitemap的地址在：数据引入-链接提交（自动提交-sitemap） 。 Url持久化我们可以发现hexo默认生成的文章地址路径是 网站名称/年/月/日/文章名称 它的url结构超过了三层，太深了,对搜索爬虫是很不友好的。 推荐使用hexo-abbrlink，将连接持久化（不会因为修改文章MarkDown文件名而改变文章地址）。 安装 hexo-abbrlink 1cnpm install hexo-abbrlink --save 配置 站点配置文件 123456permalink: :abbrlink/permalink_defaults:# abbrlink configabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: dec # 进制：dec(default) and hex 小编是直接将一级目录设为了文章名，二级格式为permalink: archives/:abbrlink.html ,其中archives 可自行修改 部署一下，就可以看到你的链接变了 添加 nofollow 标签给非友情链接的出站链接添加「nofollow」标签，nofollow 标签是由谷歌领头创新的一个「反垃圾链接」的标签，并被百度、yahoo 等各大搜索引擎广泛支持，引用 nofollow 标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上的带有 nofollow 属性的任何出站链接，以减少垃圾链接的分散网站权重。 首先修改 footer.swig（your-hexo-site\themes\next\layout\_partials)123&apos;&lt;a class=&quot;theme-link&quot; href=&quot;http://hexo.io&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125;改成&#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; href=&quot;http://hexo.io&quot; rel=&quot;external nofollow&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125; 123&lt;a class=&quot;theme-link&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt;改成&lt;a class=&quot;theme-link&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot; rel=&quot;external nofollow&quot;&gt; 再修改 sidebar.swig（your-hexo-site\themes\next\layout\_macro） 123&lt;a href=&quot;&#123;&#123; link &#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt;改成&lt;a href=&quot;&#123;&#123; link &#125;&#125;&quot; target=&quot;_blank&quot; rel=&quot;external nofollow&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt; 123&lt;a href=&quot;http://creativecommons.org/licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0&quot; class=&quot;cc-opacity&quot; target=&quot;_blank&quot;&gt;改成&lt;a href=&quot;http://creativecommons.org/licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0&quot; class=&quot;cc-opacity&quot; target=&quot;_blank&quot; rel=&quot;external nofollow&quot;&gt; 总得来说，就是将所有可能的外链地址填上rel=&quot;external nofollow&quot;字段，提示搜索引擎不要将这类链接收录。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo初次使用及部署到云服务器详细指南]]></title>
    <url>%2F798806741%2F</url>
    <content type="text"><![CDATA[前言之前使用WordPress来搭建个人博客。最近看到许多博客使用hexo并配合Next主题，效果还挺好的。而且Next主题几乎将我需要使用到的功能点包含进去了。还有一个关键性因素是：hexo是使用Markdown来撰写文章的。所以最近几天研究了一下hexo+next主题，便将博客从WordPress迁移了。 Hexo简介Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。由于Hexo最终生成静态网页，所以云服务器端只需要有web服务器（小编使用的是Centos7+Apache）就可以了，另加git，用于将网页从本地发布到云服务器上。关于Hexo的操作都放在本地。 设备 Mac pro 阿里云服务器(Centos7+Apache) Mac Hexo安装安装前提 Node.js GitGit本机上自带有git，就不啰嗦了，推荐可用：Homebrew :brew install git。 安装 Homebrew 将以下命令粘贴至终端1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 安装完成后 我们可以用 brew install 命令来安装我们需要安装的软件(Git)1➜ ~ brew install git 可以用 git --version来检测是否安装了Git12➜ ~ git --versiongit version 2.14.3 (Apple Git-98) 哈哈，结果还是啰嗦了！！ Node.jsNVM安装 nvm终端输入：1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash 12export NVM_DIR="$HOME/.nvm"[ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; \. "$NVM_DIR/nvm.sh" # This loads nvm 判断nvm是否安装12➜ ~ command -v nvmnvm 或者123➜ ~ nvm --version0.33.2nvm command -v命令适用于判断所有应用是否安装，若未安装，则会输出空。 安装Node1nvm install stable 判断node是否安装12➜ ~ node -vv9.2.0 node 安装完成后 npm 自然也就有了 安装 Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。1➜ ~ npm install -g hexo-cli 由于通过npm安装的资源在国外，用npm 安装就非常费时。好在伟大的淘宝团队推出了 “淘宝 NPM 镜像”，解决了这个问题。使用淘宝团队定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:1➜ ~ npm install -g cnpm --registry=https://registry.npm.taobao.org 支持 npm 除了 publish 之外的所有命令。 所以安装Hexo可以替换为：1➜ ~ cnpm install -g hexo-cli -g 或 –global 表示全局安装模块，如果没有这个参数，会安装在当前目录的node_modules子目录下。 建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 若未指定&lt;folder&gt;，则将在当前目录下建站（设为博客文件的根目录）。 新建完成后，指定文件夹的目录如下：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 其中_config.yml为站点配置文件，_posts为文章目录。其他目录介绍可查看官方文档建站 修改_config.yml配置文件12345678910111213# Site 站点信息配置title: 海的那边subtitle: 小小码农description: Android开发过程中的经验积累keywords: Android，app开发author: haitaolanguage: zh-Hanstimezone:# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://www.nhtzj.comroot: / 运行 Hexo现在，一个 Hexo 本地博客已经搭建起来了，你可以在本地运行 生成文件使用 Hexo 生成静态文件1➜ ~ hexo generate hexo generate可简写为hexo g下述中提到有hexo generate的都可简写为hexo g。 监视文件变动Hexo 能够监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。1➜ ~ hexo generate --watch 本地运行1234567891011➜ hexo serverINFO Start processingINFO Generate link 798806741 for post [Hexo初次使用及部署到云服务器详细指南.md]WARN ===============================================================WARN ========================= ATTENTION! ==========================WARN ===============================================================WARN NexT repository is moving here: https://github.com/theme-nextWARN ===============================================================WARN It's rebase to v6.0.0 and future maintenance will resume thereWARN ===============================================================INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 最后一行可知道： 本地服务器地址：http://localhost:4000/ 关闭：Ctrl+C hexo server可简写为hexo s WordPress迁移首先，安装 hexo-migrator-wordpress 插件。1➜ ~ cnpm install hexo-migrator-wordpress --save 在 WordPress 仪表盘中导出数据(“Tools” → “Export” → “WordPress”)（详情参考WP支持页面）。 插件安装完成后，执行下列命令来迁移所有文章。source 可以是 WordPress 导出的文件路径或网址。1➜ ~ hexo migrate wordpress &lt;source&gt; 注意这个插件并不能完美地实现WordPress-&gt;Hexo的数据转换，尤其是在处理WordPress的分类方面存在问题（见Front-matter中的分类与标签）。因此，建议您在迁移完成后，手工审阅所有生成的markdown文件，检查其中是否有错误。对于文章数量较大的WordPress站点，这项工作可能要花很长的时间。 其他博客平台的迁移情参考官方文档迁移 部署Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。1➜ ~ hexo deploy hexo deploy可简写为hexo d 在开始之前，您必须先在 _config.yml 中修改参数，一个正确的部署配置中至少要有 type 参数，例如：12deploy: type: git 您可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer。12345deploy:- type: git repo:- type: heroku repo: 在部署之前尽量先运行hexo clean,将本地清空，再hexo generate和hexo deploy。这三条命令可用&amp;&amp;符号连接，结果如下：1➜ ~ hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy 简写后为1➜ ~ hexo cl &amp;&amp; hexo g &amp;&amp; hexo d hexo g &amp;&amp; hexo d还可简写为hexo g -d Hexo 插件hexo-deployer-git由于我使用的是git管理，所以Hexo需要安装hexo-deployer-git1➜ ~ cnpm install hexo-deployer-git --save 修改配置1234deploy: type: git repository: &lt;git 仓库地址&gt; branch: master 其中&lt;git 仓库地址&gt;在下一章节创建git仓库目录中产生。 其他方式的部署，请参考官方文档部署 云服务器端配置Git安装Git一般云服务器是装有Git的，也可用yum install git命令安装git。也可参考CentOS下搭建Git服务器(基于SSH协议)手动下载最新版git，再进行配置安装。 创建一个 GIT 用户，用来运行 GIT 服务* 创建用户：`adduser git` * 设置密码：`passwd git` 添加证书* 切换到git用户：`su git` * 进入git用户主目录：`cd`或`cd ~` * 创建.ssh目录：`mkdir .ssh &amp;&amp; chmod 700 .ssh` * 创建authorized_keys公钥保存文件：`touch .ssh/authorized_keys &amp;&amp; chmod 600 .ssh/authorized_keys` 接着，我们需要为系统用户 git 的 authorized_keys 文件添加一些开发者 SSH 公钥。 假设我们已经获得了若干受信任的公钥，并将它们保存在临时文件中。 与前文类似，这些公钥看起来是这样的：1234567$ cat /tmp/id_rsa.john.pubssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCB007n/ww+ouN4gSLKssMxXnBOvf9LGt4LojG6rs6hPB09j9R/T17/x4lhJA0F3FR1rP6kYBRsWj2aThGw6HXLm9/5zytK6Ztg3RPKK+4kYjh6541NYsnEAZuXz0jTTyAUfrtU3Z5E003C4oxOj6H0rfIF1kKI9MAQLMdpGW1GYEIgS9EzSdfd8AcCIicTDWbqLAcU4UpkaX8KyGlLwsNuuGztobF8m72ALC/nLF6JLtPofwFBlgc+myivO7TCUSBdLQlgMVOFq1I2uPWQOkOWQAHukEOmfjy2jctxSDBQ220ymjaNsHT4kgtZg2AYYgPqdAv8JggJICUvax2T9va5 gsg-keypair 将这些公钥加入系统用户 git 的 .ssh 目录下 authorized_keys 文件的末尾：1$ cat /tmp/id_rsa.john.pub &gt;&gt; ~/.ssh/authorized_keys 或者直接用echo命令将公钥文件内容追加到authorized_keys文件中（由于公钥文件内容中是没有换行符存在，所以可以用echo追加），如下： 123456$ echo &quot;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCB007n/ww+ouN4gSLKssMxXnBOvf9LGt4LojG6rs6hPB09j9R/T17/x4lhJA0F3FR1rP6kYBRsWj2aThGw6HXLm9/5zytK6Ztg3RPKK+4kYjh6541NYsnEAZuXz0jTTyAUfrtU3Z5E003C4oxOj6H0rfIF1kKI9MAQLMdpGW1GYEIgS9EzSdfd8AcCIicTDWbqLAcU4UpkaX8KyGlLwsNuuGztobF8m72ALC/nLF6JLtPofwFBlgc+myivO7TCUSBdLQlgMVOFq1I2uPWQOkOWQAHukEOmfjy2jctxSDBQ220ymjaNsHT4kgtZg2AYYgPqdAv8JggJICUvax2T9va5 gsg-keypair&quot; &gt;&gt; ~/.ssh/authorized_keys 创建git仓库目录创建一个名为blog的git仓库123mkdir /var/repocd /var/repogit init --bare blog.git 配置 GIT HOOKS1vim /var/repo/blog.git/hooks/post-receive 添加12#!/bin/shgit --work-tree=/var/www/hexo --git-dir=/var/repo/blog.git checkout -f 然后保存退出，并设置权限1chmod +x /var/repo/blog.git/hooks/post-receive 改变 BLOG.GIT 目录的拥有者为 GIT 用户1chown -R git:git blog.git 创建静态文件目录并将创建git仓库目录步骤生成的git仓库链接到静态文件目录下* 创建静态文件目录（文章网页）：mkdir /var/www/hexo * 链接git仓库：chown -R git:git /var/www/hexo * 配置权限：chmod -R 755 /var/www/hexo 这样git仓库更新便会自动同步到hexo目录下 到此步，服务器端的git配件基本完成，此git仓库的地址为git@本服务器ip:/var/repo/blog.git,现在可以回到Hexo 插件hexo-deployer-git,将此地址填入repository:内。注：git仓库的地址格式为git账户@服务器地址:git仓库文件全路径。 为了安全考虑，禁用GIT用户的SHELL 登录权限配置（下面两个步骤非常重要，否则客户端总是提示密码错误！！！） 首先你必须确保 git-shell 已存在于 /etc/shells 文件中 使用命令which git-shell判断系统是否安装了git-shell。如果已经安装，则返回git-shell的安装目录，如：/usr/bin/git-shell；如果未安装则需要安装git-shell命令，安装命令：yum install git 判断shells文件是否存在，判断命令：cat /etc/shells 如果文件不存在或没有/usr/bin/git-shell，则需要使用vim增加这个路径：sudo vim /etc/shells，在最后一行添加git-shell路径 12345678/etc/shells: valid login shells /bin/sh/bin/dash/bin/bash/bin/rbash/usr/bin/tmux/usr/bin/screen/usr/bin/git-shell /usr/bin/git-shell为git-shell路径，故添加进去。 现在你可以使用 chsh 命令修改任一系统用户的shell权限了现在我们修改第一步中创建的git用户的登录权限，禁止git用户使用shell权限：终端中输入sudo chsh git然后在Login Shell [/bin/bash]:后输入git-shell路径/usr/bin/git-shell 修改完成后验证： vim /etc/passwd找到类似git:x:1000:1000:,,,:/home/git:/usr/bin/git-shell，看看git用户是否是以git-shell结尾 这样，git用户就只能使用SSH连接对Git仓库进行推送和拉取操作，而不能登录机器并取得普通shell命令 添加Apache虚拟站点添加Apache虚拟站点，将/var/www/hexo设为该站点根目录。重启apache1systemctl restart httpd 文档 Hexo Git]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android事件分发机制源码解析]]></title>
    <url>%2F2679806526%2F</url>
    <content type="text"><![CDATA[触摸事件传递机制是Android中一块比较重要的知识体系，了解并熟悉整套的传递机制有助于更好的分析各种滑动冲突、滑动失效问题，更好去扩展控件的事件功能和开发自定义控件。 预备知识MotionEvent在Android设备中，触摸事件主要包括点按、长按、拖拽、滑动等，点按又包括单击和双击，另外还包括单指操作和多指操作等。一个最简单的用户触摸事件一般经过以下几个流程： 手指按下 手指滑动 手指抬起 其中，ACTION_DOWN、ACTION_MOVE、ACTION_UP就分别对应于上面的手指按下、手指滑动、手指抬起操作，即一个最简单的用户操作包含了一个ACTION_DOWN事件，若干个ACTION_MOVE事件和一个ACTION_UP事件。 几个方法事件分发过程中，涉及的主要方法有以下几个： dispatchTouchEvent: 用于事件的分发，所有的事件都要通过此方法进行分发，决定是自己对事件进行消费还是交由子View处理 onTouchEvent: 主要用于事件的处理，返回true表示消费当前事件 onInterceptTouchEvent: 是ViewGroup中独有的方法，若返回true表示拦截当前事件，交由自己的onTouchEvent()进行处理，返回false表示不拦截 我们的源码分析也主要围绕这几个方法展开。 源码分析Activity我们从Activity的dispatchTouchEvent方法作为入口进行分析：123456789public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev);&#125; 这个方法首先会判断当前触摸事件的类型，如果是ACTION_DOWN事件，会触发onUserInteraction方法。根据文档注释，当有任意一个按键、触屏或者轨迹球事件发生时，栈顶Activity的onUserInteraction会被触发。如果我们需要知道用户是不是正在和设备交互，可以在子类中重写这个方法，去获取通知（比如取消屏保这个场景）。 然后是调用Activity内部mWindow的superDispatchTouchEvent方法，mWindow其实是PhoneWindow的实例，我们看看这个方法做了什么：PhoneWindow源码链接 12345678public class PhoneWindow extends Window implements MenuBuilder.Callback &#123;... @Overridepublic boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event);&#125;...&#125; DecorView源码链接12345678private final class DecorView extends FrameLayout implements RootViewSurfaceTaker &#123; ... public boolean superDispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event); &#125; ...&#125; 原来PhoneWindow内部调用了DecorView的同名方法，而DecorView其实是FrameLayout的子类，FrameLayout并没有重写dispatchTouchEvent方法，所以事件开始交由ViewGroup的dispatchTouchEvent开始分发了，这个方法将在下一节分析。FrameLayout源码链接 我们回到Activity的dispatchTouchEvent方法，注意当getWindow().superDispatchTouchEvent(ev)这一语句返回false时，即事件没有被任何子View消费时，最终会执行Activity的onTouchEvent：12345678public boolean onTouchEvent(MotionEvent event) &#123; if (mWindow.shouldCloseOnTouch(this, event)) &#123; finish(); return true; &#125; return false;&#125; 小结： 事件从Activity的dispatchTouchEvent开始，经由DecorView开始向下传递，交由子View处理，若事件未被任何Activity的子View处理，将由Activity自己处理。 ViewGroupViewGroup源码链接由上节分析可知，事件来到DecorView后，经过层层调用，来到了ViewGroup的dispatchTouchEvent方法中:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209 @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; ... boolean handled = false; if (onFilterTouchEventForSecurity(ev)) &#123; final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // 若是down事件，则重置参数 if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); &#125; // 先检验事件是否需要被ViewGroup拦截 final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; //校验是否给mGroupFlags设置了FLAG_DISALLOW_INTERCEPT标志位 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; // 走onInterceptTouchEvent判断是否拦截事件 intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; ... // Check for cancelation. final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // Update list of touch targets for pointer down, if needed. final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled &amp;&amp; !intercepted) &#123; View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; // 注意ACTION_DOWN等事件才会走遍历所有子View的流程 if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; ... // 开始遍历所有子View开始逐个分发事件 final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); ... // 判断触摸点是否在这个View的内部 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; ... // 事件被子View消费，退出循环，不再继续分发给其他子View if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; ... // addTouchTarget内部将mFirstTouchTarget设置为child，即不为null newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125;​ &#125; &#125; &#125; &#125; // 事件未被任何子View消费，自己处理 if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; else &#123; // 将MotionEvent.ACTION_DOWN后续事件分发给mFirstTouchTarget指向的View TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) &#123; final TouchTarget next = target.next; // 如果已经在上面的遍历过程中传递过事件，跳过本次传递 if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; handled = true; &#125; else &#123; final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; ... &#125; predecessor = target; target = next; &#125; &#125; // Update list of touch targets for pointer up or cancel, if needed. if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; resetTouchState(); &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123; final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); &#125; &#125; if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); &#125; return handled; &#125; /** * Resets all touch state in preparation for a new cycle. */ private void resetTouchState() &#123; clearTouchTargets(); resetCancelNextUpFlag(this); mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; mNestedScrollAxes = SCROLL_AXIS_NONE; &#125; /** * Clears all touch targets. */ private void clearTouchTargets() &#123; TouchTarget target = mFirstTouchTarget; if (target != null) &#123; do &#123; TouchTarget next = target.next; target.recycle(); target = next; &#125; while (target != null); mFirstTouchTarget = null; &#125; &#125; /** * Adds a touch target for specified child to the beginning of the list. * Assumes the target child is not already present. */ private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) &#123; final TouchTarget target = TouchTarget.obtain(child, pointerIdBits); target.next = mFirstTouchTarget; mFirstTouchTarget = target; return target; &#125; /** * Transforms a motion event into the coordinate space of a particular child view, * filters out irrelevant pointer ids, and overrides its action if necessary. * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead. */ private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; ... // 注意传参child为null时，调用的是自己的dispatchTouchEvent if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; ... handled = child.dispatchTouchEvent(transformedEvent); &#125; return handled; &#125; public boolean onInterceptTouchEvent(MotionEvent ev) &#123; ··· // 默认不拦截事件 return false; &#125; 这个方法比较长，只要把握住主要脉络，修枝剪叶后还是非常清晰的： 判断事件是够需要被ViewGroup拦截首先会根据mGroupFlags判断是否可以执行onInterceptTouchEvent方法，它的值可以通过requestDisallowInterceptTouchEvent方法设置：12345678910111213141516171819@Overridepublic void requestDisallowInterceptTouchEvent(boolean disallowIntercept) &#123; if (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0)) &#123; // We're already in this state, assume our ancestors are too return; &#125; if (disallowIntercept) &#123; mGroupFlags |= FLAG_DISALLOW_INTERCEPT; &#125; else &#123; mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; &#125; // Pass it up to our parent if (mParent != null) &#123; mParent.requestDisallowInterceptTouchEvent(disallowIntercept); &#125;&#125; 所以我们在处理某些滑动冲突场景时，可以从子View中调用父View的requestDisallowInterceptTouchEvent方法，阻止父View拦截事件。 如果view没有设置FLAG_DISALLOW_INTERCEPT，就可以进入onInterceptTouchEvent方法，判断是否应该被自己拦截， ViewGroup的onInterceptTouchEvent直接返回了false，即默认是不拦截事件的，ViewGroup的子类可以重写这个方法，内部判断拦截逻辑。 注意：只有当事件类型是ACTION_DOWN或者mFirstTouchTarget不为空时，才会走是否需要拦截事件这一判断，如果事件是ACTION_DOWN的后续事件（如ACTION_MOVE、ACTION_UP等），且在传递ACTION_DOWN事件过程中没有找到目标子View时，事件将会直接被拦截，交给ViewGroup自己处理。mFirstTouchTarget的赋值会在下一节提到。 遍历所有子View，逐个分发事件执行遍历分发的条件是：当前事件是ACTION_DOWN、ACTION_POINTER_DOWN或者ACTION_HOVER_MOVE三种类型中的一个（后两种用的比较少，暂且忽略）。所以，如果事件是ACTION_DOWN的后续事件，如ACTION_UP事件，将不会进入遍历流程！ 进入遍历流程后，拿到一个子View，首先会判断触摸点是不是在子View范围内，如果不是直接跳过该子View； 否则通过dispatchTransformedTouchEvent方法，间接调用child.dispatchTouchEvent达到传递的目的； 其中canViewReceivePointerEvents(child)判断child是否可见（Visiable）， isTransformedTouchPointInView(x, y, child, null)判断当前触点（x，y）是否在child区域内。 如果dispatchTransformedTouchEvent返回true，即事件被子View消费，就会把mFirstTouchTarget设置为child，即不为null，并将alreadyDispatchedToNewTouchTarget设置为true，然后跳出循环，事件不再继续传递给其他子View。 可以理解为，这一步的主要作用是，在事件的开始，即传递ACTION_DOWN事件过程中，找到一个需要消费事件的子View，我们可以称之为目标子View，执行第一次事件传递，并把mFirstTouchTarget设置为这个目标子View 将事件交给ViewGroup自己或者目标子View处理经过上面一步后，如果mFirstTouchTarget仍然为空，说明没有任何一个子View消费事件，将同样会调用dispatchTransformedTouchEvent，但此时这个方法的View child参数为null，所以调用的其实是super.dispatchTouchEvent(event)，即事件交给ViewGroup自己处理。ViewGroup是View的子View，所以事件将会使用View的dispatchTouchEvent(event)方法判断是否消费事件。 反之，如果mFirstTouchTarget不为null，说明上一次事件传递时，找到了需要处理事件的目标子View，此时，ACTION_DOWN的后续事件，如ACTION_UP等事件，都会传递至mFirstTouchTarget中保存的目标子View中。这里面还有一个小细节，如果在上一节遍历过程中已经把本次事件传递给子View，alreadyDispatchedToNewTouchTarget的值会被设置为true，代码会判断alreadyDispatchedToNewTouchTarget的值，避免做重复分发。 小结： dispatchTouchEvent方法首先判断事件是否需要被拦截，如果需要拦截会调用onInterceptTouchEvent，若该方法返回true，事件由ViewGroup自己处理，不在继续传递。 若事件未被拦截，将先遍历找出一个目标子View，后续事件也将交由目标子View处理。 若没有目标子View，事件由ViewGroup自己处理。 此外，如果一个子View没有消费ACTION_DOWN类型的事件，那么事件将会被另一个子View或者ViewGroup自己消费，之后的事件都只会传递给目标子View（mFirstTouchTarget）或者ViewGroup自身。简单来说，就是如果一个View没有消费ACTION_DOWN事件，后续事件也不会传递进来。 View现在回头看上一节的第2、3步，不管是对子View分发事件，还是将事件分发给ViewGroup自身，最后都殊途同归，调用到了View的dispatchTouchEvent，这就是我们这一节分析的目标。View源码链接12345678910111213141516171819202122232425public boolean dispatchTouchEvent(MotionEvent event) &#123; ··· boolean result = false; if (onFilterTouchEventForSecurity(event)) &#123; //判断事件是否先交给ouTouch方法处理 ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; ··· return result;&#125; 代码量不多，主要做了三件事： 若View设置了OnTouchListener，且处于enable状态时，会先调用mOnTouchListener的onTouch方法 若onTouch返回false，事件传递给onTouchEvent方法继续处理 若最后onTouchEvent也没有消费这个事件，将返回result默认值false，告知上层parent将事件给其他兄弟View 这样，我们的分析转到了View的onTouchEvent方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160public boolean onTouchEvent(MotionEvent event) &#123; final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return clickable; &#125; if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123; switch (action) &#123; case MotionEvent.ACTION_UP: ··· boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (prepressed) &#123; // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); &#125; if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClick(); &#125; &#125; &#125; if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // If the post failed, unpress right now mUnsetPressedState.run(); &#125; removeTapCallback(); &#125; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) &#123; mPrivateFlags3 |= PFLAG3_FINGER_DOWN; &#125; mHasPerformedLongPress = false; if (!clickable) &#123; checkForLongClick(0, x, y); break; &#125; if (performButtonActionOnTouchDown(event)) &#123; break; &#125; // Walk up the hierarchy to determine if we're inside a scrolling container. boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for // a short period in case this is a scroll. if (isInScrollingContainer) &#123; mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); &#125; mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); &#125; else &#123; // Not inside a scrolling container, so show the feedback right away setPressed(true, x, y); checkForLongClick(0, x, y); &#125; break; case MotionEvent.ACTION_CANCEL: if (clickable) &#123; setPressed(false); &#125; removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; break; case MotionEvent.ACTION_MOVE: if (clickable) &#123; drawableHotspotChanged(x, y); &#125; // Be lenient about moving outside of buttons if (!pointInView(x, y, mTouchSlop)) &#123; // Outside button // Remove any future long press/tap checks removeTapCallback(); removeLongPressCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; &#125; break; &#125; return true; &#125; return false;&#125; public final boolean isFocusable() &#123; return FOCUSABLE == (mViewFlags &amp; FOCUSABLE);&#125; public final boolean isFocusableInTouchMode() &#123; return FOCUSABLE_IN_TOUCH_MODE == (mViewFlags &amp; FOCUSABLE_IN_TOUCH_MODE);&#125; onTouchEvent方法的主要流程如下： 如果一个View处于DISABLED状态，但是CLICKABLE或者LONG_CLICKABLE的话，这个View仍然能消费事件，只是不会再走下面的流程; 如果View是enable的且处于可点击状态，事件将被这个View消费： 在方法返回前，onTouchEvent会根据MotionEvent的不同类型做出不同响应，如调用setPressed()去设置View的按下效果和抬起效果等。 这里我们主要关注ACTION_UP分支，这个分支内部经过重重判断之后，会调用到performClick方法：1234567891011121314public boolean performClick() &#123; final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; &#125; else &#123; result = false; &#125; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); return result;&#125; 可以看到，如果设置了OnClickListener，就会回调我们的onClick方法，最终消费事件。 总结通过上面的源码解析，我们可以总结出事件分发的整体流程： 下面做一个总体概括： 事件由Activity的dispatchTouchEvent()开始，将事件传递给当前Activity的根ViewGroup：mDecorView，事件开始自上而下进行传递，直至被消费。 事件传递至ViewGroup时，调用dispatchTouchEvent()进行分发处理: 检查送否应该对事件进行拦截:onInterceptTouchEvent()，若为true，跳过2步骤； 将事件依次分发给子View，若事件被某个View消费了，将不再继续分发； 如果2中没有子View对事件进行消费或者子View的数量为零，事件将由ViewGroup自己处理，处理流程和View的处理流程一致； 事件传递至View的dispatchTouchEvent()时， 首先会判断OnTouchListener是否存在，倘若存在，则执行onTouch()，若onTouch()未对事件进行消费，事件将继续交由onTouchEvent处理，根据上面分析可知，View的onClick事件是在onTouchEvent的ACTION_UP中触发的，因此，onTouch事件优先于onClick事件。 若事件在自上而下的传递过程中一直没有被消费，而且最底层的子View也没有对其进行消费，事件会反向向上传递，此时，父ViewGroup可以对事件进行消费，若仍然没有被消费的话，最后会回到Activity的onTouchEvent。 如果一个子View没有消费ACTION_DOWN类型的事件，那么事件将会被另一个子View或者ViewGroup自己消费，之后的事件都只会传递给目标子View（mFirstTouchTarget）或者ViewGroup自身。简单来说，就是如果一个View没有消费ACTION_DOWN事件，后续事件也不会传递进来。]]></content>
      <categories>
        <category>android</category>
        <category>事件分发</category>
      </categories>
      <tags>
        <tag>事件分发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android消息处理机制之Looper、Handler、Message]]></title>
    <url>%2F3531063604%2F</url>
    <content type="text"><![CDATA[前言相信不少人在面试Android工程师时，会被问到这两个问题： Android中的Looper、Handler、Message之间关系（Android消息处理机制） Android事件分发机制 本篇章就对第一种从源码角度给大家做一下讲解，有不对之处敬请谅解并指明。 概述Handler 、 Looper 、Message 这三者是Android异步消息处理线程的重要组成部分。 异步消息处理线程启动后会进入一个无限的循环体之中，每循环一次，从其内部的消息队列中取出一个消息，然后回调相应的消息处理函数，执行完成一个消息后则继续循环。若消息队列为空，线程则会阻塞等待。 简而言之，Looper负责的就是创建一个MessageQueue，然后进入一个无限循环体不断从该MessageQueue中读取消息，而消息的创建者就是一个或多个Handler 。 相关概念相关概念的解释 主线程（UI线程） 定义：当程序第一次启动时，Android会同时启动一条主线程（Main Thread）作用：主线程主要负责处理与UI相关的事件 Message（消息） 定义：Handler接收和处理的消息对象（Bean对象）作用：通信时相关信息的存放和传递 ThreadLocal 定义：线程内部的数据存储类作用：负责存储和获取本线程的Looper Message Queue（消息队列） 定义：采用单链表的数据结构来存储消息列表作用：用来存放通过Handler发过来的Message，按照FIFO先进先出执行 Handler（处理者） 定义：Message的主要处理者作用：负责发送Message到消息队列&amp;处理Looper分派过来的Message Looper（循环器） 定义：扮演MessageQueue和Handler之间桥梁的角色作用： 消息循环：循环取出Message Queue的Message 消息派发：将取出的Message交付给相应的Handler 图例解释关联简要说明 详细流程图 源码分析LooperLooper源码链接 对于Looper主要是prepare()和loop()两个方法。 首先看prepare()方法12345678910public static void prepare() &#123; prepare(true);&#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; sThreadLocal是一个ThreadLocal对象，可以在一个线程中存储变量。可以看到，在第9行，将一个Looper的实例放入了ThreadLocal，并且6-8行判断了sThreadLocal是否为null，否则抛出异常。这也就说明了Looper.prepare()方法不能被调用两次，同时也保证了一个线程中只有一个Looper实例~相信有些哥们一定遇到这个错误。 下面看Looper的构造方法： 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 在构造方法内，新建了一个MessageQueue（消息队列），并将当前的线程信息保留。 然后我们看loop()方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println("&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what); &#125; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logging != null) &#123; logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what); &#125; msg.recycleUnchecked(); &#125;&#125; 第6行，myLooper方法1234567/** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. */public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();&#125; 通过sThreadLocal将之前Looper.prepare()存入的Looper对象取出，取出后命名为“me”。如果me为null则抛出异常，也就是说looper方法必须在prepare方法之后运行。 第10行：拿到该looper实例中的mQueue（消息队列） 第17-59行：for (;;)，进入无限循环 第18行：取出一个消息，如果没有消息则阻塞。 第36行：msg.target.dispatchMessage(msg);把消息交给msg的target的dispatchMessage方法去处理。msg的target是什么呢？其实就是handler对象，下面会进行分析。 第58行：释放消息占据的资源。 Looper的退出当然Looper也提供了两个方法可以退出一个Looper： quit()：quit会直接退出Looper quitSafety()：quitSafety只是设定一个退出标记，然后把消息队列中的已有消息处理完毕后退出Looper 这两个方法都是调用Message.quit(boolean safe)方法。 Looper 12345678public void quit() &#123; mQueue.quit(false);&#125;public void quitSafely() &#123; mQueue.quit(true);&#125; MessageQueue 123456789101112131415161718192021void quit(boolean safe) &#123; if (!mQuitAllowed) &#123; throw new IllegalStateException("Main thread not allowed to quit."); &#125; synchronized (this) &#123; if (mQuitting) &#123; return; &#125; mQuitting = true; if (safe) &#123; removeAllFutureMessagesLocked(); &#125; else &#123; removeAllMessagesLocked(); &#125; // We can assume mPtr != 0 because mQuitting was previously false. nativeWake(mPtr); &#125;&#125; 可见，quitSafely时调用removeAllFutureMessagesLocked(),quit时调用removeAllMessagesLocked()。 12345678910111213141516171819202122232425262728293031323334353637private void removeAllMessagesLocked() &#123; Message p = mMessages; while (p != null) &#123; Message n = p.next; p.recycleUnchecked(); p = n; &#125; mMessages = null;&#125;private void removeAllFutureMessagesLocked() &#123; final long now = SystemClock.uptimeMillis(); Message p = mMessages; if (p != null) &#123; if (p.when &gt; now) &#123; removeAllMessagesLocked(); &#125; else &#123; Message n; for (;;) &#123; n = p.next; if (n == null) &#123; return; &#125; if (n.when &gt; now) &#123; break; &#125; p = n; &#125; p.next = null; do &#123; p = n; n = p.next; p.recycleUnchecked(); &#125; while (n != null); &#125; &#125;&#125; Message 1234567891011121314151617181920212223void recycleUnchecked() &#123; // Mark the message as in use while it remains in the recycled object pool. // Clear out all other details. flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125;&#125; 从上面的代码可见，removeAllMessagesLocked()是直接将消息队列内的所有消息直接清除回收掉；而removeAllFutureMessagesLocked()是将时间when&gt;now的消息清除回收，这一般对delay的消息有影响。 SystemClock.uptimeMillis()是自系统启动后到现在的时间（不包含系统深度水睡眠时间）。 Looper主要作用： 与当前线程绑定，保证一个线程只会有一个Looper实例，同时一个Looper实例也只有一个MessageQueue。 loop()方法，不断从MessageQueue中去取消息，交给消息的target属性的dispatchMessage去处理。 好了，我们的异步消息处理线程已经有了消息队列（MessageQueue），也有了在无限循环体中取出消息的哥们，现在缺的就是发送消息的对象了，于是乎：Handler登场了。 Handler使用Handler之前，我们都是初始化一个Handler实例。所以我们首先看Handler的构造方法，看其如何与MessageQueue联系上的，它在子线程中发送的消息（一般发送消息都在非UI线程）怎么发送到MessageQueue中的。Handler源码链接 Handler有多个构造函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127/** * Default constructor associates this handler with the &#123;@link Looper&#125; for the * current thread. * * If this thread does not have a looper, this handler won't be able to receive messages * so an exception is thrown. */public Handler() &#123; this(null, false);&#125; /** * Constructor associates this handler with the &#123;@link Looper&#125; for the * current thread and takes a callback interface in which you can handle * messages. * * If this thread does not have a looper, this handler won't be able to receive messages * so an exception is thrown. * * @param callback The callback interface in which to handle messages, or null. */public Handler(Callback callback) &#123; this(callback, false);&#125; /** * Use the provided &#123;@link Looper&#125; instead of the default one. * * @param looper The looper, must not be null. */public Handler(Looper looper) &#123; this(looper, null, false);&#125; /** * Use the provided &#123;@link Looper&#125; instead of the default one and take a callback * interface in which to handle messages. * * @param looper The looper, must not be null. * @param callback The callback interface in which to handle messages, or null. */public Handler(Looper looper, Callback callback) &#123; this(looper, callback, false);&#125; /** * Use the &#123;@link Looper&#125; for the current thread * and set whether the handler should be asynchronous. * * Handlers are synchronous by default unless this constructor is used to make * one that is strictly asynchronous. * * Asynchronous messages represent interrupts or events that do not require global ordering * with respect to synchronous messages. Asynchronous messages are not subject to * the synchronization barriers introduced by &#123;@link MessageQueue#enqueueSyncBarrier(long)&#125;. * * @param async If true, the handler calls &#123;@link Message#setAsynchronous(boolean)&#125; for * each &#123;@link Message&#125; that is sent to it or &#123;@link Runnable&#125; that is posted to it. * * @hide */public Handler(boolean async) &#123; this(null, async);&#125; /** * Use the &#123;@link Looper&#125; for the current thread with the specified callback interface * and set whether the handler should be asynchronous. * * Handlers are synchronous by default unless this constructor is used to make * one that is strictly asynchronous. * * Asynchronous messages represent interrupts or events that do not require global ordering * with respect to synchronous messages. Asynchronous messages are not subject to * the synchronization barriers introduced by &#123;@link MessageQueue#enqueueSyncBarrier(long)&#125;. * * @param callback The callback interface in which to handle messages, or null. * @param async If true, the handler calls &#123;@link Message#setAsynchronous(boolean)&#125; for * each &#123;@link Message&#125; that is sent to it or &#123;@link Runnable&#125; that is posted to it. * * @hide */public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, "The following Handler class should be static or leaks might occur: " + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; /** * Use the provided &#123;@link Looper&#125; instead of the default one and take a callback * interface in which to handle messages. Also set whether the handler * should be asynchronous. * * Handlers are synchronous by default unless this constructor is used to make * one that is strictly asynchronous. * * Asynchronous messages represent interrupts or events that do not require global ordering * with respect to synchronous messages. Asynchronous messages are not subject to * the synchronization barriers introduced by &#123;@link MessageQueue#enqueueSyncBarrier(long)&#125;. * * @param looper The looper, must not be null. * @param callback The callback interface in which to handle messages, or null. * @param async If true, the handler calls &#123;@link Message#setAsynchronous(boolean)&#125; for * each &#123;@link Message&#125; that is sent to it or &#123;@link Runnable&#125; that is posted to it. * * @hide */public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 没传Looper的构造方法，通过Looper.myLooper()获取当前线程保存的Looper实例（第93行），并获取这个Looper实例中保存的MessageQueue（消息队列）（第98行）；传Looper的构造方法，直接保存传入的looper对象（第123行），并获取该looper对象中保存的MessageQueue（消息队列）（第124行）；这样就保证了handler的实例与我们Looper实例中MessageQueue关联上了。 然后看我们最常用的sendMessage方法 12345678910111213141516171819202122232425public final boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg, 0);&#125;public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125;public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; sendMessage -&gt; sendMessageDelayed -&gt; sendMessageAtTime辗转反则最后调用了sendMessageAtTime，在此方法内部有直接获取MessageQueue然后调用了enqueueMessage方法，我们再来看看此方法：1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; enqueueMessage方法中首先为msg.target赋值为this，【如果大家还记得Looper的loop方法会取出每个msg然后交给msg.target.dispatchMessage(msg)去处理消息】，也就是把当前的handler作为msg的target属性。最终会调用queue的enqueueMessage的方法，也就是说handler发出的消息，最终会保存到消息队列中去。 现在已经很清楚了Looper会调用prepare()和loop()方法，在当前执行的线程中保存一个Looper实例，这个实例会保存一个MessageQueue对象，然后当前线程进入一个无限循环中去，不断从MessageQueue中读取Handler发来的消息。然后再回调创建这个消息的handler中的dispathMessage方法，下面我们赶快去看一看这个方法： 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 第2行：判断msg.callback是否为空。不为空，则调用Handler.handleCallback()方法,该方法内其实就是调用了msg.callback.run()123private static void handleCallback(Message message) &#123; message.callback.run();&#125; 第5行：判断mCallback是否为空，mCallback是Handler内的一个成员变量，该值是在Handler构造方法处传入的。若mCallback不为空，则调用mCallback.handleMessage()，若mCallback.handleMessage()返回true，则结束，否则继续掉用Handler.handleMessage()方法。 mCallback在Handler内定义为内部接口123public interface Callback &#123; public boolean handleMessage(Message msg); &#125; 而Handler.handleMessage()方法是一个空方法。因为消息的最终回调是由我们控制的，我们在创建handler的时候都是复写handleMessage方法，然后根据msg.what进行消息处理。12public void handleMessage(Message msg) &#123;&#125; 例如：123456789101112131415private Handler mHandler = new Handler() &#123; public void handleMessage(android.os.Message msg) &#123; switch (msg.what) &#123; case value: break; default: break; &#125; &#125;; &#125;; 到此，这个流程已经解释完毕，让我们首先总结一下 首先Looper.prepare()在本线程中保存一个Looper实例，然后该实例中保存一个MessageQueue对象；因为Looper.prepare()在一个线程中只能调用一次，所以MessageQueue在一个线程中只会存在一个。 Looper.loop()会让当前线程进入一个无限循环，不断从MessageQueue的实例中读取消息，然后回调msg.target.dispatchMessage(msg)方法。 Handler的构造方法，会首先得到当前线程中保存的Looper实例，进而与Looper实例中的MessageQueue想关联。 Handler的sendMessage方法，会给msg的target赋值为handler自身，然后加入MessageQueue中。 在构造Handler实例时，我们会重写handleMessage方法，也就是msg.target.dispatchMessage(msg)最终调用的方法。 主线程（UI线程）处理根据上面的例子，为什么Handler可以在主线程中直接可以使用呢？ 答案是： 因为主线程（UI线程）的Looper在应用程序开启时创建好了，即在ActivityThread.main方法中创建的，该函数为Android应用程序的入口ActivityThread源码链接 12345678910111213141516171819202122232425262728public static void main(String[] args) &#123; ··· Process.setArgV0("&lt;pre-initialized&gt;"); //1. 创建消息循环Looper Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, "ActivityThread")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); //2. 执行消息循环 Looper.loop(); throw new RuntimeException("Main thread loop unexpectedly exited"); &#125; 依次调用了Looper.prepareMainLooper()和Looper.loop()，完成Looper的初始化、将当前Looper记录为sMainLooper（主线程Looper）和对消息队列的轮询。123456789public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException("The main Looper has already been prepared."); &#125; sMainLooper = myLooper(); &#125;&#125; Handler.post(),Handler.sendEmptyMessage()等Handler.post()1234567891011public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125;private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m;&#125; Handler.sendEmptyMessage()1234567891011public final boolean sendEmptyMessage(int what)&#123; return sendEmptyMessageDelayed(what, 0);&#125;public final boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123; Message msg = Message.obtain(); msg.what = what; return sendMessageDelayed(msg, delayMillis);&#125; post()、sendEmptyMessage()等没有直接传入Message对象的，其实是对传入的参数进行包装成Message后再调用后续方法，并最终调用enqueueMessage()方法。最终和上面介绍的sendMessage()一致。 MessageQueueMessageQueue 源码链接 前面讲了这么多关于MessageQueue（消息队列）的入和出，接下来就看看它的源码是如何的吧。 MessageQueue创建1234567@SuppressWarnings("unused")private long mPtr; // used by native codeMessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; mPtr = nativeInit();&#125; nativeInit()为native方法，该方法内会创建一个native层的MessageQueue，并且将引用地址返回给Java层保存在mPtr变量中，通过这种方式将Java层的对象与Native层的对象关联在了一起。 存储Message，MessageQueue.enqueueMessage()在MessageQueue中会使用enqueueMessage()方法存储Message，其实现的方式是通过单链表的数据结构来存储消息列表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException("Message must have a target."); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + " This message is already in use."); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true; &#125; enqueueMessage()方法主要实现了如下功能点： 首先判断消息队列里有没有消息，没有的话则将当前插入的消息作为队头，并且这时消息队列如果处于等待状态的话则将其唤醒。唤醒调用native方法nativeWake(mPtr) 若是在中间插入，则根据Message创建的时间（when字段）进行插入 取Message，MessageQueue.next()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Message next() &#123; ...... int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; // nativePollOnce方法在native层，若是nextPollTimeoutMillis为-1，这时候消息队列处于等待状态。 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; //按照我们设置的时间取出消息 if (msg != null) &#123; if (now &lt; msg.when) &#123; nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, "Returning message: " + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // 如果消息队列中没有消息，将nextPollTimeoutMillis设为-1，下次循环消息队列则处于等待状态 nextPollTimeoutMillis = -1; &#125; //退出消息队列，返回null，这时候Looper中的消息循环也会终止。 if (mQuitting) &#123; dispose(); return null; &#125; ...... &#125; ..... &#125;&#125; nativePollOnce(ptr, nextPollTimeoutMillis)是一个native方法，实际作用就是通过Native层的MessageQueue阻塞nextPollTimeoutMillis毫秒的时间。 如果nextPollTimeoutMillis=-1，一直阻塞不会超时。 如果nextPollTimeoutMillis=0，不会阻塞，立即返回。 如果nextPollTimeoutMillis&gt;0，最长阻塞nextPollTimeoutMillis毫秒(超时)，如果期间有程序唤醒会立即返回。 MessageMessage 源码链接 之前处处提到Message，这里就简单说明一下。 Message就是用来存储各种特定信息的Bean对象，主要有如下几个成员变量123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119public final class Message implements Parcelable &#123; /** * User-defined message code so that the recipient can identify * what this message is about. Each &#123;@link Handler&#125; has its own name-space * for message codes, so you do not need to worry about yours conflicting * with other handlers. */ public int what; /** * arg1 and arg2 are lower-cost alternatives to using * &#123;@link #setData(Bundle) setData()&#125; if you only need to store a * few integer values. */ public int arg1; /** * arg1 and arg2 are lower-cost alternatives to using * &#123;@link #setData(Bundle) setData()&#125; if you only need to store a * few integer values. */ public int arg2; /** * An arbitrary object to send to the recipient. When using * &#123;@link Messenger&#125; to send the message across processes this can only * be non-null if it contains a Parcelable of a framework class (not one * implemented by the application). For other data transfer use * &#123;@link #setData&#125;. * * &lt;p&gt;Note that Parcelable objects here are not supported prior to * the &#123;@link android.os.Build.VERSION_CODES#FROYO&#125; release. */ public Object obj; /*package*/ int flags; /*package*/ long when; /*package*/ Bundle data; /*package*/ Handler target; /*package*/ Runnable callback; // sometimes we store linked lists of these things /*package*/ Message next; private static final Object sPoolSync = new Object(); private static Message sPool; private static int sPoolSize = 0; private static final int MAX_POOL_SIZE = 50; /** * Return a new Message instance from the global pool. Allows us to * avoid allocating new objects in many cases. */ public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message(); &#125; /** * Return a Message instance to the global pool. * &lt;p&gt; * You MUST NOT touch the Message after calling this function because it has * effectively been freed. It is an error to recycle a message that is currently * enqueued or that is in the process of being delivered to a Handler. * &lt;/p&gt; */ public void recycle() &#123; if (isInUse()) &#123; if (gCheckRecycle) &#123; throw new IllegalStateException("This message cannot be recycled because it " + "is still in use."); &#125; return; &#125; recycleUnchecked(); &#125; /** * Recycles a Message that may be in-use. * Used internally by the MessageQueue and Looper when disposing of queued Messages. */ void recycleUnchecked() &#123; // Mark the message as in use while it remains in the recycled object pool. // Clear out all other details. flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125; &#125;&#125; 这里主要讲一下其中的两个方法：obtain()和recycle()。Message通过其成员变量next、sPool构成了一个单向链表形成了消息重用的消息池。sPool记录列表头，next指向列表下一项。obtain()方法是从该消息池（单向链表）中由头部取出一个Message，若该消息池为空（sPool==null）则直接new一个消息对象。recycle()则是重置Message对象内的成员变量，并将其加入到单向链表（消息池）头部 面试回答 请解释下Android通信机制中Message、Handler、MessageQueue、Looper的之间的关系？ 首先，是这个MessageQueue，MessageQueue是一个消息队列，它可以存储Handler发送过来的消息，其内部提供了进队和出队的方法来管理这个消息队列，其出队和进队的原理是采用单链表的数据结构进行插入和删除的，即enqueueMessage()方法和next()方法。这里提到的Message，其实就是一个Bean对象，里面的属性用来记录Message的各种信息。 然后，是这个Looper，Looper是一个循环器，它可以循环的取出MessageQueue中的Message，其内部提供了Looper的初始化和循环出去Message的方法，即prepare()方法和loop()方法。在prepare()方法中，Looper会关联一个MessageQueue，而且将Looper存进一个ThreadLocal中，在loop()方法中，通过ThreadLocal取出Looper，使用MessageQueue.next()方法取出Message后，判断Message是否为空，如果是则Looper阻塞，如果不是，则通过dispatchMessage()方法分发该Message到Handler中，而Handler执行handlerMessage()方法，由于handlerMessage()方法是个空方法，这也是为什么需要在Handler中重写handlerMessage()方法的原因。这里要注意的是Looper只能在一个线程中只能存在一个。这里提到的ThreadLocal，其实就是一个对象，用来在不同线程中存放对应线程的Looper。 最后，是这个Handler，Handler是Looper和MessageQueue的桥梁，Handler内部提供了发送Message的一系列方法，最终会通过MessageQueue.enqueueMessage()方法将Message存进MessageQueue中。我们平时可以直接在主线程中使用Handler，那是因为在应用程序启动时，在入口的main方法中已经默认为我们创建好了Looper。 参考Android 异步消息处理机制 让你深入理解 Looper、Handler、Message三者关系 深入理解 MessageQueue Android中为什么主线程不会因为Looper.loop()里的死循环卡死]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[请不要滥用SharedPreference]]></title>
    <url>%2F559452592%2F</url>
    <content type="text"><![CDATA[不要滥用SharedPreference这篇文章在使用SharedPreference上给出了很多好的建议。 不要存放大的key和value！我就不重复三遍了，会引起界面卡、频繁GC、占用内存等等，好自为之！ 毫不相关的配置项就不要丢在一起了！文件越大读取越慢，不知不觉就被猪队友给坑了；蓝后，放进defalut的那个简直就是愚蠢行为！ 读取频繁的key和不易变动的key尽量不要放在一起，影响速度。（如果整个文件很小，那么忽略吧，为了这点性能添加维护成本得不偿失） 不要乱edit和apply，尽量批量修改一次提交！ 尽量不要存放JSON和HTML，这种场景请直接使用json！ 不要指望用这货进行跨进程通信！！！ 请不要滥用SharedPreference 涉及源码SharedPreferencesImpl.java(需翻墙)ContextImpl.java(需翻墙) 获取SharePreferences对象的三种方式要想使用SharedPreferences来存储数据，首先需要获取到SharedPreferences对象。Android 中主要提供了三种方法用于得到SharedPreferences对象。 Context.getSharedPreferences()Context类中的getSharedPreferences()方法 此方法接收两个参数，第一个参数用于指定 SharedPreferences文件的名称，如果指定的文件不存在则会创建一个， SharedPreferences文件都是存放在/data/data/包名/shared_prefs/目录下的。第二个参数用于 指定操作模式，主要有两种模式可以选择，MODE_PRIVATE和 MODE_MULTI_PROCESS。MODE_PRIVATE仍然是默认的操作模式，和直接传入0效 果是相同的，表示只有当前的应用程序才可以对这个SharedPreferences文件进行读写。 MODE_MULTI_PROCESS则一般是用于会有多个进程中对同一个SharedPreferences文 件进行读写的情况。类似地，MODE_WORLD_READABLE和 MODE_WORLD_WRITEABLE这两种模式已在Android 4.2版本中被废弃。 Activity.getPreferences()Activity类中的getPreferences()方法 这个方法和Context中的getSharedPreferences()方 法很相似，不过它只接收一个操作模式参数，因为使用这个方法时会自动将当前活动的 类名作为SharedPreferences的文件名。 最终还是调用了方法1中的方法，源码如下：123456789101112131415161718192021222324252627282930313233/** * Retrieve a &#123;@link SharedPreferences&#125; object for accessing preferences * that are private to this activity. This simply calls the underlying * &#123;@link #getSharedPreferences(String, int)&#125; method by passing in this activity's * class name as the preferences name. * * @param mode Operating mode. Use &#123;@link #MODE_PRIVATE&#125; for the default * operation. * * @return Returns the single SharedPreferences instance that can be used * to retrieve and modify the preference values. */ public SharedPreferences getPreferences(int mode) &#123; return getSharedPreferences(getLocalClassName(), mode); &#125; /** * Returns class name for this activity with the package prefix removed. * This is the default name used to read and write settings. * * @return The local class name. */ @NonNull public String getLocalClassName() &#123; final String pkg = getPackageName(); final String cls = mComponent.getClassName(); int packageLen = pkg.length(); if (!cls.startsWith(pkg) || cls.length() &lt;= packageLen || cls.charAt(packageLen) != '.') &#123; return cls; &#125; return cls.substring(packageLen+1); &#125; PreferenceManager.getDefaultSharedPreferences()PreferenceManager类中的getDefaultSharedPreferences()方法 这是一个静态方法，它 接收一个Context参数，并自动使用当前应用程序的包名作为前缀来命名 SharedPreferences文。最终还是调用了方法1中的方法，源码如下：1234567891011121314151617181920212223242526/** * Gets a SharedPreferences instance that points to the default file that is * used by the preference framework in the given context. * * @param context The context of the preferences whose values are wanted. * @return A SharedPreferences instance that can be used to retrieve and * listen to values of the preferences. */ public static SharedPreferences getDefaultSharedPreferences(Context context) &#123; return context.getSharedPreferences(getDefaultSharedPreferencesName(context), getDefaultSharedPreferencesMode()); &#125; /** * Returns the name used for storing default shared preferences. * * @see #getDefaultSharedPreferences(Context) * @see Context#getSharedPreferencesPath(String) */ public static String getDefaultSharedPreferencesName(Context context) &#123; return context.getPackageName() + "_preferences"; &#125; private static int getDefaultSharedPreferencesMode() &#123; return Context.MODE_PRIVATE; &#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RxJava 混淆配置]]></title>
    <url>%2F146508185%2F</url>
    <content type="text"><![CDATA[转自：https://blog.csdn.net/soslinken/article/details/51375036 因为升级到了RxJava 1.1.5版本。在使用混淆时，出现了类无法找到的错误，所以怀疑是混淆配置有问题，到github上看了一下，是因为1.1.1版本中修改了部分实现，混淆后，就会报错，根据Github上的issus文件，增加如下混淆配置即可。1234567891011-dontwarn sun.misc.**-keepclassmembers class rx.internal.util.unsafe.*ArrayQueue*Field* &#123; long producerIndex; long consumerIndex;&#125;-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueProducerNodeRef &#123; rx.internal.util.atomic.LinkedQueueNode producerNode;&#125;-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueConsumerNodeRef &#123; rx.internal.util.atomic.LinkedQueueNode consumerNode;&#125; 这个配置是使用 https://github.com/artem-zinnatullin/RxJavaProGuardRules 这个开源项目的，使用Android studio的同学，可以直接增加一个依赖即可。 依赖如下：12345// RxJava itselfcompile &apos;io.reactivex:rxjava:1.3.3&apos;// And ProGuard rules for RxJava!compile &apos;com.artemzin.rxjava:proguard-rules:1.3.3.0&apos; 原issus地址：https://github.com/krschultz/android-proguard-snippets/pull/112]]></content>
      <categories>
        <category>android</category>
        <category>混淆</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MPChartLib-PieChart 饼图使用说明]]></title>
    <url>%2F132783743%2F</url>
    <content type="text"><![CDATA[前言MPAndroidChart是一个强大的Android图表加载库。支持展示折线图、柱状图、饼图、雷达图、气泡图、K线图和图表的缩放、拖拽、动画功能。 本篇介绍MpCahrtLib中的一种图表控件-PieChart，饼图。 tip：最有效的理解与实现需求（定制）的方式是：查看源码。 代码 MPChartLib 示例代码 简要说明饼图的源代码主要是如下两个类： PieChart PieChartRenderer PieChart - 图表整体结构从如下代码就可窥见一二。1234567891011121314151617181920212223242526272829303132@Overrideprotected void init() &#123; super.init(); mRenderer = new PieChartRenderer(this, mAnimator, mViewPortHandler); mXAxis = null; mHighlighter = new PieHighlighter(this);&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (mData == null) return; mRenderer.drawData(canvas); if (valuesToHighlight()) mRenderer.drawHighlighted(canvas, mIndicesToHighlight); mRenderer.drawExtras(canvas); mRenderer.drawValues(canvas); mLegendRenderer.renderLegend(canvas); drawDescription(canvas); drawMarkers(canvas);&#125; PieChartRenderer - 负责PieChart具体绘制。主要有：drawData(),drawValues(),drawExtras(),drawHighlighted() drawData() 饼图各大块的计算与绘制 drawHighlighted() 点按后的高亮模式绘制 drawExtras()内包含了 drawHole()内圈、drawCenterText()内圈内文字、c.drawBitmap()图 drawValues 饼图各大块上的文本 主要方法介绍 PieDataSet.setSliceSpace(); //设置饼图饼块间距，传入值的单位是dp，取值范围[0,20]，默认是0dp PieDataSet.setSelectionShift(); //设置饼图饼块选中效果时（highlighted），距离饼图中心距离，默认是12dp PieChart.setDrawSliceText(false); //是否显示饼图上的X轴名称 新版本改成 PieChart.setDrawEntryLabels(false);//是否显示饼图上的X轴名称,setDrawSliceText已删除 PieData.setDrawValues(false); //隐藏饼图片上的Y轴数据（百分比数据） PicChart.setOnChartValueSelectedListener();//饼块选中回调 PicChart.animateX(); //按X轴动画显示，个人感觉和animateY()、animateXY()差别不大 PicChart.animateY(); // PicChart.animateXY(); // PicChart.spin(); //设置旋转动画 PieChart.setUsePercentValues(true);//Y轴值是否显示百分比值，源码内如下处理 12float value = mChart.isUsePercentValuesEnabled() ? entry.getVal() / yValueSum * 100f : entry.getVal(); Piechart.setDescription(“”);//隐藏Desc 新版本改成 PieChart.getDescription().setEnabled(false);//隐藏/显示Desc,setDescription()已删除 PieChart.setExtraOffsets(5, 10, 5, 5);//图表距图表边距的距离，分别为：左，上，右，下，该值为dp单位。 PieChart.setDragDecelerationFrictionCoef(0.95f);//拖动时的减速摩擦系数，即手指离开后，饼图还能再旋转多久。该值范围[0,1),值越大，旋转越久。默认为0.9f。 PieChart.setCenterTextTypeface();//设置中心文本字体 PieChart.setCenterText();//设置中心文本 PieChart.setDrawHoleEnabled(true);//是否显示内圆 PieChart.setHoleColor(Color.WHITE);//设置内圆颜色 PieChart.setTransparentCircleColor(Color.WHITE);//设置贴着内圆外面的透明圆的颜色 PieChart.setTransparentCircleAlpha(110);//设置贴着内圆外面的透明圆的透明度，范围：[0,255],0:完全透明，255:完全不透明。默认为100 PieChart.setHoleRadius(58f);//设置内圆半径，该值为内圆半径与整个饼图的比例。默认为50f，即50% PieChart.setTransparentCircleRadius(61f);//the radius of the transparent circle next to the chart-hole in the center，翻译过来就是：贴着内圆外面的透明圆的半径，该值也是比例，默认为55f,即55% PieChart.setDrawCenterText(true);//是否显示内圆文本 PieChart.setRotationAngle(0);//设置饼图起始饼块绘制的角度。默认270f（正北） PieChart.setRotationEnabled(true);//是否可以手动旋转 PieChart.setHighlightPerTapEnabled(true);//饼块选中是否高亮 PicChart.saveToGallery(); //保存到gallery（图库） PicChart.saveToPath(); // 保存到指定路径 设置label样式 PicChart.setEntryLabelColor(Color.WHITE); PicChart.setEntryLabelTypeface(); PicChart.setEntryLabelTextSize(12f); 设置legend（图例）样式 Legend.setVerticalAlignment(Legend.LegendVerticalAlignment.TOP); Legend.setHorizontalAlignment(Legend.LegendHorizontalAlignment.RIGHT); Legend.setOrientation(Legend.LegendOrientation.VERTICAL); Legend.setForm();//设置图例形状，有3种：SQUARE, CIRCLE, LINE。即：方，圆，线。默认为SQUARE。 Legend.setXEntrySpace(7f);//图例条目间距，setOrientation(Legend.LegendOrientation.HORIZONTAL)有效 Legend.setYEntrySpace(0f);//图例条目间距，setOrientation(Legend.LegendOrientation.VERTICAL)有效 Legend.setYOffset(0f);//设置Y轴边距，在已有ExtraOffsets等边距的基础上再加该边距。]]></content>
      <categories>
        <category>android</category>
        <category>图表</category>
        <category>MPChartLib</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[小米四启用虚拟按键以及禁用实体按键]]></title>
    <url>%2F2505448859%2F</url>
    <content type="text"><![CDATA[转自：https://blog.csdn.net/jia_zero/article/details/77652404 启用虚拟按键： 先刷成小米开发版，或者稳定版root。 因为我这个机器上已经拍摄了大量的照片，还有儿歌，还有录像，转移太费劲，我就采用稳定版root的方式。 root试了所有的工具包括：root精灵、root大师、百度root、还有官方的superSU、最后用360 一键root，root成功，但是360会给手机上装好几个软件，到时候root完了删除。 root过后，安装REexplorer， 开启安卓原生虚拟按键的方法 第1步：系统状态改为可读写 第2步：进去system目录下 第3步：修改build.prop(长按build.prop文件选择以文本方式编辑) 第4步：在build.prop文件最后添加qemu.hw.mainkeys=0 第5步：在RE文件管理器的右上角选择保存并退出。（一般会自动生成一个bak文件，如果有问题，改名替换回来即可） 第6步：重启手机 第7步：重启后三个虚拟键就启动了。 禁用三个实体键。 关闭实体按键的方法 第1步；同样使用RE文件管理器修改系统状态为读写 第2步：进入system/usr /keylayout目录下 第3步：选择 所有的以.kl 结尾的文件 第4步：找到每个.kl 文件中如下信息 key 102 HOME VIRTUAL key 139 MENU VIRTUAL key 158 BACK VIRTUAL ，分别在key前添加# 或者将这三个字段直接删除 第5步：选择RE文件管理器右上角的保存并退出 第6步：重启手机 禁用成功。 亲测有效。]]></content>
      <categories>
        <category>系统</category>
        <category>MIUI</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Activity启动模式（三）之 Flag]]></title>
    <url>%2F69430407%2F</url>
    <content type="text"><![CDATA[前言前文 Activity启动模式（一）之 launchMode 介绍了通过配置清单文件launchMode的方式来改变Activity启动模式 前文 Activity启动模式（二）之 taskAffinity 介绍了taskAffinity属性的特点 本篇将介绍修改Activity启动模式的另一种方式：代码内配置Intent.setFlags()形式。 代码内配置启动模式优先级高于清单文件launchMode模式。 Intent Flag代码内配置启动方式的代码格式如下： 其中 context 上下文 FlagNewTaskClearTopActivity 需要启动的Activity setFlags 配置启动模式，用“|”符号（位或运算符）累加Flag12startActivity(new Intent(context, FlagNewTaskClearTopActivity.class) .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP)); 点击查看：Flag测试源码 Intent的Flag有很多，就挑一些介绍一下吧。 FLAG_ACTIVITY_CLEAR_TASK如果在调用 Context.startActivity()时传递这个标记，该activity在启动前，会将该activity所属task栈中的其他activity清空，也就是说，这个新启动的activity变为了这个空task的根activity。所有老的activity都结束掉。该标志必须和FLAG_ACTIVITY_NEW_TASK一起使用。 即：Intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK) FLAG_ACTIVITY_CLEAR_TOP如果该activity已经在当前task中存在，并且设置了该flag，系统不会启动新的 Activity 实例，会将task栈里将该Activity之上的所有Activity一律结束掉，然后将Intent发给这个已存在的Activity。Activity收到 Intent之后，或者在onNewIntent()里做下一步的处理，或者自行结束然后重新创建自己。 AndroidMainifest 为standard模式，且FLAG_ACTIVITY_CLEAR_TOP：清除栈内该Activity和该Activity上面的所有Activity，并重新实例化该Activity置入栈顶 FLAG_ACTIVITY_CLEAR_TOP|FLAG_ACTIVITY_SINGLE_TOP ：效果和singleTask一样，清除栈内该Activity上面的所有Activity，并重用该Activity，在onNewIntent()里做下一步的处理 FLAG_ACTIVITY_CLEAR_TOP|FLAG_ACTIVITY_NEW_TASK：根据taskAffinity属性找到或新建对应的栈，之后同第一种情况一样 FLAG_ACTIVITY_NEW_TASK 设置此状态，记住以下原则，首先会查找是否存在和被启动的Activity具有相同的亲和性的任务栈（即taskAffinity，注意同一个应用程序中的activity的亲和性在没有修改的情况下是一样的，所以下面的a情况会在同一个栈中），如果有，刚直接把这个栈整体移动到前台，并保持栈中的状态不变，即栈中的activity顺序不变，如果没有，则新建一个栈来存放被启动的activity。 a. 前提: Activity LearnMainActivity（以下用Activity A 替代说明）和Activity 启动模式-Flag NEW_TASK （以下用Activity B 替代说明）在同一个应用中。 操作: Activity A启动开僻Task堆栈(堆栈状态：A)， 在Activity A中启动Activity B， 启动Activity B的Intent的Flag设为FLAG_ACTIVITY_NEW_TASK，Activity B被压入Activity A所在堆栈(堆栈状态：AB), 在Activity B中再次启动Activity B， 启动Activity B的Intent的Flag设为FLAG_ACTIVITY_NEW_TASK，Activity B被压入Activity A所在堆栈(堆栈状态：ABB), 原因: 默认情况下同一个应用中的所有Activity拥有相同的关系(taskAffinity)，此时的Activity B同standard启动模式一致。 b. 前提: Activity LearnMainActivity（以下用Activity A 替代说明）在名称为”LearnApplication”的应用中， Activity MainActivity （以下用Activity C 替代说明）和Activity （以下用Activity D 替代说明）在名称为”AppB”的应用中。 操作1: 在Launcher中单击“LearnApplication”图标，Activity A启动开僻Task堆栈，命名为TaskA(TaskA堆栈状态: A)， 在Activity A中启动Activity C， 启动Activity C的Intent的Flag设为FLAG_ACTIVITY_NEW_TASK，Android系统会为Activity C开僻一个新的Task，命名为TaskB(TaskB堆栈状态: C), 长按Home键，选择TaskA，Activity A回到前台, 再次启动Activity C（两种情况：1.从桌面启动；2.从Activity A启动，两种情况一样）， 这时TaskB回到前台, Activity C显示，供用户使用,即：包含FLAG_ACTIVITY_NEW_TASK的Intent启动Activity的Task正在运行，则不会为该Activity创建新的Task，而是将原有的Task返回到前台显示。 操作2: 在Launcher中单击”LearnApplication”图标，Activity A启动开僻Task堆栈，命名为TaskA(TaskA堆栈状态: A)， 在Activity A中启动Activity C，启动Activity C的Intent的Flag设为FLAG_ACTIVITY_NEW_TASK，Android系统会为Activity C开僻一个新的Task，命名为TaskB(TaskB堆栈状态: C)， 在Activity C中启动Activity D(TaskB的状态: CD) 长按Home键， 选择TaskA，Activity A回到前台， 再次启动Activity C(从桌面或者ActivityA启动，也是一样的)，这时TaskB回到前台, Activity D显示，供用户使用。 说明了在此种情况下设置FLAG_ACTIVITY_NEW_TASK后，会先查找是不是有Activity C存在的栈，根据亲和性(taskAffinity)，如果有，刚直接把这个栈整体移动到前台，并保持栈中的状态不变，即栈中的顺序不变。 补充：同一App内情况 FLAG_ACTIVITY_NEW_TASK（taskAffinity默认）：同standard启动模式一样 FLAG_ACTIVITY_NEW_TASK|FLAG_ACTIVITY_CLEAR_TOP：根据taskAffinity属性找到或新建对应的栈，清除栈内该Activity和该Activity上面的所有Activity，并重新实例化该Activity置入栈顶 FLAG_ACTIVITY_NEW_TASK|FLAG_ACTIVITY_CLEAR_TASK：根据taskAffinity属性找到或新建对应的栈，清空栈内所有Activity，将该Activity实例压入栈内，成为栈底Activity。 FLAG_ACTIVITY_SINGLE_TOP 同singleTop一样 ，如果该Activity在栈顶，则重用该Activity，在onNewIntent()里做下一步的处理 其他一些FlagFLAG_ACTIVITY_BROUGHT_TO_FRONT 比方说我现在有Ａ，在Ａ中启动Ｂ，在Ａ中Intent中加上这个标记。此时B就是以FLAG_ACTIVITY_BROUGHT_TO_FRONT 这个启动的，在B中再启动C，D（正常启动C，D），如果这个时候在D中再启动B，这个时候最后的栈的情况是 A,C,D,B.。 FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET api21后已经废弃，请使用FLAG_ACTIVITY_NEW_DOCUMENT FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS 设置完之后，新的activity将不会添加到当前activity列表中，当某些情况下我们不希望用户通过历史列表回到我们的Activity的时候这个标记比较有用。他等同于在XML中指定Activity的属性android:excludeFromRecents=”true”。 FLAG_ACTIVITY_FORWARD_RESULT 如果设置，并且这个Intent用于从一个存在的Activity启动一个新的Activity，那么，这个作为答复目标的Activity将会传到这个新的Activity中。这种方式下，新的Activity可以调用setResult(int)，并且这个结果值将发送给那个作为答复目标的Activity。 FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY 一般由系统调用，比如长摁home键从历史记录中启动。 FLAG_ACTIVITY_MULTIPLE_TASK 这个标识用来创建一个新的task栈，并且在里面启动新的activity（所有情况，不管系统中存在不存在该activity实例），经常和FLAG_ACTIVITY_NEW_DOCUMENT或者FLAG_ACTIVITY_NEW_TASK一起使用。这上面两种使用场景下，如果没有带上FLAG_ACTIVITY_MULTIPLE_TASK标识，他们都会使系统搜索存在的task栈，去寻找匹配intent的一个activity，如果没有找到就会去新建一个task栈；但是当和FLAG_ACTIVITY_MULTIPLE_TASK一起使用的时候，这两种场景都会跳过搜索这步操作无条件的创建一个新的task。和FLAG_ACTIVITY_NEW_TASK一起使用需要注意，尽量不要使用该组合除非你完成了自己的顶部应用启动器，他们的组合使用会禁用已经存在的task栈回到前台的功能。 FLAG_ACTIVITY_NEW_DOCUMENT api 21之后加入的一个标识，用来在intent启动的activity的task栈中打开一个document，和documentLaunchMode效果相等，有着不同的documents的activity的多个实例，将会出现在最近的task列表中。单独使用效果和documentLaunchMode=”intoExisting”一样，如果和FLAG_ACTIVITY_MULTIPLE_TASK一起使用效果就等同于documentLaunchMode=”always”。 FLAG_ACTIVITY_NO_ANIMATION 禁止activity之间的切换动画 FLAG_ACTIVITY_NO_HISTORY 该Activity将不在stack中保留，用户一离开它，这个Activity就关闭了。 onActivityResult() 也就不会调用了。 FLAG_ACTIVITY_NO_USER_ACTION 禁止activity调用onUserLeaveHint()函。onUserLeaveHint()作为activity周期的一部分，它在activity因为用户要跳转到别的activity而退到background时使用。比如，在用户按下Home键（用户的操作），它将被调用。比如有电话进来（不属于用户的操作），它就不会被调用。注意：通过调用finish()时该activity销毁时不会调用该函数。 FLAG_ACTIVITY_PREVIOUS_IS_TOP 如果给Intent对象设置了这个标记，这个Intent对象被用于从一个存在的Activity中启动一个新的Activity，那么新的这个Activity不能用于接受发送给顶层activity的intent，这个新的activity的前一个activity被作为顶部activity。 FLAG_ACTIVITY_REORDER_TO_FRONT如果在Intent中设置，并传递给Context.startActivity()，这个标志将引发已经运行的Activity移动到历史stack的顶端。 例如，假设一个Task由四个Activity组成：A，B，C，D。如果D调用startActivity()来启动Activity B，那么，B会移动到历史stack的顶端，现在的次序变成A，C，D，B。如果FLAG_ACTIVITY_CLEAR_TOP标志也设置的话，那么这个标志将被覆盖。 FLAG_ACTIVITY_RESET_TASK_IF_NEEDED 这个标记在以下情况下会生效：1.启动Activity时创建新的task来放置Activity实例；2.已存在的task被放置于前台。系统会根据affinity对指定的task进行重置操作，task会压入某些Activity实例或移除某些Activity实例。我们结合上面的FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET可以加深理解。 FLAG_ACTIVITY_RETAIN_IN_RECENTS api21加入。 默认情况下通过FLAG_ACTIVITY_NEW_DOCUMENT启动的activity在关闭之后，task中的记录会相对应的删除。如果为了能够重新启动这个activity你想保留它，就可以使用者个flag，最近的记录将会保留在接口中以便用户去重新启动。接受该flag的activity可以使用autoRemoveFromRecents去复写这个request或者调用Activity.finishAndRemoveTask()方法。 FLAG_ACTIVITY_TASK_ON_HOME api11加入。 把当前新启动的任务置于Home任务之上，也就是按back键从这个任务返回的时候会回到home，即使这个不是他们最后看见的activity，注意这个标记必须和FLAG_ACTIVITY_NEW_TASK一起使用。 FLAG_EXCLUDE_STOPPED_PACKAGES 和 FLAG_INCLUDE_STOPPED_PACKAGES 在3.1之后，系统的package manager增加了对处于“stopped state”应用的管理，这个stopped和Activity生命周期中的stop状态是完全两码事，指的是安装后从来没有启动过和被用户手动强制停止的应用，与此同时系统增加了2个Flag：FLAG_INCLUDE_STOPPED_PACKAGES和FLAG_EXCLUDE_STOPPED_PACKAGES ，来标识一个intent是否激活处于“stopped state”的应用。当2个Flag都不设置或者都进行设置的时候，采用的是FLAG_INCLUDE_STOPPED_PACKAGES的效果。 FLAG_DEBUG_LOG_RESOLUTION将log置为可用状态，如果设置了这个flag，那么在处理这个intent的时候，将会打印相关创建日志。 FLAG_FROM_BACKGROUND 用来标识该intent的操作是一个后端的操作而不是一个直接的用户交互。 FLAG_GRANT_PERSISTABLE_URI_PERMISSION api19添加 当和FLAG_GRANT_READ_URI_PERMISSION 和/或FLAG_GRANT_WRITE_URI_PERMISSION一起使用时，uri权限在设置重启之后依然存在直到用户调用了revokeUriPermission(Uri, int)方法，这个标识仅为可能的存在状态提供许可，接受的应用必须要调用takePersistableUriPermission(Uri, int)方法去实际的变为存在状态。 FLAG_GRANT_PREFIX_URI_PERMISSION api21加入。 当和FLAG_GRANT_READ_URI_PERMISSION 和/或FLAG_GRANT_WRITE_URI_PERMISSION一起使用时，uri的许可只用匹配前缀即可（默认为全部匹配）。 FLAG_GRANT_READ_URI_PERMISSION 和 FLAG_GRANT_WRITE_URI_PERMISSION 如果设置FLAG_GRANT_READ_URI_PERMISSION这个标记,Intent的接受者将会被赋予读取Intent中URI数据的权限和lipData中的URIs的权限。当使用于Intent的ClipData时，所有的URIs和data的所有递归遍历或者其他Intent的ClipData数据都会被授权。FLAG_GRANT_WRITE_URI_PERMISSION同FLAG_GRANT_READ_URI_PERMISSION只是相应的赋予的是写权限。 一个典型的例子就是邮件程序处理带有附件的邮件。进入邮件需要使用permission来保护，因为这些是敏感的用户数据。然而，如果有一个指向图片附件的URI需要传递给图片浏览器，那个图片浏览器是不会有访问附件的权利的，因为他不可能拥有所有的邮件的访问权限。针对这个问题的解决方案就是per-URI permission：当启动一个activity或者给一个activity返回结果的时候，呼叫方可以设置Intent.FLAG_GRANT_READ_URI_PERMISSION和/或Intent.FLAG_GRANT_WRITE_URI_PERMISSION . 这会使接收该intent的activity获取到进入该Intent指定的URI的权限，而不论它是否有权限进入该intent对应的content provider。 FLAG_RECEIVER_FOREGROUND api16添加。 当发送广播时，允许其接受者拥有前台的优先级，更短的超时间隔。 FLAG_RECEIVER_NO_ABORT api19添加 如果这是一个有序广播，不允许接受者终止这个广播，它仍然能够传递给下面的接受者。 FLAG_RECEIVER_REGISTERED_ONLY 如果设置了这个flag，当发送广播的时，动态注册的接受者才会被调用，在Androidmanifest.xml 里定义的Receiver 是接收不到这样的Intent 的。 FLAG_RECEIVER_REPLACE_PENDING api8添加。 如果设置了的话，ActivityManagerService就会在当前的系统中查看有没有相同的intent还未被处理，如果有的话，就由当前这个新的intent来替换旧的intent，所以就会出现在发送一系列的这样的Intent 之后，中间有些Intent 有可能在你还没有来得及处理的时候， 就被替代掉了的情况]]></content>
      <categories>
        <category>android</category>
        <category>启动模式</category>
      </categories>
      <tags>
        <tag>Activity启动模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity启动模式（二）之 taskAffinity]]></title>
    <url>%2F2222880126%2F</url>
    <content type="text"><![CDATA[taskAffinity说明android:taskAffinity affinity，名称（ n.）， 密切关系；吸引力；姻亲关系；类同 taskAffinity，即与 Activity 有着亲和关系的任务。从概念上讲，具有相同亲和关系的 Activity 归属同一任务（从用户的角度来看，则是归属同一“应用”）。 任务的亲和关系由其根 Activity 的亲和关系确定。 亲和关系确定两件事 - Activity 更改到的父项任务（请参阅 allowTaskReparenting 属性）和通过 FLAG_ACTIVITY_NEW_TASK 标志启动 Activity 时将用来容纳它的任务。 默认情况下，应用中的所有 Activity 都具有相同的亲和关系。您可以设置该属性来以不同方式组合它们，甚至可以将在不同应用中定义的 Activity 置于同一任务内。 要指定 Activity 与任何任务均无亲和关系，请将其设置为空字符串。 如果未设置该属性，则 Activity 继承为应用设置的亲和关系（即 元素的 taskAffinity 属性，该属性与activity中的taskAffinity 属性效果一致，不同的是application中的该属性作用于所有activity。若activity中单独设置了taskAffinity 属性，则使用activity中的该属性）。 应用默认亲和关系的名称是 元素设置的软件包名称。 taskAffinity与四大启动模式四大启动模式的介绍请参考前文 Activity启动模式（一）之 launchMode点击查看：affinity测试源码从四大启动模式与Task的关系分析及taskAffinity的说明中，可以断定taskAffinity在standard、singleTop模式中是无效的；而singleInstance模式本就是全局唯一的，taskAffinity虽然会改变singleInstance模式启动的activity的taskAffinity值，但不会改变singleInstance模式的特性,也可简单地将singleInstance也归为无效。 那就仅剩下singleTask模式了。下文将详细介绍singleTask与taskAffinity的关系。 任务栈中的affinity信息可以查看上文 Activity启动模式（一）之 launchMode 中提到的shell命令。 简化信息命令为： adb shell dumpsys activity activities | sed -En -e ‘/Running activities/,/Run #0/p’ taskAffinity特点singleTask与taskAffinity之间的关系，其实已经在taskAffinity说明中全部介绍了。 两者的要点有如下： 任务的亲和关系由其根 Activity 的亲和关系确定 亲和关系是处理allowTaskReparenting和FLAG_ACTIVITY_NEW_TASK（singleTask）的依据，taskAffinity也主要和这两者配合使用。 未设置该属性，则 Activity 继承为应用（application）设置的亲和关系;若应用未设置该属性，则默认使用包名作为该属性值；若application和Activity中均设置了该属性，则以Activity中的属性为准。 该属性可以将在不同应用中定义的 Activity 置于同一任务内 将该属性设置为空字符串，可使指定 Activity 与任何任务均无亲和关系。有点像singleInstance的模式。单独使用一个任务栈，且其内只有指定 Activity的一个实例。 该属性要么为空字符串，要么其值之中至少包含一个“.”符号，否则apk无法通过编译安装 可将测试代码中的清单文件AffinitySingleInstanceActivity、AffinitySingleTopAActivity的taskAffinity改为空字符串，验证第5条结论。12345678910&lt;activity android:name=".activity.sample.lanchmode.advance.affinity.useless.AffinitySingleInstanceActivity" android:label="启动模式-singleInstance affinity A" android:launchMode="singleInstance" android:taskAffinity="" /&gt; &lt;activity android:name=".activity.sample.lanchmode.advance.affinity.useless.AffinitySingleTopAActivity" android:label="启动模式-singleTop affinity A" android:launchMode="singleTop" android:taskAffinity="" /&gt; singleTask的启动模式下流程如下： 而FLAG_ACTIVITY_NEW_TASK且指定了与包名不同的亲和性值后，有一条流程，结果有些特别。该流程如下所示： 是否存在需要的栈（Y）-&gt;栈内是否存在该Activity的实例（Y）-&gt;结果毫无反应 taskAffinity与allowTaskReparenting当启动 Activity 的任务接下来转至前台时，Activity 是否能从该任务转移至与其有亲和关系的任务 —“true”表示它可以转移，“false”表示它仍须留在启动它的任务处。 如果未设置该属性，则对 Activity 应用由 元素的相应 allowTaskReparenting 属性设置的值。 默认值为“false”。 正常情况下，当 Activity 启动时，会与启动它的任务关联，并在其整个生命周期中一直留在该任务处。您可以利用该属性强制 Activity 在其当前任务不再显示时将其父项更改为与其有亲和关系的任务。该属性通常用于使应用的 Activity 转移至与该应用关联的主任务。 举例说明：例如，如果电子邮件包含网页链接，则点击链接会调出可显示网页的 Activity。 该 Activity 由浏览器应用定义，但作为电子邮件任务的一部分启动。 如果将其父项更改为浏览器任务，它会在浏览器下一次转至前台时显示，当电子邮件任务再次转至前台时则会消失。 Activity 的亲和关系由 taskAffinity 属性定义。 任务的亲和关系通过读取其根 Activity 的亲和关系来确定。因此，按照定义，根 Activity 始终位于具有相同亲和关系的任务之中。 由于具有“singleTask”或“singleInstance”启动模式的 Activity 只能位于任务的根，因此更改父项仅限于“standard”和“singleTop”模式。 （另请参阅 launchMode属性。） android:allowTaskReparenting点击查看：allowTaskReparenting测试源码 allowTaskReparenting测试源码请查看两个application（LearnApplication、AppB），这两个app对应举例说明中的两个应用：电子邮件应用-LearnApplication，浏览器应用-AppB，其他对应关系为：电子邮件-MainActivity（LearnApplication），网页链接-MainActivity中的“allowTaskReparenting”条目，LearnApplication显示网页的 Activity-TestReparentActivity（AppB）。 具体操作流程为（前提：清除后台app、appb两个应用，确保流程正确） 点击LearnApplication应用logo，打开LearnApplication应用 点击“allowTaskReparenting”条目，LearnApplication应用会打开AppB的TestReparentActivity界面。 按home键 点击AppB应用，AppB应用会显示TestReparentActivity界面 点击返回键，TestReparentActivity销毁，并显示AppB应用的MainActivity界面 操作到第2步12345678910111213141516Task id #1540 TaskRecord&#123;16d20b3 #1540 A=com.nhtzj.learnapplication U=0 sz=2&#125; Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.nhtzj.learnapplication/.activity.main.MainActivity (has extras) &#125; Hist #1: ActivityRecord&#123;78adae5 u0 com.nhtzj.appb/.sample.TestReparentActivity t1540&#125; Intent &#123; cmp=com.nhtzj.appb/.sample.TestReparentActivity &#125; ProcessRecord&#123;8dfa670 21197:com.nhtzj.appb/u0a267&#125; Hist #0: ActivityRecord&#123;e19b029 u0 com.nhtzj.learnapplication/.activity.main.MainActivity t1540&#125; Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.nhtzj.learnapplication/.activity.main.MainActivity bnds=[820,363][1002,545] (has extras) &#125; ProcessRecord&#123;6902de9 21113:com.nhtzj.learnapplication/u0a59&#125; Running activities (most recent first): TaskRecord&#123;16d20b3 #1540 A=com.nhtzj.learnapplication U=0 sz=2&#125; Run #1: ActivityRecord&#123;78adae5 u0 com.nhtzj.appb/.sample.TestReparentActivity t1540&#125; Run #0: ActivityRecord&#123;e19b029 u0 com.nhtzj.learnapplication/.activity.main.MainActivity t1540&#125; mResumedActivity: ActivityRecord&#123;78adae5 u0 com.nhtzj.appb/.sample.TestReparentActivity t1540&#125; 操作到第4步12345678910111213141516171819202122Task id #1542 TaskRecord&#123;468514d #1542 A=com.nhtzj.appb U=0 sz=2&#125; Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.nhtzj.appb/.sample.MainActivity (has extras) &#125; Hist #1: ActivityRecord&#123;78adae5 u0 com.nhtzj.appb/.sample.TestReparentActivity t1542&#125; Intent &#123; cmp=com.nhtzj.appb/.sample.TestReparentActivity &#125; ProcessRecord&#123;8dfa670 21197:com.nhtzj.appb/u0a267&#125; Hist #0: ActivityRecord&#123;3fc1c3e u0 com.nhtzj.appb/.sample.MainActivity t1542&#125; Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.nhtzj.appb/.sample.MainActivity bnds=[76,625][258,807] (has extras) &#125; Task id #1540 TaskRecord&#123;16d20b3 #1540 A=com.nhtzj.learnapplication U=0 sz=1&#125; Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.nhtzj.learnapplication/.activity.main.MainActivity (has extras) &#125; Hist #0: ActivityRecord&#123;e19b029 u0 com.nhtzj.learnapplication/.activity.main.MainActivity t1540&#125; Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.nhtzj.learnapplication/.activity.main.MainActivity bnds=[820,363][1002,545] (has extras) &#125; ProcessRecord&#123;6902de9 21113:com.nhtzj.learnapplication/u0a59&#125; Running activities (most recent first): TaskRecord&#123;468514d #1542 A=com.nhtzj.appb U=0 sz=2&#125; Run #1: ActivityRecord&#123;78adae5 u0 com.nhtzj.appb/.sample.TestReparentActivity t1542&#125; TaskRecord&#123;16d20b3 #1540 A=com.nhtzj.learnapplication U=0 sz=1&#125; Run #0: ActivityRecord&#123;e19b029 u0 com.nhtzj.learnapplication/.activity.main.MainActivity t1540&#125; mResumedActivity: ActivityRecord&#123;78adae5 u0 com.nhtzj.appb/.sample.TestReparentActivity t1542&#125; 操作到第5步12345678910111213TaskRecord&#123;16d20b3 #1540 A=com.nhtzj.learnapplication U=0 sz=1&#125; Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.nhtzj.learnapplication/.activity.main.MainActivity (has extras) &#125; Hist #0: ActivityRecord&#123;e19b029 u0 com.nhtzj.learnapplication/.activity.main.MainActivity t1540&#125; Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.nhtzj.learnapplication/.activity.main.MainActivity bnds=[820,363][1002,545] (has extras) &#125; ProcessRecord&#123;6902de9 21113:com.nhtzj.learnapplication/u0a59&#125; Running activities (most recent first): TaskRecord&#123;468514d #1542 A=com.nhtzj.appb U=0 sz=1&#125; Run #1: ActivityRecord&#123;3fc1c3e u0 com.nhtzj.appb/.sample.MainActivity t1542&#125; TaskRecord&#123;16d20b3 #1540 A=com.nhtzj.learnapplication U=0 sz=1&#125; Run #0: ActivityRecord&#123;e19b029 u0 com.nhtzj.learnapplication/.activity.main.MainActivity t1540&#125; mResumedActivity: ActivityRecord&#123;3fc1c3e u0 com.nhtzj.appb/.sample.MainActivity t1542&#125; 若第4步改为：点击LearnApplication应用，则显示LearnApplication应用主界面（LearnMainActivity）新第5步：按home键新第6步：点击AppB应用，则显示TestReparentActivity界面]]></content>
      <categories>
        <category>android</category>
        <category>启动模式</category>
      </categories>
      <tags>
        <tag>Activity启动模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破解软件收集]]></title>
    <url>%2F2779984340%2F</url>
    <content type="text"><![CDATA[前言仅供个人使用，文件放于云主机免费硬盘上，下载速度受限。 Mac软件 Beyond Compare 4.3.4(24657)本地下载 IntelliJ IDEA 官网下载包（小编使用的IntelliJ IDEA 是2020.1）+ 破解 本地下载 Parallels Desktop 网盘下载 ｜ 本地下载 Parallels_Desktop_启动器_（解决Big_Sur_PD不能联网）本地下载 Navicat for MySQL 12.0.16 本地下载 密码：xclient.info Movist Pro 2.6.6 本地下载 PC软件 SourceInsight40120 本地下载 破解软件下载平台https://xclient.info]]></content>
      <categories>
        <category>收集</category>
      </categories>
      <tags>
        <tag>收集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity启动模式（一）之 launchMode]]></title>
    <url>%2F1459607507%2F</url>
    <content type="text"><![CDATA[launchMode简介Activity启动模式，即Activity启动的方式。 lauchMode可以配置在清单文件AndroidManifest.xml文件中。 也可通过java代码动态配置。 知识储备任务栈（Task）在讲解Activity启动模式前，先讲解下Activity的管理方式：任务栈（Task），这有利于我们理解Activity启动模式。 采用任务栈任务栈（Task）的形式管理Activity 任务栈采用“先进后出”的栈结构 每按一次Back键或finish一个Activity，就有一个栈顶的Activity出栈 终端使用adb shell指令Android还为开发者提供了adb(Android Debug Bridge)，这是非常强大的调试工具。最常用的自然是logcat来显示日志记录。另外一个很强大的指令就是这里要提到的dumpsys。dumpsys还可以添加不同的参数来指示需要输出哪一类Service的信息。对于本文提到的内容，需要查看的就是activity。 adb shell dumpsys activity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 ACTIVITY MANAGER PENDING INTENTS (dumpsys activity intents) //注意一下 * PendingIntentRecord&#123;c8486ed com.xiaomi.xmsf startService&#125; * PendingIntentRecord&#123;dd7d922 com.xiaomi.xmsf startService&#125; * PendingIntentRecord&#123;b5bffb3 android broadcastIntent&#125; // 省略 N 行 ...ACTIVITY MANAGER BROADCAST STATE (dumpsys activity broadcasts) //注意一下 Historical broadcasts [foreground]: #0: BroadcastRecord&#123;88e1b3a u-1 android.intent.action.TIME_TICK&#125; act=android.intent.action.TIME_TICK flg=0x50000014 (has extras) extras: Bundle[&#123;android.intent.extra.ALARM_COUNT=1&#125;] #1: BroadcastRecord&#123;9a973eb u-1 android.intent.action.TIME_TICK&#125; act=android.intent.action.TIME_TICK flg=0x50000014 (has extras) extras: Bundle[&#123;android.intent.extra.ALARM_COUNT=1&#125;] // 省略 N 行 ...ACTIVITY MANAGER CONTENT PROVIDERS (dumpsys activity providers) //注意一下 Published single-user content providers (by class): * ContentProviderRecord&#123;2af5291 u0 com.android.providers.telephony/.TelephonyProvider&#125; proc=ProcessRecord&#123;108d60f 4086:com.android.phone/1001&#125; singleton=true authority=telephony // 省略 N 行 ...ACTIVITY MANAGER URI PERMISSIONS (dumpsys activity permissions) //注意一下 Granted Uri Permissions: * UID 1000 holds: UriPermission&#123;e61888e 0 @ content://downloads/all_downloads/125&#125; UriPermission&#123;2f698af 0 @ content://downloads/all_downloads/126&#125; // 省略 N 行 ...ACTIVITY MANAGER SERVICES (dumpsys activity services) //注意一下 User 0 active services: * ServiceRecord&#123;2e1e671 u0 com.android.bluetooth/.hid.HidService&#125; app=ProcessRecord&#123;b328630 4915:com.android.bluetooth/1002&#125; created=-3d15h37m1s744ms started=true connections=1 Connections: act=android.bluetooth.IBluetoothInputDevice -&gt; 2989:com.android.systemui/1000 // 省略 N 行 ...ACTIVITY MANAGER RECENT TASKS (dumpsys activity recents) //注意一下 Recent tasks: * Recent #0: TaskRecord&#123;f3e16fb #1558 A=com.nhtzj.appb U=0 sz=1&#125; * Recent #1: TaskRecord&#123;663d296 #1405 A=com.miui.home U=0 sz=1&#125; * Recent #2: TaskRecord&#123;1a325b8 #1557 A=com.nhtzj.learnapplication U=0 sz=1&#125; * Recent #3: TaskRecord&#123;141234a #1427 A=.delinstalledapk U=0 sz=0&#125; * Recent #4: TaskRecord&#123;6b8c2bb #1425 A=com.miui.packageinstaller U=0 sz=0&#125; * Recent #5: TaskRecord&#123;fa213d8 #1406 A=android.task.stk.StkLauncherActivity U=0 sz=0&#125; // 省略 N 行 ...ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities) //注意一下Display #0 (activities from top to bottom): Stack #23: Task id #1558 TaskRecord&#123;f3e16fb #1558 A=com.nhtzj.appb U=0 sz=1&#125; Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.nhtzj.appb/.sample.MainActivity (has extras) &#125; Hist #0: ActivityRecord&#123;e4adca6 u0 com.nhtzj.appb/.sample.MainActivity t1558&#125; Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.nhtzj.appb/.sample.MainActivity bnds=[76,625][258,807] (has extras) &#125; ProcessRecord&#123;36e1c21 9302:com.nhtzj.appb/u0a267&#125; // 省略 N 行 ...ACTIVITY MANAGER RUNNING PROCESSES (dumpsys activity processes) //注意一下 Isolated process list (sorted by uid): Isolated # 0: ProcessRecord&#123;284e1aa 2979:WebViewLoader-armeabi-v7a/1037&#125; UID states: UID 1000: UidRecord&#123;2d2119b 1000 P procs:13&#125; UID 1001: UidRecord&#123;db0e938 1001 P procs:2&#125; // 省略 N 行 ... 该命令返回一大串内容，但也能清晰看出它们比较详细的分类 每一个类别都有一个括号内容，给出了更加详细的指令来查看该类别下更多具体内容。 比如本次用到的类别：ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities) 括号内的dumpsys activity activities为activity的详细指令。 因此再来尝试指令： db shell dumpsys activity activities12345678910111213141516171819202122232425262728293031323334353637383940ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)Display #0 (activities from top to bottom): Stack #12: Task id #1302 * TaskRecord&#123;5fb98dc #1302 A=com.nhtzj.learnapplication U=0 sz=3&#125; userId=0 effectiveUid=u0a238 mCallingUid=2000 mCallingPackage=null affinity=com.nhtzj.learnapplication intent=&#123;act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10000000 cmp=com.nhtzj.learnapplication/.activity.main.MainActivity&#125; realActivity=com.nhtzj.learnapplication/.activity.main.MainActivity autoRemoveRecents=false isPersistable=true numFullscreen=3 taskType=0 mTaskToReturnTo=1 rootWasReset=false mNeverRelinquishIdentity=true mReuseTask=false mLockTaskAuth=LOCK_TASK_AUTH_PINNABLE Activities=[ActivityRecord&#123;772a6cc u0 com.nhtzj.learnapplication/.activity.main.MainActivity t1302&#125;, ActivityRecord&#123;182f696 u0 com.nhtzj.learnapplication/.activity.sample.lanchmode.standard.StandardActivity t1302&#125;, ActivityRecord&#123;d4a426e u0 com.nhtzj.learnapplication/.activity.sample.lanchmode.standard.StandardActivity t1302&#125;] askedCompatMode=false inRecents=true isAvailable=true lastThumbnail=null lastThumbnailFile=/data/system/recent_images/1302_task_thumbnail.png stackId=12 hasBeenVisible=true mResizeable=false firstActiveTime=1524119334682 lastActiveTime=1524119334682 (inactive for 147s) * Hist #2: ActivityRecord&#123;d4a426e u0 com.nhtzj.learnapplication/.activity.sample.lanchmode.standard.StandardActivity t1302&#125; packageName=com.nhtzj.learnapplication processName=com.nhtzj.learnapplication launchedFromUid=10238 launchedFromPackage=com.nhtzj.learnapplication userId=0 app=ProcessRecord&#123;32912fe 28815:com.nhtzj.learnapplication/u0a238&#125; Intent &#123; cmp=com.nhtzj.learnapplication/.activity.sample.lanchmode.standard.StandardActivity &#125; frontOfTask=false task=TaskRecord&#123;5fb98dc #1302 A=com.nhtzj.learnapplication U=0 sz=3&#125; taskAffinity=com.nhtzj.learnapplication realActivity=com.nhtzj.learnapplication/.activity.sample.lanchmode.standard.StandardActivity baseDir=/data/app/com.nhtzj.learnapplication-2/base.apk dataDir=/data/user/0/com.nhtzj.learnapplication stateNotNeeded=false componentSpecified=true mActivityType=0 compat=&#123;480dpi&#125; labelRes=0x0 icon=0x7f0b0000 theme=0x7f0d0005 config=&#123;1.0 460mcc7mnc zh_CN ldltr sw360dp w360dp h576dp 480dpi nrml port finger -keyb/v/h -nav/h s.41 themeChanged=0 themeChangedFlags=0&#125; stackConfigOverride=&#123;1.0 ?mcc?mnc ?locale ?layoutDir ?swdp ?wdp ?hdp ?density ?lsize ?long ?orien ?uimode ?night ?touch ?keyb/?/? ?nav/? themeChanged=0 themeChangedFlags=0&#125; taskDescription: iconFilename=null label="null" color=ff3f51b5 launchFailed=false launchCount=1 lastLaunchTime=-2m27s763ms haveState=false icicle=null state=RESUMED stopped=false delayedResume=false finishing=false keysPaused=false inHistory=true visible=true sleeping=false idle=true fullscreen=true noDisplay=false immersive=false launchMode=0 frozenBeforeDestroy=false forceNewConfig=false mActivityType=APPLICATION_ACTIVITY_TYPE waitingVisible=false nowVisible=true lastVisibleTime=-2m27s389ms realComponentName=com.nhtzj.learnapplication/.activity.sample.lanchmode.standard.StandardActivity 整个log显示了当前所有在运行的任务栈，它们的id分别是什么。对于每个Task，也有Activity数量等信息，同时也列出了其中的Activity列表，并且对于每个Activity也有比较详细的描述，比如启动它的Intent的内容。 如果觉得内容过多，只想看看栈的内容，也可以直接跳到”Running activities (most recent first)”那部分，比较简洁而又明了的列出了栈中得Activity列表，就能知道当按下返回键的时候会应该会回到哪个Activity以后是要退出程序。 对于”Running activities”的内容在dumpsys activity中就有，并不需要dumpsys activity activities，也可以用下边的指令来限制仅输出”Running activities”列表： adb shell dumpsys activity activities | sed -En -e ‘/Running activities/,/Run #0/p’123456789➜ ~ adb shell dumpsys activity activities | sed -En -e '/Running activities/,/Run #0/p' Running activities (most recent first): TaskRecord&#123;5fb98dc #1302 A=com.nhtzj.learnapplication U=0 sz=3&#125; Run #2: ActivityRecord&#123;d4a426e u0 com.nhtzj.learnapplication/.activity.sample.lanchmode.standard.StandardActivity t1302&#125; Run #1: ActivityRecord&#123;182f696 u0 com.nhtzj.learnapplication/.activity.sample.lanchmode.standard.StandardActivity t1302&#125; Run #0: ActivityRecord&#123;772a6cc u0 com.nhtzj.learnapplication/.activity.main.MainActivity t1302&#125; Running activities (most recent first): TaskRecord&#123;77ff1c8 #4 A=com.miui.home U=0 sz=1&#125; Run #0: ActivityRecord&#123;98a1459 u0 com.miui.home/.launcher.Launcher t4&#125; 其中，TaskRecord中的“A=”的值，即为taskAffinity设定的值。 taskAffinity的说明，请参考下文Activity启动模式之 taskAffinity 四大启动模式 code 简介 standard 标准模式 singleTop 栈顶复用模式 singleTask 栈内复用模式 singleInstance 单例模式 具体介绍点击查看：lanchMode测试源码 标准模式（standard）标准模式,每次启动Activity都会创建一个新的Activity实例,并且将其压入任务栈栈顶,而不管这个Activity是否已经存在。并且存在于 启动它的Activity实例所在的task之中。 标准模式为activity的默认启动方式，在清单文件中可以不写明。即默认为“standard”。 清单文件配置 1234 &lt;activityandroid:name=".activity.sample.lanchmode.standard.StandardActivity" android:label="启动模式-standard" android:launchMode="standard" /&gt; 或 不写明123&lt;activity android:name=".activity.sample.lanchmode.standard.StandardActivity" android:label="启动模式-standard"/&gt; task中的形式如下： 栈顶复用模式（singleTop） 如果需要新建的Activity位于任务栈栈顶，那么此Activity的实例就不会重建，而是重用栈顶的实例( 调用实例的 onNewIntent() 、不调用onCreate()和onStart())。 否则就会创建该Activity新的实例，并放入栈顶 流程图如下： 栈内复用模式（singleTask）官方说明： The system creates the activity at the root of a new task and routes the intent to it. However, if an instance of the activity already exists, the system routes the intent to existing instance through a call to its onNewIntent() method, rather than creating a new one. 翻译过来就是： 在singleTask模式下，如果是第一次创建该Activity实例时，则会新建task并将该Activity添加到该task中。否则(该Activity的实例已存在)，则会将栈内该Activity实例之后加入的Activity关闭，并打开已有的Activity实例，并调用Activity的onNewIntent()方法，而不会新建Activity实例。 流程图如下： 单例模式（singleInstance） 栈内复用模式（singleTask）的强化，该模式下全局仅有一个实例 打开该Activity时，直接创建一个新的任务栈，并创建该Activity实例放入新栈中 一旦该模式的Activity实例已经存在于某个栈中，任何应用再激活该Activity时都会重用该栈中的实例 使用场景：多个应用共享一个应用，不管谁激活该 Activity 都会进入同一个应用中。使用场景如闹铃提醒，将闹铃提醒与闹铃设置分离。 官方介绍android:launchMode (本地)android:launchMode （developer.android.com，需翻墙） 总结 唯一性从小到大：standard &lt; singleTop &lt; singleTask &lt; singleInstance standard：无限制 singleTop：栈顶唯一 singleTask：栈内唯一 singleInstance：全局唯一 singleTop、singleTask、singleInstance重用时不会重走整个生命周期 singleTop:onPause &gt; onNewIntent &gt; onResume singleTask(位于栈顶):同singleTop一致 singleTask(没有位于栈顶):onNewIntent &gt; onRestart &gt; onStart &gt; onResume singleInstance(singleInstance实例可见，即处于前台):同singleTop一致 singleInstance(singleInstance实例不可见，即处于后台)：同 singleTask(没有位于栈顶) 一致]]></content>
      <categories>
        <category>android</category>
        <category>启动模式</category>
      </categories>
      <tags>
        <tag>Activity启动模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网址收集]]></title>
    <url>%2F3223491470%2F</url>
    <content type="text"><![CDATA[生活类 VIP大哥网 | 腾讯视频、爱奇艺、芒果、网易云、迅雷、PPTV、百度云等vip账号共享 VIP分享网论坛|迅雷、腾讯视频、芒果vip账号共享 Google Play 应用下载网站 http://www.hsweb.me/ 工具类 翻墙工具shadowsocks Android版Shadowsocks github下载、本地下载 Mac版ShadowsocksX-NG github下载、本地下载]]></content>
      <categories>
        <category>收集</category>
      </categories>
      <tags>
        <tag>收集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App 在线更新适配（Android 6.0、Android7.0，Android8.0）]]></title>
    <url>%2F4229889625%2F</url>
    <content type="text"><![CDATA[前言本篇仅介绍关于代码更新App所需要考虑的适配问题，不介绍如何下载App文件，也不介绍关于Android6.0动态权限申请的流程（apk文件存放于外部存储上，需要Manifest.permission.WRITE_EXTERNAL_STORAGE 权限）。 Android8.0添加了“未知来源的应用权限”的权限（Manifest.permission.REQUEST_INSTALL_PACKAGES）。本篇暂不做详细说明。 也就是说，本文前提： 该App已获取WRITE_EXTERNAL_STORAGE 和 REQUEST_INSTALL_PACKAGES 权限。 Android6.0之后的动态权限申请，小编推荐使用AndPermission,AndPermission中文文档 apk文件已下载完成， 路径为 String mSavePath = Environment.getExternalStorageDirectory().getPath() + File.separator + “apk” + File.separator; 文件名称为 String mFileName = “test.apk”; 代码调用apk安装工具类AppUtils.installApp(Context context, File file)1234567/** * 安装APK文件 */private void installApk() &#123; File apkfile = new File(mSavePath, mFileName); AppUtils.installApp(context, apkfile);&#125; AppUtils.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 public final class AppUtils &#123; private AppUtils() &#123; throw new UnsupportedOperationException("u can't instantiate me..."); &#125;​ /** * 安装App(支持6.0) * * @param context 上下文 * @param filePath 文件路径 */ public static void installApp(Context context, String filePath) &#123; installApp(context, FileUtils.getFileByPath(filePath)); &#125; /** * 安装App（支持6.0） * * @param context 上下文 * @param file 文件 */ public static void installApp(Context context, File file) &#123; if (!FileUtils.isFileExists(file)) return; context.startActivity(IntentUtils.getInstallAppIntent(context, file)); &#125; /** * 安装App（支持6.0） * * @param activity activity * @param filePath 文件路径 * @param requestCode 请求值 */ public static void installApp(Activity activity, String filePath, int requestCode) &#123; installApp(activity, FileUtils.getFileByPath(filePath), requestCode); &#125; /** * 安装App(支持6.0) * * @param activity activity * @param file 文件 * @param requestCode 请求值 */ public static void installApp(Activity activity, File file, int requestCode) &#123; if (!FileUtils.isFileExists(file)) return; activity.startActivityForResult(IntentUtils.getInstallAppIntent(activity , file), requestCode); &#125; &#125; IntentUtils.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * &lt;pre&gt; * author : Haitao * blog : http://blog.nhtzj.com * time : 2018/2/7 * desc : 意图相关工具类 * version: 2.0 * &lt;/pre&gt; */public class IntentUtils &#123; private IntentUtils() &#123; throw new UnsupportedOperationException("u can't fuck me..."); &#125; /** * 获取安装App（支持6.0）的意图 * * @param filePath 文件路径 * @return intent */ public static Intent getInstallAppIntent(Context context , String filePath) &#123; return getInstallAppIntent(context , FileUtils.getFileByPath(filePath)); &#125; /** * 获取安装App(支持6.0)的意图 * * @param file 文件 * @return intent */ public static Intent getInstallAppIntent(Context context , File file) &#123; if (file == null) return null; Intent intent = new Intent(Intent.ACTION_VIEW); String type; if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M) &#123; // 小于Android 6.0 type = "application/vnd.android.package-archive"; &#125; else &#123; type = MimeTypeMap.getSingleton().getMimeTypeFromExtension(FileUtils.getFileExtension(file)); &#125; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123; //大于等于Android 7.0 intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); Uri contentUri = FileProvider.getUriForFile(context , BuildConfig.APPLICATION_ID + ".provider", file); intent.setDataAndType(contentUri, type); &#125; else &#123; intent.setDataAndType(Uri.fromFile(file), type); &#125; return intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); &#125;&#125; FileUtils.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public final class FileUtils &#123; /** * 根据文件路径获取文件 * * @param filePath 文件路径 * @return 文件 */ public static File getFileByPath(String filePath) &#123; return isSpace(filePath) ? null : new File(filePath); &#125; private static boolean isSpace(String s) &#123; if (s == null) return true; for (int i = 0, len = s.length(); i &lt; len; ++i) &#123; if (!Character.isWhitespace(s.charAt(i))) &#123; return false; &#125; &#125; return true; &#125; /** * 获取全路径中的文件拓展名 * * @param file 文件 * @return 文件拓展名 */ public static String getFileExtension(File file) &#123; if (file == null) return null; return getFileExtension(file.getPath()); &#125; /** * 获取全路径中的文件拓展名 * * @param filePath 文件路径 * @return 文件拓展名 */ public static String getFileExtension(String filePath) &#123; if (isSpace(filePath)) return filePath; int lastPoi = filePath.lastIndexOf('.'); int lastSep = filePath.lastIndexOf(File.separator); if (lastPoi == -1 || lastSep &gt;= lastPoi) return ""; return filePath.substring(lastPoi + 1); &#125;&#125; 适配Android 7.0在Android 7.0上，对文件的访问权限作出了修改，不能在使用file://格式的Uri 访问文件 ，Android 7.0提供 FileProvider,应该使用这个来获取apk地址 在res 目录下，新建一个xml 文件夹，在xml 下面创建一个文件provider_paths文件 provider_paths.xml 123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;paths xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;external-path name="external_files" path="." /&gt;&lt;/paths&gt; 之后在清单文件中添加123456789&lt;provider android:name="android.support.v4.content.FileProvider" android:authorities="$&#123;applicationId&#125;.provider" android:exported="false" android:grantUriPermissions="true"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/provider_paths" /&gt; &lt;/provider&gt; Android 8.0适配Android 8.0适配请参考Android app 在线更新那点事儿（适配Android6.0、7.0、8.0）的第5段：“五、适配Android 8.0：未知来源的应用权限”。 该篇介绍了使用SDK自带的下载类DownloadManager来下载apk。而小编这篇是借助三方框架okhttp直接下载到指定位置，故有前言中提到的第二个条件。]]></content>
      <categories>
        <category>android</category>
        <category>适配</category>
      </categories>
      <tags>
        <tag>适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云对象存储 OSS 绑定域名]]></title>
    <url>%2F3623267463%2F</url>
    <content type="text"><![CDATA[阿里云对象存储 OSS 简介阿里云对象存储 OSS（以下简称为：oss），在读写权限设置为公共读后，便可通过外网域名访问。 本篇主要是讲解并记录跨账号绑定域名。 不过先从基础的讲起。 域名访问的域名格式是：Bucket名称+“.”+EndPoint 比如： 我的Bucket名称为nht，EndPoint为oss-cn-shanghai.aliyuncs.com， 则访问域名为nht.oss-cn-shanghai.aliyuncs.com 使用说明： 访问域名带上文件路径，即可通过互联网访问到 Bucket 内的任意文件。如果 ACL 是私有读，则还需要带上签名，URL 拼写规则：nht.oss-cn-shanghai.aliyuncs.com/object 默认情况下，访问文件包含两个部分：OSS域名地址+对象文件名 比如访问 /blog/w3lho-bx6ae.gif 文件的访问地址为： http://nht.oss-cn-shanghai.aliyuncs.com/blog/w3lho-bx6ae.gif 绑定自定义域名（file.nhtzj.com）后，则该对象的访问地址为：http://file.nhtzj.com/blog/w3lho-bx6ae.gif 绑定域名操作步骤 进入 OSS 管理控制台 界面。 在左侧存储空间列表中，单击目标存储空间名称，打开该存储空间概览页面。 单击域名管理页签。 单击绑定用户域名，打开绑定用户域名页面。如下图所示。 同账户下的域名可自动添加CHAME解析 绑定域名。 i. 在用户域名框中，输入要绑定的域名名称。 ii. 如果需要CDN加速，开启阿里云 CDN 加速。如何开启请参考：OSS如何开启CDN加速服务。 说明：关于CDN加速的详细介绍，请参考最佳实践 CDN加速OSS。 iii. 选择是否需要自动添加 CNAME 记录。 注意：当您输入的域名（二级域名部分）已在其他阿里云账号下配置过云解析，则跨账号绑定域名 时不支持自动添加云解析，您需要手动添加CNAME记录。具体操作请参见域名解析操作步骤。 单击 提交。 域名解析操作步骤 登录云解析 DNS 控制台进入域名解析列表页面。 单击目标域名对应的解析，打开域名解析页面。 单击添加解析，打开添加解析页面。 在记录类型下拉列表中，选择CNAME；在记录值框中，填写对应的存储空间外网域名。 单击确认。域名解析完成。 跨账号绑定域名阿里账号：A A账号下： oss Bucket 名称：nht oss 外网访问域名：nht.oss-cn-shanghai.aliyuncs.com 阿里账号：B B账号下： 域名：aaaa.com 现在要给A账号下的oss绑定 B账号下的aaaa.com 的二级域名file.aaaa.com 参照绑定域名操作步骤,将步骤4中的“用户域名”填写为“file.aaaa.com” 参照域名解析操作步骤,进入aaaa.com的域名解析。 2.1 “主机记录”输入我们指定的二级域名“file”，“.aaaa.com”为固定项，不用输入。 2.2 将“记录值”内填入A账号下oss 外网访问域名 “nht.oss-cn-shanghai.aliyuncs.com”。 2.3 其他配置与域名解析操作步骤一致。 这样，就可以使用file.aaaa.com二级域名替换A账号下oss 外网访问域名：nht.oss-cn-shanghai.aliyuncs.com，进行A账号下oss内的文件的访问。 官方文档 管理域名]]></content>
      <categories>
        <category>OSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[加载动画及占位图 EmptyLayout]]></title>
    <url>%2F1023507363%2F</url>
    <content type="text"><![CDATA[前言在android开发中，对于网络加载、本地数据加载等耗时任务时，为了更好的用户体验，会先给用户展示一些等待图或者动画一类的占位图。对于列表更是需要处理空数据等其他异常情况。本篇的主角 EmptyLayout 就是由此而生。 借鉴：oschina 先上效果 直接上代码代码位置 EmptyLayout.java该控件主要是setErrorType方法，控制显示类型。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190public class EmptyLayout extends LinearLayout implements View.OnClickListener &#123; public static final int NETWORK_ERROR = 1; // 网络异常 public static final int NETWORK_LOADING = 2;//加载中 public static final int NODATA = 3;//暂无数据 public static final int HIDE_LAYOUT = 4;//隐藏该控件 public static final int NO_LOGIN = 5;//未登录 private Loading mLoading; private boolean clickEnable = true; private final Context context; public ImageView img; private int mErrorState; private String strNoDataContent = ""; private TextView tv; private boolean mLoadingLocalFriend; private OnViewClick listener; public EmptyLayout(Context context) &#123; super(context); this.context = context; init(); &#125; public EmptyLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); this.context = context; init(); &#125; private void init() &#123; View view = LayoutInflater.from(getContext()).inflate(R.layout.widget_empty_layout, this, false); img = (ImageView) view.findViewById(R.id.img_error_layout); tv = (TextView) view.findViewById(R.id.tv_error_layout); mLoading = (Loading) view.findViewById(R.id.animProgress); setBackgroundColor(-1); setOnClickListener(this); img.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; if (clickEnable &amp;&amp; mErrorState != NETWORK_LOADING) &#123; if (listener != null) listener.onViewClick(v); &#125; &#125; &#125;); addView(view); &#125; public void dismiss() &#123; mErrorState = HIDE_LAYOUT; setVisibility(View.GONE); &#125; public int getErrorState() &#123; return mErrorState; &#125; public boolean isLoadError() &#123; return mErrorState == NETWORK_ERROR; &#125; public boolean isLoading() &#123; return mErrorState == NETWORK_LOADING; &#125; @Override public void onClick(View v) &#123; if (clickEnable &amp;&amp; mErrorState != NETWORK_LOADING) &#123; if (listener != null) listener.onViewClick(v); &#125; &#125; /** * 修改提示文本 * * @param msg */ public void setErrorMessage(String msg) &#123; tv.setText(msg); &#125; /** * 修改提示文本 * * @param loadingLocalFriend */ public void setLoadingLocalFriend(boolean loadingLocalFriend) &#123; this.mLoadingLocalFriend = loadingLocalFriend; tv.setText(R.string.error_view_loading_local_friend); &#125; /** * 修改显示图片 * * @param imgResource */ public void setErrorImg(int imgResource) &#123; try &#123; img.setImageResource(imgResource); &#125; catch (Exception e) &#123; &#125; &#125; /** * 修改显示类型 * * @param i */ public void setErrorType(int i) &#123; if (HIDE_LAYOUT == i &amp;&amp; HIDE_LAYOUT == mErrorState) &#123; return; &#125; setVisibility(View.VISIBLE); switch (i) &#123; case NETWORK_ERROR: mErrorState = NETWORK_ERROR; if (TDevice.hasInternet(context)) &#123; tv.setText(R.string.error_view_load_error_click_to_refresh); img.setBackgroundResource(R.drawable.page_tip_fail); &#125; else &#123; tv.setText(R.string.tip_network_error); img.setBackgroundResource(R.drawable.page_tip_network); &#125; img.setVisibility(View.VISIBLE); mLoading.stop(); mLoading.setVisibility(View.GONE); clickEnable = true; break; case NETWORK_LOADING: mErrorState = NETWORK_LOADING; mLoading.setVisibility(View.VISIBLE); mLoading.start(); img.setVisibility(View.GONE); if (mLoadingLocalFriend) &#123; tv.setText(R.string.error_view_loading_local_friend); &#125; else &#123; tv.setText(R.string.error_view_loading); &#125; clickEnable = false; break; case NODATA: mErrorState = NODATA; img.setBackgroundResource(R.drawable.page_icon_empty); img.setVisibility(View.VISIBLE); mLoading.stop(); mLoading.setVisibility(View.GONE); setTvNoDataContent(); clickEnable = true; break; case HIDE_LAYOUT: mLoading.stop(); setVisibility(View.GONE); break; default: break; &#125; &#125; public void setNoDataContent(String noDataContent) &#123; strNoDataContent = noDataContent; &#125; public void setOnLayoutClickListener(OnViewClick listener) &#123; this.listener = listener; &#125; public void setTvNoDataContent() &#123; if (!strNoDataContent.equals("")) tv.setText(strNoDataContent); else tv.setText(R.string.error_view_no_data); &#125; @Override public void setVisibility(int visibility) &#123; if (visibility == View.GONE) mErrorState = HIDE_LAYOUT; super.setVisibility(visibility); &#125; public static interface OnViewClick &#123; void onViewClick(View v); &#125;&#125; layout widget_empty_layout.xml其中Loading为加载动画，也可用ProgressBar替换 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/layout_error" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#FFF" android:gravity="center" android:orientation="vertical"&gt; &lt;ImageView android:id="@+id/img_error_layout" android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="@drawable/page_tip_network" android:visibility="gone" tools:visibility="visible" /&gt; &lt;com.nhtzj.learnapplication.widget.loading.Loading android:id="@+id/animProgress" android:layout_width="26dip" android:layout_height="26dip" /&gt; &lt;TextView android:id="@+id/tv_error_layout" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" android:layout_marginTop="10.0dip" android:gravity="center" android:lines="2" android:text="@string/error_view_loading" android:textColor="@color/txt_color_gray" android:textSize="@dimen/sp_14" /&gt;&lt;/LinearLayout&gt; values123456789101112&lt;string name="error_view_no_data"&gt;暂无内容&lt;/string&gt;&lt;string name="error_view_loading"&gt;加载中…&lt;/string&gt;&lt;string name="error_view_loading_local_friend"&gt;获取附近的程序员中…&lt;/string&gt;&lt;string name="error_view_load_error_click_to_refresh"&gt;内容加载失败\r\n点击重新加载&lt;/string&gt; &lt;string name="tip_network_error"&gt;没有可用的网络&lt;/string&gt;&lt;string name="loading"&gt;加载中…&lt;/string&gt; &lt;dimen name="g_loading_lineSize"&gt;2dp&lt;/dimen&gt; &lt;dimen name="g_loading_minSize"&gt;28dp&lt;/dimen&gt; &lt;dimen name="g_loading_maxSize"&gt;40dp&lt;/dimen&gt; &lt;dimen name="sp_14"&gt;14sp&lt;/dimen&gt; 源码下载海的那边 / learn]]></content>
      <categories>
        <category>android</category>
        <category>view</category>
        <category>自定义</category>
        <category>组合控件</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>自定义view</tag>
        <tag>组合控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gson list处理]]></title>
    <url>%2F127571935%2F</url>
    <content type="text"><![CDATA[Gson list处理，代码优化源码片段ParameterizedTypeImpl.class123456789101112131415161718192021222324252627282930313233343536373839import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;/** * &lt;pre&gt; * author : Haitao * e-mail : haitao_ni@foxmail.com * time : 2017/08/07 * desc : Gson 反序列化Type类 * version: 1.0 * &lt;/pre&gt; */ public class ParameterizedTypeImpl implements ParameterizedType &#123; private final Class raw; private final Type[] args; public ParameterizedTypeImpl(Class raw, Type[] args) &#123; this.raw = raw; this.args = args != null ? args : new Type[0]; &#125; @Override public Type[] getActualTypeArguments() &#123; return args; &#125; @Override public Type getRawType() &#123; return raw; &#125; @Override public Type getOwnerType() &#123; return null; &#125;&#125; JSON2Class.class12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import com.google.gson.Gson;import com.google.gson.JsonSyntaxException;import java.lang.reflect.Type;import java.util.List;/** * &lt;pre&gt; * author : Haitao * e-mail : haitao_ni@foxmail.com * time : 2017/8/7 * desc : Json字符串转class * version: 1.0 * &lt;/pre&gt; */public class JSON2Class &#123; private static Gson mGson = new Gson(); /** * json 字符串转Object * @param json * @param typeOfT * @param &lt;T&gt; * @return * @throws JsonSyntaxException */ public static &lt;T&gt; T fromJsonObject(String json, Class&lt;T&gt; typeOfT) throws JsonSyntaxException &#123; if (json == null) &#123; return null; &#125; else &#123; return mGson.fromJson(json, typeOfT); &#125; &#125; /** * json字符串转List&lt;T&gt; * @param json * @param clazz * @param &lt;T&gt; * @return * @throws JsonSyntaxException */ public static &lt;T&gt; List&lt;T&gt; fromJsonArray(String json, Class&lt;T&gt; clazz) throws JsonSyntaxException &#123; if (json == null) &#123; return null; &#125; else &#123; Type listType = new ParameterizedTypeImpl(List.class, new Class[]&#123;clazz&#125;); return mGson.fromJson(json, listType); &#125; &#125; public static Gson getGson() &#123; return mGson; &#125;&#125; 使用示例Model类 NoticeDBean.class12345678910111213141516171819202122232425262728293031323334public class NoticeDBean &#123; /** * "id": "1", * "title": "测试公告", * "createtime": "2017-07-18 21:50:33" */ private String id; private String title; private String createtime; public String getId() &#123; return this.id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getTitle() &#123; return this.title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getCreatetime() &#123; return this.createtime; &#125; public void setCreatetime(String createtime) &#123; this.createtime = createtime; &#125;&#125; 示例1234567String jsonObjectStr="&#123;"id":"3","title":"测试公告","createtime":"2017-08-04 16:44:08"&#125;";String jsonArrayStr="[&#123;"id":"3","title":"测试公告","createtime":"2017-08-04 16:44:08"&#125;,&#123;"id":"3","title":"测试公告","createtime":"2017-08-04 16:44:08"&#125;]";NoticeDBean notice=JSON2Class.fromJsonObject(jsonObjectStr,NoticeDBean.class);List&lt;NoticeDBean&gt; notice = JSON2Class.fromJsonArray(jsonArrayStr,NoticeDBean.class);]]></content>
      <categories>
        <category>android</category>
        <category>json</category>
      </categories>
      <tags>
        <tag>gson</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[备忘录]]></title>
    <url>%2F668177610%2F</url>
    <content type="text"><![CDATA[Gradle下载的依赖包在什么位置？ Mac系统默认下载到：/Users/(用户名)/.gradle/caches/modules-2/files-2.1 Windows系统默认下载到：C:\Users(用户名).gradle\caches\modules-2\files-2.1 也可在 External Libraries下找到需要查看的依赖包，以oss为例，在Gradle:com.aliyun.dpa:oss-android-sdk:2.8.0 上右键-&gt;Libraries Properties 也可查看本地路径。 下载的插件包在什么位置 Mac系统默认下载到：/Users/(用户名)/.gradle/caches/modules-2/files-2.1/com.android.tools.build/gradle Gradle离线下载配置离线下载官方地址：https://services.gradle.org/distributions 点击对应项即可下载。 查看项目gradle版本 打开项目的根目录下的 /gradle/wrapper/gradle-wrapper.properties，我的配置如下： 123456#Tue Mar 12 16:38:29 CST 2019distributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distszipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/distsdistributionUrl=https\://services.gradle.org/distributions/gradle-4.10.1-all.zip 使用的gradle版本为4.10.1，离线下载可以直接点击https://services.gradle.org/distributions，找到对应项 gradle-4.10.1-all.zip，或者在 https://services.gradle.org/distributions/后接上 gradle-4.10.1-all.zip即可下载。比如 https://services.gradle.org/distributions/gradle-4.10.1-all.zip。建议用迅雷下载。 找到gradle存放位置，将下载的gradle离线包放入对应文件夹内。 Mac路径：/User/用户名/.gradle/wrapper/dists/，dists文件夹下是以gradle版本为名称的文件夹。以小编4.10.1为例，打开 gradle-4.10.1-all文件夹，找到类似 455itskqi2qtf0v2sja68alqd这样的文件夹，直接将之前下载的zip包放入即可。 下图中gradle-4.10.1-all.zip文件上方的三个为AS打开项目后自动解压生成的。 注：以gradle版本为名的文件夹及其里面的文件夹，需要先用Android Studio软件打开项目后才能自动生成。内部类似 455itskqi2qtf0v2sja68alqd这样的文件夹如果有多个，则按照时间，将对应的zip放入其中。 重新打开AS项目 gradle版本和插件版本对应关系官网地址 Plugin version Required Gradle version 1.0.0 - 1.1.3 2.2.1 - 2.3 1.2.0 - 1.3.1 2.2.1 - 2.9 1.5.0 2.2.1 - 2.13 2.0.0 - 2.1.2 2.10 - 2.13 2.1.3 - 2.2.3 2.14.1+ 2.3.0+ 3.3+ 3.0.0+ 4.1+ 3.1.0+ 4.4+ 3.2.0 - 3.2.1 4.6+ 3.3.0 - 3.3.2 4.10.1+ 3.4.0 - 3.4.1 5.1.1+ 3.5.0 - 3.5.4 5.4.1+ 3.6.0 - 3.6.4 5.6.4+ 4.0.0+ 6.1.1+ 4.1.0+ 6.5+ 4.2.0+ 6.7.1+ gradle命令 查看模块依赖详情 1./gradlew app:dependencies 查看模块依赖详情（指定configuration） 1./gradlew app:dependencies --configuration releaseUnitTestRuntimeClasspath SSH修改密码 终端进入目录 /Users/(用户名)/.ssh 输入 ssh-keygen -f id\_rsa -p， -p 选项请求修改私钥的密码-f{filename} 选项去指定密钥的名称,比如其中的 id\_rsa 为指定的私钥文件名 原先有密码，则需输入old passphrase，旧密码； 原先没有密码，则直接输入新密码 new passphrase (empty for no passphrase) Mac app打开问题处理显示 “安全性与隐私”-“任何来源”在 macOS Sierra 中，你会发现系统偏好设置的“安全性与隐私”中默认已经去除了允许“任何来源”的选项。 现在通过终端命令方式打开这个选项： 使用 spctl 命令： 1sudo spctl --master-disable OK！现在在 “安全性与隐私”中会多出“任何来源”这一选项。让我们愉快地使用app吧。 macOS 10.15 Catalina xxx.app已损坏，无法打开，你应该将它移到废纸篓解决方法更新macOS 10.15 Catalina后，很多在10.14上可以使用的App都会提示提示【xxx已损坏，无法打开，你应该将它移到废纸篓解决办法】，哪怕你在【安全与隐私 》 通用】中已经开启了“任何来源”，但还是会这样提示，其实解决方法很简单。就是绕过macOS的公证。 绕过公证：在终端中执行如下命令 1sudo xattr -rd com.apple.quarantine /Applications/xxxxxx.app 将其中的 xxxxxx.app替换为您需要设置的app名称。 比如软件StarUML： 1sudo xattr -rd com.apple.quarantine /Applications/StarUML.app 或者复制以下命令粘贴到终端后 1sudo xattr -rd com.apple.quarantine 打开Finder（访达），点击左侧的 应用程序，将应用拖进终端中，然后按键盘的回车键（return），输入密码，再按回车键，完成。 注意 quarantine 后面必须有个空格 某个程序绕开公证。 想恢复公正许怎么做重装应用 Mac下用Charles实现Android http和https抓包Mac下用Charles实现Android http和https抓包 Mac更新系统后无法使用git更新了系统后，进入到git工程目录，输入git命令，提示错误： 1xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun 进入Android Studio后提示： 12can&apos;t start git: /usr/bin/git probably the path to git executable is not valid . `fix it`. 解决方案：在终端输入： 1xcode-select --install 据说原因是因为每次更新系统之后xcode就被卸载了，因此需要重新安装一次。 adb多设备在线时，指定设备 通过adb devices命令获取所有online设备的serial number 1234➜ ~ adb devicesList of devices attached11ab03c3 deviceemulator-5554 device 具体需要选择哪个设备，可以通过插拔其中的设备进行辨别。 通过adb -s &lt;serial number&gt; 命令向设备发送adb命令 比如我需要安装app 1➜ ~ adb -s 11ab03c3 install test.apk Git删除分支（本地、远程） 查看分支，获取分支名称 1git branch -a 删除本地分支 1git branch -d &lt;BranchName&gt; 删除远程分支 1git push origin --delete &lt;BranchName&gt; 修改分支名称git修改分支名称 Sourcetree操作：（实例：将br_test_rename改为br_test_rename_new） 修改本地分支名称（BRANCHES目录下的是本地分支，下面提到的 REMOTES是远程分支）选中需要修改的分支br_test_rename；右键，点击 Rename，在弹出的对话框内输入新的分支名称br_test_rename_new，点击 OK 按钮确认修改。 推送新名称分支到远程仓库点击 push按钮；在弹出的对话框内购选中br_test_rename_new前的选择框；点击OK按钮进行推送；推送成功后，可以在 REMOTES目录下看到br_test_rename_new的新分支 删除远程br_test_rename名称的旧分支 REMOTES目录下找到br_test_rename名称的分支；右键，点击 Delete…；在弹出的确认对话框内点击 OK 按钮进行删除； 整个修改过程就完成了。主要流程归纳为： 修改本地名称 推送 删除远程旧分支 回退 本地仓库回退到指定版本 1git rest --hard &lt;commit id | HEAD^&gt; //HEAD^表示上一个版本，HEAD^^ 表示上上个版本 暂存区回退到工作区 1git reset HEAD &lt;file&gt;... 丢弃工作区修改（回到最新一次add或commit的状态） 1git checkout -- &lt;file&gt;... ssh与https相互切换从ssh切换到https格式：git remote set-url 远程仓库名称（当只有一个远程仓库时可省略） https地址 git remote set-url origin https://github.com/nhtzj/Java.git 从ssh切换到https格式：git remote set-url 远程仓库名称（当只有一个远程仓库时可省略） ssh地址 git remote set-url origin git@github.com:nhtzj/Java.git 其他 添加远程仓库地址 1git remote add origin git@gitee.com:goldsea/gitlearn.git 格式：git remote add + 自定义仓库命名 + 仓库ssh地址 第一次推送本地仓库内容到远程仓库 1git push -u origin master -u 参数的添加可以让本地仓库和远程仓库进行绑定 查看本地ssh key 1cat ~/.ssh/id_rsa.pub 修改最近一次提交的提交信息（commit 未push） 1git commit --amend 在文本编辑器内编辑提交信息，再保存 查看分支操作记录（带时间） 1git reflog show --date=iso &lt;branch name&gt; Iterm2快捷键Mac终端Iterm2快捷键大全 分屏 垂直分屏：command + d 水平分屏：command + shift + d 切换屏幕：command + option + 方向键 或者 command + [ ] 命令 查看历史命令：command + ; 查看剪贴板历史：command + shift + h 上一条命令：ctrl + p 搜索命令历史：ctrl + r 删除错误的密码：ctrl + u 行内 清除当前行：ctrl + u 到行首：ctrl + a 到行尾：ctrl + e 删除当前光标的字符：ctrl + d 删除光标之前的字符：ctrl + h 删除光标之前的单词：ctrl + w 删除到文本末尾：ctrl + k 交换光标处文本：ctrl + t 其他 清屏：command + k Vim 命令多行注释 进入命令行模式，按ctrl + v（windows ctrl + q）进入 visual block模式 按上键（ 或者下键）选中多行，把需要注释的行标记起来 按大写“I”键（Shift+i）进入插入模式，输入“#”（或者 “//”），然后按下“ESC”键（一下或两下） 取消多行注释 进入命令行模式，按ctrl + v进入 visual block模式 选中要删除的行首的注释符号，注意”//“ 要选中两个 按”d”即可删除注释 Android Studio快捷键参考：知乎 类结构（方法和成员变量）：command +fn + F12 、菜单Navigate -&gt; File Structure 优化导包：control+option+o 显示注释：control+J (在settings对话框的搜索框中，输入“quick doc”进行搜索) 导出为成员变量：option+command+F （在Refactor -&gt; Extract 内也有） 切换tab: (需要切换英文输入法，光标在编辑器内，在Window -&gt; Edit Tabs 内也能看到)上一页 shift+command+[ 下一页 shift+command+] 切换窗口:command+` 返回上一浏览位置 (具体可在keymap内搜索back或forward查看)返回上一次浏览位置back： option+command+ ← 或 command+ [返回下一次浏览位置forward： option+command+ →或 command+ ] 浮窗显示调用变量/方法定义：command + Y 高亮 - 查看某个变量在那个地方调用了：Cmd + Shift + Fn + F7 查看类的层次结构 ：Control + H 自动生成变量：Cmd + Alt + V （Alt即option） 自动提取参数：Cmd + Alt + P 参数提示：Cmd + P 快速跳转到父类：Cmd + U 快速跳转到实现：Cmd + Option + B 国际化，检查代码内的中文字符利用AS中的全局搜索+正则表达式，搜索。 正则表达式: 1^((?!(*|//)).)+[\u4e00-\u9fa5] 打开全局搜索，位于 Edit -&gt; Find - &gt; Fild in Path 在输入框内输入正则表达式：^((?!(*|//)).)+[\u4e00-\u9fa5] 钩上 Regex，也可钩上 File mask，用于查找指定文件后缀的文件 In Project、Module、Directory、Scope用于指定查询路径 点击 Open in Find Window，在Find标签内一直保存。因为 Fild in Path窗口在你点击其他地方后就会消失。 Fetch failed: Could not read from remote repository今天兴致勃勃地将Mac上地Android Studio 3.0升级到了3.1。但是用AS自带地图形化按钮提交和更新代码时（使用Git），却一直提示 “Fetch failed: Could not read from remote repository”。这可真是郁闷啊。Add、Commit都可以，就时Push不行。Add、Commit是对本地仓库地操作。用终端命令push又是可以的，所以该问题可以断定是3.1地AS将git的某个或某些配置改掉了。 解决途径： AS下进入： Settings -&gt; Version Control -&gt; Git -&gt; SSH Executable 如果SSH Executable选择的是Built-in，将它改为Native。 OK！大功告成！ AS直接安装apk提示：安装包有异常，无法安装Android Studio 3.0会在debug apk的manifest文件application标签里自动添加 android:testOnly=&quot;true&quot;属性，导致IDE中run跑出的apk在大部分手机上只能用adb install -t来安装，在oppo手机上甚至安装不了 解决方式在主工程 /gradle.properties内加入如下： 12# gradle.propertiesandroid.injected.testOnly=false AS禁用原因：大致就是安全性问题 Android Studio 3.0 and FLAG_TEST_ONLY 参考Disable ‘testOnly’ mode for Android Studio 3.0 More than one file was found with OS independent path ‘META-INF/proguard/androidx-annotations.pro’处理方式在 app/build.gradle内加入如下： 12345android &#123; packagingOptions &#123; exclude 'META-INF/proguard/androidx-annotations.pro' &#125;&#125; 在android节点内添加packagingOptions`的内容 参考More than one file was found with OS independent path ‘META-INF/proguard/androidx-annotations.pro’ Invoke-customs are only supported starting with Android O (–min-api 26) 处理方式在 app/build.gradle内加入如下： 123456android &#123; compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125;&#125; 在`android节点内添加compileOptions的内容 参考Invoke-customs are only supported starting with android 0 –min-api 26 Mac 快捷键 全屏/退出全屏：control+command+F Finder(访达)显示/隐藏 隐藏的文件或文件夹： shift + command + . 绘制圆图 drawCircle() + BitmapShader Paint.setXfermode() subLime 设置不换行 Preferences--&gt;Settings-User 添加 &quot;word_wrap&quot; : false, log日志过滤 「command + F」后在底部输入需要过滤的关键字 选择「Find All」 「command + L」或「菜单栏Selection -&gt; Expand Selection to Line」:将选中项扩展为关键字所在行 「command + C」:复制 新建文档后在新文档内「command + V」复制到新文本 权限修改文件或文件夹拥有者使用权限 : root 语法12chown [-fhv] [-R [-H | -L | -P]] owner[:group] file ...chown [-fhv] [-R [-H | -L | -P]] :group file ... 参数 : user : 新的文件拥有者的使用者 ID group : 新的文件拥有者的使用者组(group) -c : 显示更改的部分的信息 -f : 忽略错误信息 -h :修复符号链接 -v : 显示详细的处理信息 -R : 处理指定目录以及其子目录下的所有文件 –help : 显示辅助说明 –version : 显示版本 事例：1sudo chown -R $(whoami) ～/.ssh 修改 ～/.ssh目录及目录下的所有文件拥有者为 $(whoami)， $(whoami): 表示当前登录的用户 Android 开发注意事项不能在 Activity 没有完全显示时显示 PopupWindow 和 Dialog说明： Android Activity 创建时的生命周期，按照 onCreate() -&gt; onStart() -&gt; onResume() -&gt; onAttachedToWindow() -&gt; onWindowFocusChanged() 的 顺 序 ， 其 中 在Activity#onAttachedToWindow() 时，Activity 会与它的 Window 关联，这时 UI 才 会开始绘制，在 Activity#onWindowFocusChanged() 时，UI 才变成可交互状态，可以提示用户使用。如果在 Window 未关联时就创建对话框，UI 可能显示异常。 推荐的做法是在 Activity#onAttachedToWindow() 之后(其实最好是Activity#onWindowFocusChanged() 之后)才创建对话框。]]></content>
      <categories>
        <category>android</category>
        <category>tool</category>
      </categories>
      <tags>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文章收集]]></title>
    <url>%2F3800276053%2F</url>
    <content type="text"><![CDATA[郭霖 微信号: guolin_blogRichText Android平台下的富文本解析器，支持Html和MarkdownBeesAndroidLottieAndroid使用详解及源码解析—轻而易举实现各种复杂动画Android开发人员不得不收集的工具类集合 | 支付宝支付 | 微信支付 …String、StringBuffer和StringBuilder之间的区别郭霖 微信号: guolin_blogAndroid技术分享平台，每天都有优质技术文章推送。你还可以向公众号投稿，将自己总结的技术心得分享给大家。 String、StringBuffer和StringBuilder之间的区别 总结 String,StringBuffer,StringBuilder最终底层存储与操作的都是char数组.但是String里面的char数组是final的,而StringBuffer,StringBuilder不是,也就是说,String是不可变的,想要新的字符串只能重新生成String.而StringBuffer和StringBuilder只需要修改底层的char数组就行.相对来说,开销要小很多. String的大多数方法都是重新new一个新String对象返回,频繁重新生成容易生成很多垃圾. 还是那句古话,StringBuffer是线程安全的,StringBuilder是线程不安全的.因为StringBuffer的方法是加了synchronized锁起来了的,而StringBuilder没有. 增删比较多时用StringBuffer或StringBuilder（注意单线程与多线程）。实际情况按需而取吧，既然已经知道了里面的原理。]]></content>
      <categories>
        <category>收集</category>
      </categories>
      <tags>
        <tag>收集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新浪行情]]></title>
    <url>%2F1728334516%2F</url>
    <content type="text"><![CDATA[行情接口 http://hq.sinajs.cn/list=股票代码 以同花顺（股票代码：300033，股票市场：sz，深圳）为例，如果需要获取该股票的最新行情，只需如下调用接口： http://hq.sinajs.cn/list=sz300033 该接口会返回一串文本，比如： 1var hq_str_sz300033="同花顺,52.100,53.150,50.990,52.400,50.880,50.990,51.000,4592538,235557372.010,2284,50.990,400,50.950,300,50.940,200,50.930,3900,50.920,1200,51.000,1300,51.270,10300,51.280,400,51.290,3902,51.300,2018-04-03,13:18:54,00"; 该字符串由多个数据用逗号”,”拼接，按照程序员的思路，顺序号从0开始。 0:“同花顺”，股票名称； 1:“52.100”，今日开盘价； 2:“53.150”，昨日收盘价； 3:“50.990”，当前价格； 4:“52.400”，今日最高价； 5:“50.880”，今日最低价； 6:“50.990”，竞买价，即“买一”报价； 7:“51.000”，竞卖价，即“卖一”报价； 8:“4592538”，成交的股票数，由于股票交易以一百股为基本单位，所以在使用时，通常把该值除以一百； 9:“235557372.010”，成交金额，单位为“元”； 10:“2284”，“买一”申请4695股，即47手； 11:“50.990”，“买一”报价； 12:“400”，“买二”； 13:“50.950”，“买二”； 14:“300”，“买三”； 15:“50.940”，“买三”； 16:“200”，“买四”； 17:“50.930”，“买四”； 18:“3900”，“买五”； 19:“50.920”，“买五”； 20:“1200”，“卖一”申报3100股，即31手； 21:“51.000”，“卖一”报价 (22, 23), (24, 25), (26,27), (28, 29)分别为“卖二”至“卖四的情况” 30:“2018-04-03”，日期； 31:“13:18:54”，时间； 如需查询多个股票，只需要将股票代码用逗号拼接后调用该接口。 比如查询同花顺（股票代码：300033，股票市场：sz，深圳），贵州茅台（股票代码：600252，股票市场：sh，上海），复星医药（股票代码：600196，股票市场：sh，上海） http://hq.sinajs.cn/list=sz300033,sh600252,sh600196 123var hq_str_sz300033="同花顺,52.100,53.150,51.090,52.400,50.880,51.080,51.090,4880945,250301808.510,10293,51.080,5900,51.070,1700,51.050,2300,51.040,200,51.030,49100,51.090,3047,51.100,1100,51.150,2000,51.180,300,51.250,2018-04-03,13:36:12,00";var hq_str_sh600252="中恒集团,3.960,4.000,3.920,3.970,3.910,3.910,3.920,12745747,50199960.000,781400,3.910,789000,3.900,285600,3.890,337700,3.880,172300,3.870,297200,3.920,224400,3.930,144347,3.940,658503,3.950,390348,3.960,2018-04-03,13:36:14,00";var hq_str_sh600196="复星医药,43.800,44.360,43.460,44.670,43.430,43.460,43.480,10789333,473126781.000,3900,43.460,9550,43.450,13400,43.440,22645,43.430,3300,43.420,12000,43.480,2500,43.490,6400,43.500,1500,43.520,600,43.530,2018-04-03,13:36:14,00"; 返回的股票数据，股票与股票之间有“\n”换行符进行换行。返回股票行情数据的顺序与接口中拼接的股票代码顺序一致。而且不会去除重复股票代码。 比如： http://hq.sinajs.cn/list=sz300033,sz300033,sh600196 123var hq_str_sz300033="同花顺,52.100,53.150,51.650,52.400,50.880,51.590,51.650,5112490,262191072.590,200,51.590,800,51.580,1000,51.570,4100,51.550,1100,51.540,1500,51.650,300,51.660,1200,51.670,500,51.680,2000,51.690,2018-04-03,13:40:42,00";var hq_str_sz300033="同花顺,52.100,53.150,51.650,52.400,50.880,51.590,51.650,5112490,262191072.590,200,51.590,800,51.580,1000,51.570,4100,51.550,1100,51.540,1500,51.650,300,51.660,1200,51.670,500,51.680,2000,51.690,2018-04-03,13:40:42,00";var hq_str_sh600196="复星医药,43.800,44.360,43.480,44.670,43.410,43.440,43.480,10962328,480641133.000,2500,43.440,7500,43.430,7400,43.420,27400,43.410,35100,43.400,6200,43.480,1200,43.500,200,43.510,400,43.530,100,43.570,2018-04-03,13:40:41,00"; 会返回两次同花顺的行情数据。 大盘指数的数据会有所差别三大指数的代码如下： 上证指数：s_sh000001 深证成指：s_sz399001 创业板指：s_sz399006 接口与股票行情接口一致，单返回数据内容有巨大差别。 http://hq.sinajs.cn/list=s_sh000001,s_sz399001,s_sz399006 返回数据如下： 123var hq_str_s_sh000001="上证指数,3129.3559,-33.8231,-1.07,1093759,13684785";var hq_str_s_sz399001="深证成指,10705.22,-147.728,-1.36,150649760,21374199";var hq_str_s_sz399006="创业板指,1862.29,-37.966,-2.00,15198600,2675426"; 数据含义分别为：指数名称，当前点数，当前价格，涨跌率，成交量（手），成交额（万元）； 分时图gif形式 http://image.sinajs.cn/newchart/min/n/*.gif 其中*代表股票代码。 比如：同花顺的分时图 http://image.sinajs.cn/newchart/min/n/sz300033.gif 数据格式 http://vip.stock.finance.sina.com.cn/quotes\_service/view/CN\_TransListV2.php?symbol=股票代码&amp;rn=时间戳 其中 symbol为股票代码， rn为请求的时间戳。 该接口一次只能请求一个股票的分时图。 以同花顺为例： http://vip.stock.finance.sina.com.cn/quotes_service/view/CN_TransListV2.php?symbol=sz300033&amp;rn=1522736353052 返回数据如下（由于数据过多，这里已经删除大部分数据） 1var trade_item_list = new Array(); trade_item_list[0] = new Array('14:19:51', '100', '51.300', 'UP'); trade_item_list[1] = new Array('14:19:48', '1000', '51.300', 'UP'); trade_item_list[2] = new Array('14:19:45', '200', '51.290', 'DOWN'); trade_item_list[3] = new Array('14:19:42', '300', '51.300', 'UP'); trade_item_list[4] = new Array('14:19:39', '200', '51.300', 'UP'); trade_item_list[5] = new Array('14:19:36', '100', '51.300', 'UP'); trade_item_list[6] = new Array('14:19:30', '1000', '51.300', 'UP'); trade_item_list[7] = new Array('14:19:24', '300', '51.300', 'UP'); trade_item_list[8] = new Array('14:19:21', '300', '51.290', 'DOWN'); trade_item_list[9] = new Array('14:19:18', '100', '51.290', 'DOWN'); trade_item_list[10] = new Array('14:19:15', '400', '51.300', 'UP'); trade_item_list[11] = new Array('14:19:09', '1000', '51.300', 'UP'); trade_item_list[12] = new Array('14:19:03', '500', '51.300', 'UP'); trade_item_list[13] = new Array('14:18:57', '1400', '51.300', 'UP'); trade_item_list[14] = new Array('14:18:54', '2800', '51.300', 'UP'); trade_item_list[15] = new Array('14:18:48', '2600', '51.290', 'DOWN'); trade_item_list[16] = new Array('14:18:39', '1500', '51.290', 'UP'); trade_item_list[17] = new Array('14:18:33', '100', '51.290', 'UP'); trade_item_list[18] = new Array('14:18:30', '300', '51.290', 'UP'); trade_item_list[19] = new Array('14:18:27', '800', '51.290', 'DOWN'); trade_item_list[20] = new Array('14:18:21', '1000', '51.300', 'UP'); trade_item_list[2510] = new Array('09:38:27', '3900', '51.550', 'EQUAL'); trade_item_list[2511] = new Array('09:38:24', '11900', '51.500', 'DOWN'); trade_item_list[2512] = new Array('09:38:21', '2700', '51.600', 'UP'); trade_item_list[2513] = new Array('09:38:18', '6200', '51.500', 'DOWN'); trade_item_list[2514] = new Array('09:38:15', '6100', '51.600', 'DOWN'); trade_item_list[2515] = new Array('09:38:12', '5800', '51.600', 'DOWN'); trade_item_list[2516] = new Array('09:38:09', '1500', '51.600', 'DOWN'); trade_item_list[2517] = new Array('09:38:06', '2200', '51.700', 'UP'); trade_item_list[2518] = new Array('09:38:03', '3500', '51.600', 'DOWN'); trade_item_list[2519] = new Array('09:38:00', '1908', '51.700', 'DOWN'); trade_item_list[2520] = new Array('09:37:57', '3192', '51.700', 'DOWN'); trade_item_list[2521] = new Array('09:37:54', '3800', '51.710', 'DOWN'); trade_item_list[2522] = new Array('09:37:51', '3600', '51.750', 'EQUAL'); trade_item_list[2523] = new Array('09:37:48', '3400', '51.710', 'DOWN'); trade_item_list[2524] = new Array('09:37:45', '3400', '51.800', 'UP'); trade_item_list[2525] = new Array('09:37:42', '11800', '51.800', 'DOWN'); trade_item_list[2526] = new Array('09:37:39', '1900', '51.890', 'UP'); trade_item_list[2527] = new Array('09:37:36', '2900', '51.800', 'DOWN'); trade_item_list[2528] = new Array('09:37:33', '3700', '51.900', 'UP'); trade_item_list[2529] = new Array('09:37:30', '10000', '51.900', 'UP'); trade_item_list[2530] = new Array('09:37:27', '1300', '51.850', 'EQUAL'); trade_item_list[2531] = new Array('09:37:24', '5600', '51.810', 'DOWN'); trade_item_list[2532] = new Array('09:37:21', '4800', '51.900', 'UP'); trade_item_list[2533] = new Array('09:37:18', '12200', '51.900', 'DOWN'); trade_item_list[2534] = new Array('09:37:15', '3600', '51.930', 'UP'); trade_item_list[2535] = new Array('09:37:12', '2800', '51.900', 'DOWN'); trade_item_list[2536] = new Array('09:37:09', '2300', '51.900', 'DOWN'); trade_item_list[2537] = new Array('09:37:06', '100', '51.930', 'EQUAL'); trade_item_list[2538] = new Array('09:37:03', '67400', '51.900', 'DOWN'); trade_item_list[2539] = new Array('09:37:00', '600', '51.980', 'UP'); trade_item_list[2540] = new Array('09:36:57', '1200', '51.940', 'EQUAL'); trade_item_list[2541] = new Array('09:36:54', '5000', '51.930', 'DOWN'); trade_item_list[2542] = new Array('09:36:51', '400', '51.980', 'DOWN'); trade_item_list[2543] = new Array('09:36:48', '200', '52.000', 'UP'); trade_item_list[2544] = new Array('09:36:45', '200', '52.010', 'EQUAL'); trade_item_list[2545] = new Array('09:36:42', '12900', '52.030', 'UP'); trade_item_list[2546] = new Array('09:36:39', '300', '52.010', 'EQUAL'); trade_item_list[2547] = new Array('09:36:36', '15200', '52.040', 'EQUAL'); trade_item_list[2548] = new Array('09:36:33', '7800', '52.010', 'DOWN'); trade_item_list[2549] = new Array('09:36:30', '1100', '52.070', 'UP'); trade_item_list[2550] = new Array('09:36:27', '4300', '52.010', 'DOWN'); trade_item_list[2551] = new Array('09:36:24', '200', '52.030', 'DOWN'); trade_item_list[2552] = new Array('09:36:21', '1900', '52.030', 'DOWN'); trade_item_list[2553] = new Array('09:36:18', '1700', '52.040', 'DOWN'); trade_item_list[2554] = new Array('09:36:15', '1300', '52.080', 'EQUAL'); trade_item_list[2555] = new Array('09:36:12', '9100', '52.110', 'UP'); trade_item_list[2556] = new Array('09:36:09', '4600', '52.110', 'UP'); trade_item_list[2557] = new Array('09:36:06', '1100', '52.110', 'UP'); trade_item_list[2558] = new Array('09:36:03', '1200', '52.110', 'DOWN'); trade_item_list[2559] = new Array('09:36:00', '1700', '52.120', 'DOWN'); trade_item_list[2560] = new Array('09:35:57', '800', '52.130', 'DOWN'); trade_item_list[2561] = new Array('09:35:54', '2000', '52.100', 'DOWN'); trade_item_list[2562] = new Array('09:35:51', '1000', '52.110', 'DOWN'); trade_item_list[2563] = new Array('09:35:48', '900', '52.110', 'DOWN'); trade_item_list[2564] = new Array('09:35:45', '1800', '52.100', 'DOWN'); trade_item_list[2565] = new Array('09:35:39', '2300', '52.110', 'DOWN'); trade_item_list[2566] = new Array('09:35:36', '500', '52.170', 'UP'); trade_item_list[2567] = new Array('09:35:33', '6900', '52.110', 'DOWN'); trade_item_list[2568] = new Array('09:35:30', '200', '52.170', 'DOWN'); trade_item_list[2569] = new Array('09:35:27', '2000', '52.170', 'DOWN'); trade_item_list[2570] = new Array('09:35:24', '3100', '52.170', 'UP'); trade_item_list[2571] = new Array('09:35:21', '6000', '52.100', 'UP'); trade_item_list[2572] = new Array('09:35:18', '1200', '52.100', 'UP'); trade_item_list[2573] = new Array('09:35:15', '1300', '52.070', 'DOWN'); trade_item_list[2574] = new Array('09:35:12', '2600', '52.070', 'DOWN'); trade_item_list[2575] = new Array('09:35:09', '3000', '52.110', 'UP'); trade_item_list[2576] = new Array('09:35:06', '100', '52.100', 'UP'); trade_item_list[2577] = new Array('09:35:03', '900', '52.100', 'EQUAL'); trade_item_list[2578] = new Array('09:35:00', '2600', '52.070', 'DOWN'); trade_item_list[2579] = new Array('09:34:57', '600', '52.110', 'UP'); trade_item_list[2580] = new Array('09:34:54', '600', '52.100', 'DOWN'); trade_item_list[2581] = new Array('09:34:51', '7500', '52.110', 'DOWN'); trade_item_list[2582] = new Array('09:34:48', '6800', '52.210', 'EQUAL'); trade_item_list[2583] = new Array('09:34:45', '2800', '52.200', 'DOWN'); trade_item_list[2584] = new Array('09:34:42', '3800', '52.200', 'DOWN'); trade_item_list[2585] = new Array('09:34:36', '5800', '52.200', 'DOWN'); trade_item_list[2586] = new Array('09:34:33', '200', '52.230', 'DOWN'); trade_item_list[2587] = new Array('09:34:27', '1500', '52.230', 'UP'); trade_item_list[2588] = new Array('09:34:24', '3400', '52.190', 'DOWN'); trade_item_list[2589] = new Array('09:34:21', '1100', '52.200', 'UP'); trade_item_list[2590] = new Array('09:34:18', '9600', '52.200', 'DOWN'); trade_item_list[2591] = new Array('09:34:15', '1100', '52.230', 'UP'); trade_item_list[2592] = new Array('09:34:12', '1000', '52.230', 'EQUAL'); trade_item_list[2593] = new Array('09:34:09', '3400', '52.250', 'EQUAL'); trade_item_list[2594] = new Array('09:34:06', '1600', '52.300', 'UP'); trade_item_list[2595] = new Array('09:34:03', '1100', '52.300', 'UP'); trade_item_list[2596] = new Array('09:34:00', '1300', '52.300', 'UP'); trade_item_list[2597] = new Array('09:33:57', '7900', '52.300', 'DOWN'); trade_item_list[2598] = new Array('09:33:54', '4500', '52.320', 'DOWN'); trade_item_list[2599] = new Array('09:33:51', '5500', '52.400', 'UP'); trade_item_list[2600] = new Array('09:33:48', '2100', '52.380', 'UP'); trade_item_list[2601] = new Array('09:33:45', '500', '52.380', 'EQUAL'); trade_item_list[2602] = new Array('09:33:42', '1700', '52.400', 'UP'); trade_item_list[2603] = new Array('09:33:39', '1300', '52.400', 'UP'); trade_item_list[2604] = new Array('09:33:33', '400', '52.400', 'EQUAL'); trade_item_list[2605] = new Array('09:33:27', '100', '52.300', 'UP'); trade_item_list[2606] = new Array('09:33:24', '300', '52.230', 'DOWN'); trade_item_list[2607] = new Array('09:33:21', '4800', '52.210', 'EQUAL'); trade_item_list[2608] = new Array('09:33:18', '1300', '52.200', 'DOWN'); trade_item_list[2609] = new Array('09:33:12', '3500', '52.200', 'DOWN'); trade_item_list[2610] = new Array('09:33:09', '16000', '52.200', 'UP'); trade_item_list[2611] = new Array('09:33:06', '1500', '52.200', 'UP'); trade_item_list[2612] = new Array('09:33:03', '4100', '52.180', 'DOWN'); trade_item_list[2613] = new Array('09:33:00', '4900', '52.200', 'UP'); trade_item_list[2614] = new Array('09:32:57', '10500', '52.180', 'DOWN'); trade_item_list[2615] = new Array('09:32:54', '600', '52.190', 'UP'); trade_item_list[2616] = new Array('09:32:51', '6300', '52.180', 'DOWN'); trade_item_list[2617] = new Array('09:32:48', '11000', '52.180', 'DOWN'); trade_item_list[2618] = new Array('09:32:45', '1300', '52.180', 'UP'); trade_item_list[2619] = new Array('09:32:42', '7700', '52.170', 'DOWN'); trade_item_list[2620] = new Array('09:32:39', '300', '52.180', 'UP'); trade_item_list[2621] = new Array('09:32:36', '2400', '52.170', 'DOWN'); trade_item_list[2622] = new Array('09:32:33', '100', '52.180', 'UP'); trade_item_list[2623] = new Array('09:32:27', '1500', '52.180', 'UP'); trade_item_list[2624] = new Array('09:32:24', '10500', '52.070', 'DOWN'); trade_item_list[2625] = new Array('09:32:21', '800', '52.110', 'EQUAL'); trade_item_list[2626] = new Array('09:32:18', '2800', '52.100', 'DOWN'); trade_item_list[2627] = new Array('09:32:15', '1700', '52.110', 'UP'); trade_item_list[2628] = new Array('09:32:12', '300', '52.100', 'DOWN'); trade_item_list[2629] = new Array('09:32:09', '4300', '52.100', 'DOWN'); trade_item_list[2630] = new Array('09:32:06', '3000', '52.100', 'UP'); trade_item_list[2631] = new Array('09:32:00', '108', '52.080', 'DOWN'); trade_item_list[2632] = new Array('09:31:57', '7800', '52.080', 'UP'); trade_item_list[2633] = new Array('09:31:54', '1700', '52.000', 'DOWN'); trade_item_list[2634] = new Array('09:31:51', '500', '52.030', 'DOWN'); trade_item_list[2635] = new Array('09:31:48', '8700', '52.080', 'UP'); trade_item_list[2636] = new Array('09:31:45', '500', '52.030', 'UP'); trade_item_list[2637] = new Array('09:31:42', '600', '52.030', 'UP'); trade_item_list[2638] = new Array('09:31:39', '2000', '51.930', 'DOWN'); trade_item_list[2639] = new Array('09:31:36', '5700', '52.000', 'EQUAL'); trade_item_list[2640] = new Array('09:31:33', '3600', '52.030', 'UP'); trade_item_list[2641] = new Array('09:31:30', '2800', '52.030', 'EQUAL'); trade_item_list[2642] = new Array('09:31:27', '8200', '51.930', 'DOWN'); trade_item_list[2643] = new Array('09:31:24', '2500', '52.050', 'DOWN'); trade_item_list[2644] = new Array('09:31:21', '1100', '52.050', 'UP'); trade_item_list[2645] = new Array('09:31:18', '900', '52.030', 'DOWN'); trade_item_list[2646] = new Array('09:31:15', '1500', '52.030', 'DOWN'); trade_item_list[2647] = new Array('09:31:12', '1100', '52.030', 'DOWN'); trade_item_list[2648] = new Array('09:31:09', '11500', '52.030', 'UP'); trade_item_list[2649] = new Array('09:31:06', '600', '51.930', 'UP'); trade_item_list[2650] = new Array('09:31:03', '500', '51.920', 'DOWN'); trade_item_list[2651] = new Array('09:31:00', '5900', '51.920', 'DOWN'); trade_item_list[2652] = new Array('09:30:57', '7700', '51.920', 'UP'); trade_item_list[2653] = new Array('09:30:54', '7000', '51.920', 'UP'); trade_item_list[2654] = new Array('09:30:51', '2200', '51.920', 'UP'); trade_item_list[2655] = new Array('09:30:48', '6400', '51.920', 'DOWN'); trade_item_list[2656] = new Array('09:30:45', '9900', '51.900', 'DOWN'); trade_item_list[2657] = new Array('09:30:42', '3600', '52.010', 'EQUAL'); trade_item_list[2658] = new Array('09:30:39', '9300', '52.080', 'UP'); trade_item_list[2659] = new Array('09:30:36', '7900', '52.060', 'UP'); trade_item_list[2660] = new Array('09:30:33', '7200', '51.920', 'DOWN'); trade_item_list[2661] = new Array('09:30:30', '7800', '52.060', 'UP'); trade_item_list[2662] = new Array('09:30:27', '4300', '52.060', 'UP'); trade_item_list[2663] = new Array('09:30:24', '7400', '51.920', 'DOWN'); trade_item_list[2664] = new Array('09:30:21', '3800', '52.000', 'DOWN'); trade_item_list[2665] = new Array('09:30:18', '7400', '52.050', 'UP'); trade_item_list[2666] = new Array('09:30:15', '8500', '52.000', 'UP'); trade_item_list[2667] = new Array('09:30:12', '2300', '52.000', 'UP'); trade_item_list[2668] = new Array('09:30:09', '2700', '52.000', 'UP'); trade_item_list[2669] = new Array('09:30:06', '44100', '51.990', 'DOWN'); trade_item_list[2670] = new Array('09:30:03', '9000', '52.100', 'UP'); trade_item_list[2671] = new Array('09:25:03', '21100', '52.100', 'EQUAL'); var trade_INVOL_OUTVOL=[2615432.5,3118257.5]; 数据含义分别为：时间，当前成交量，当前价格，涨跌符号。 某分钟的价格取该分钟内的最后一个价格。 比如：09:30分的价格有从09:30:03到09:30:57共19个价格，则09:30的价格取09:30:57的价格51.920。 某分钟的成交量为该分钟内所有成交量的和。比如09:30分的成交量为从09:30:03到09:30:57共19个成交量之和。 某分钟的持有量为该分钟内所有持有量的和。当前持有量=当前成交量*涨跌符号；（UP为1，DOWN为-1，EQUAL为0）。 某分钟的持有量为正，则柱状图为红色；为负，则柱状图为绿色；为0，则柱状图为灰色。 以下为小编使用正则处理该数据的代码： 由于该接口返回的数据是从现在往前排列，所以最后的ArrayList需要调用Collections.reverse(list)方法反转一下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788 public ArrayList&lt;NewMinutesBean&gt; parseSinaMinutes(String str) &#123; ArrayList&lt;NewMinutesBean&gt; list = new ArrayList&lt;&gt;(); if (TextUtils.isEmpty(str)) &#123; return list; &#125; String time, preTime = null, upDownFlag; float priceCur; long numCur; long holdingVol, holdingVolFlag; NewMinutesBean minutesBean = null; String sinaRegex = "(\\('(.*?')\\, '(\\d*?)'\\, '(.*?)'\\, '(\\w*?)'\\));"; Pattern pattern = Pattern.compile(sinaRegex, Pattern.CASE_INSENSITIVE); Matcher matcher = pattern.matcher(str); int index = 0; String startTime = "09:30"; String endTime = "15:00"; long millisStart = hourToMillis(startTime); long millisEnd = hourToMillis(endTime); while (matcher.find()) &#123; time = matcher.group(2).substring(0, 5); if (index == 240 &amp;&amp; !time.equalsIgnoreCase(preTime)) &#123; break; &#125; long millisNow = hourToMillis(time); if (millisNow &gt; millisEnd) &#123; break; &#125; upDownFlag = matcher.group(5); switch (upDownFlag) &#123; case "UP": holdingVolFlag = 1; break; case "DOWN": holdingVolFlag = -1; break; case "EQUAL": holdingVolFlag = 0; break; default: holdingVolFlag = 0; &#125; priceCur = NumberUtils.parseFloat(matcher.group(4)); numCur = NumberUtils.parseLong(matcher.group(3)); holdingVol = numCur * holdingVolFlag; if (!time.equalsIgnoreCase(preTime) &amp;&amp; millisNow &gt;= millisStart) &#123; minutesBean = new NewMinutesBean(time, priceCur, numCur, holdingVol); list.add(minutesBean); if (index == 0) &#123; lowestPrice = hightestPrice = priceCur; &#125; if (priceCur &gt; hightestPrice) &#123; hightestPrice = priceCur; &#125; if (priceCur &lt; lowestPrice) &#123; lowestPrice = priceCur; &#125; index++; &#125; else &#123; if (minutesBean != null) &#123; minutesBean.setTradingVol(minutesBean.getTradingVol() + numCur); if (millisNow &gt;= millisStart) minutesBean.setHoldingVol(minutesBean.getHoldingVol() + holdingVol); &#125; &#125; preTime = time; &#125;//反转数据 Collections.reverse(list); return list; &#125; SimpleDateFormat dataFormat; private long hourToMillis(String startTime) &#123; if(dataFormat==null)&#123; dataFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm", Locale.getDefault()); &#125; return dataFormat.parse("2018-04-02 "+startTime).getTime(); &#125; NewMinutesBean.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class NewMinutesBean &#123; private String time; private float price; private long tradingVol; private long holdingVol; public NewMinutesBean(String time) &#123; this.time = time; &#125; public NewMinutesBean() &#123; &#125; public NewMinutesBean(String time, float price, long tradingVol, long holdingVol) &#123; this.time = time; this.price = price; this.tradingVol = tradingVol; this.holdingVol = holdingVol; &#125; public String getTime() &#123; return time; &#125; public void setTime(String time) &#123; this.time = time; &#125; public float getPrice() &#123; return price; &#125; public void setPrice(float price) &#123; this.price = price; &#125; public long getTradingVol() &#123; return tradingVol; &#125; public void setTradingVol(long tradingVol) &#123; this.tradingVol = tradingVol; &#125; public long getHoldingVol() &#123; return holdingVol; &#125; public void setHoldingVol(long holdingVol) &#123; this.holdingVol = holdingVol; &#125; @Override public String toString() &#123; return "NewMinutesBean&#123;" + "time='" + time + '\'' + ", price=" + price + ", tradingVol=" + tradingVol + ", holdingVol=" + holdingVol + '&#125;'; &#125;&#125; K线图对于股票的K线图的获取可以通过请求http://image.sinajs.cn/newchart/…/n/_.gif此URL获取. _ _其中_代表股票代码， …代表K线图类型。 详见如下： 日K：daily 周K：weekly 月K：monthly 查看日K线图： http://image.sinajs.cn/newchart/daily/n/sz300033.gif 查看周K线图： http://image.sinajs.cn/newchart/weekly/n/sz300033.gif 查看月K线图： http://image.sinajs.cn/newchart/monthly/n/sz300033.gif 最近二十天左右的每5分钟数据http://money.finance.sina.com.cn/quotes_service/api/json_v2.php/CN_MarketData.getKLineData?symbol=sz300033&amp;scale=5&amp;ma=5&amp;datalen=1023 （参数：股票编号、分钟间隔（5、15、30、60）、均值（5、10、15、20、25）、查询个数点（最大值242））]]></content>
      <categories>
        <category>android</category>
        <category>股票</category>
        <category>新浪行情</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>股票</tag>
        <tag>行情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定时、轮询]]></title>
    <url>%2F3768358896%2F</url>
    <content type="text"><![CDATA[前言本篇是小编在处理股票价格的定时刷新以及从非交易时间到交易时间过渡时重新唤醒定时刷新的技术总结。 技术方案Intent.ACTION_TIME_TICK通过动态注册Intent.ACTION_TIME_TICK这个广播。系统每分钟会发出该广播。 关于Intent.ACTION_TIME_TICK，官方的注释是这样的：12345Added in API level 1String ACTION_TIME_TICKBroadcast Action: The current time has changed. Sent every minute. You cannot receive this through components declared in manifests, only by explicitly registering for it with Context.registerReceiver().This is a protected intent that can only be sent by the system.Constant Value: "android.intent.action.TIME_TICK" 简单来讲就是每隔1分钟，系统会发出该广播。该广播不能静态注册在manifests文件中，只能使用Context.registerReceiver()动态注册。而且该广播是一个protected类型的广播，只能由系统跳用发出该广播，用户无权发出该广播。 知道了这些，就可以注册操作了。以实现时间段切换的需求。 1234567Receiver mTimeTickReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; // TODO 这里就可以按需求编写 &#125; &#125;; registerReceiver(mTimeTickReceiver, new IntentFilter(Intent.ACTION_TIME_TICK)); 该方式可以在单独的进程中使用，也可以在单独的界面中注册使用。 定时器方式定时器方式常见的有：Handler，Timer， Thread, AlarmManager等。 这里我想详细介绍一个RxJava提供的方式，Observable.interval()。 小编就编写一个简单Fragment基类来实现该操作。 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * Fragment TimeTick基础类 */public abstract class BaseTimeTickFragment extends BaseFragment &#123; private Subscription mTimeSubscription; /** * 处理在viewpager中的情况 * @param isVisibleToUser */ @Override public void setUserVisibleHint(boolean isVisibleToUser) &#123; super.setUserVisibleHint(isVisibleToUser); if (isVisibleToUser) &#123; startTimeTick(); &#125; else &#123; stopTimeTick(); &#125; &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = super.onCreateView(inflater, container, savedInstanceState); startTimeTick(); return view; &#125; @Override public void onDestroyView() &#123; super.onDestroyView(); stopTimeTick(); &#125; private void startTimeTick() &#123; stopTimeTick(); mTimeSubscription = Observable.interval(Constant.TIME_TICK_INTERVAL, Constant.TIME_TICK_INTERVAL, TimeUnit.SECONDS) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Long&gt;() &#123; @Override public void call(Long aLong) &#123; onTimeTick(TimeManager.getInstance().getServiceTime()); &#125; &#125;); &#125; private void stopTimeTick() &#123; if (mTimeSubscription != null &amp;&amp; !mTimeSubscription.isUnsubscribed()) &#123; mTimeSubscription.unsubscribe(); &#125; &#125; /** * 子类实现该方法，会定时调用该方法 * @param millis */ protected abstract void onTimeTick(long millis);&#125; TimeManager请参考Android时间与服务器同步方案 RxJava 还提供了Observable.timer()方式的定时器。]]></content>
      <categories>
        <category>android</category>
        <category>时间处理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android时间与服务器同步方案]]></title>
    <url>%2F3320101914%2F</url>
    <content type="text"><![CDATA[转自：https://blog.csdn.net/qinci/article/details/70666631 前言在部分场景里，应用对时间的要求比较严苛，比如金融类app，股票类、期货等，对交易区间的判断是非常重要的。这就需要客户端的时间与服务器时间或者是世界标准时间同步，而不能简单地获取本地时间就可以了。 本方案思路基于android系统提供的方法SystemClock.elapsedRealtime()，即手机系统开机时间。再配合服务器时间（或世界标准时间）实现移动端时间的准确性。 SystemClock.elapsedRealtime() ：手机系统开机时间（包含睡眠时间），用户无法修改 在必要的时刻获取一下服务器时间，然后记录这个时刻的手机开机时间（elapsedRealtime） 后续时间获取：现在服务器时间 = 以前服务器时间 - 以前服务器时间的获取时刻的手机开机时间 + 现在手机开机时间 移动端启动系统时间 = 以前服务器时间 - 以前服务器时间的获取时刻的手机开机时间 具体代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * &lt;pre&gt; * author : Haitao * blog : http://blog.nhtzj.com * time : 2018/4/2 * desc : Android时间与服务器同步方案&lt;br&gt; * 1.SystemClock.elapsedRealtime() ：手机系统开机时间（包含睡眠时间），用户无法在设置里面修改&lt;br&gt; * 2.在必要的时刻获取一下服务器时间，然后记录这个时刻的手机开机时间（elapsedRealtime）&lt;br&gt; * 3.后续时间获取：现在服务器时间 = 以前服务器时间 + 现在手机开机时间 - 以前服务器时间的获取时刻的手机开机时间&lt;br&gt; * version: 2.0 * &lt;/pre&gt; */public class TimeManager &#123; private static TimeManager instance; private long differenceTime; //以前服务器时间 - 以前服务器时间的获取时刻的系统启动时间,即：手机开机时的服务器时间 private boolean isServerTime; //是否是服务器时间 private TimeManager() &#123; &#125; public static TimeManager getInstance() &#123; if (instance == null) &#123; synchronized (AppManager.class) &#123; if (instance == null) &#123; instance = new TimeManager(); &#125; &#125; &#125; return instance; &#125; /** * 获取当前时间 * * @return the time */ public synchronized long getServiceTime() &#123; if (!isServerTime) &#123; //todo 这里可以加上触发获取服务器时间操作 return System.currentTimeMillis(); &#125; //时间差加上当前手机启动时间就是准确的服务器时间了 return differenceTime + SystemClock.elapsedRealtime(); &#125; /** * 时间校准 * * @param lastServiceTime 当前服务器时间 * @return the long */ public synchronized long initServerTime(long lastServiceTime) &#123; //记录时间差 differenceTime = lastServiceTime - SystemClock.elapsedRealtime(); isServerTime = true; return lastServiceTime; &#125;&#125; 然后只要把软件调用System.currentTimeMillis()全部替换成TimeManager.getInstance().getServiceTime();即可获取到准确时间。 利用OkHttp的Interceptor自动同步时间使用了Okhttp请求框架的，可以利用OkHttp的Interceptor自动同步时间 网络响应头包含Date字段（世界标准时间）。比如：Date: Mon, 02 Apr 2018 12:36:04 GMT，换算成本地时间，需要知道用户所在的时区 利用Interceptor记录每次请求响应时间，如果本次网络操作的时间小于上一次网络操作的时间，则获取Date字段，转换时区后更新本地TimeManager。 这样时间就只会越来越精确了 详细代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * &lt;pre&gt; * author : Haitao * blog : http://blog.nhtzj.com * time : 2018/4/2 * desc : 利用OkHttp的Interceptor自动同步时间 * version: 2.0 * &lt;/pre&gt; */public class TimeCalibrationInterceptor implements Interceptor &#123; long minResponseTime = Long.MAX_VALUE; @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); long startTime = System.nanoTime(); Response response = chain.proceed(request); long responseTime = System.nanoTime() - startTime; Headers headers = response.headers(); calibration(responseTime, headers); return response; &#125; private void calibration(long responseTime, Headers headers) &#123; if (headers == null) &#123; return; &#125; //如果这一次的请求响应时间小于上一次，则更新本地维护的时间 if (responseTime &gt;= minResponseTime) &#123; return; &#125; String standardTime = headers.get("Date"); if (!TextUtils.isEmpty(standardTime)) &#123; Date parse = HttpDate.parse(standardTime); if (parse != null) &#123; // 客户端请求过程一般大于比收到响应时间耗时，所以没有简单的除2 加上去，而是直接用该时间 TimeManager.getInstance().initServerTime(parse.getTime()); minResponseTime = responseTime; &#125; &#125; &#125;&#125; 之后将改Interceptor添加入OkHttpClient即可。1234567OkHttpClient okHttpClient = new OkHttpClient.Builder() .connectTimeout(20000L, TimeUnit.MILLISECONDS) .readTimeout(20000L, TimeUnit.MILLISECONDS) .addInterceptor(new RetryIntercepter(2)) //出错重试 .addInterceptor(new LoggerInterceptor("TAG", true)) //Log 打印信息 .addInterceptor(new TimeCalibrationInterceptor()) //时间同步 .build() OK，大功告成！！！]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>时间处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[取消GridView/ListView item被点击时的效果]]></title>
    <url>%2F716418986%2F</url>
    <content type="text"><![CDATA[在控件被初始化的时候设置12gridView.setSelector(new ColorDrawable(Color.TRANSPARENT));listView.setSelector(new ColorDrawable(Color.TRANSPARENT))； 在布局文件中设置listSelector属性12345678910111213&lt;GridView android:listSelector="@android:color/transparent" android:numColumns="auto_fit" android:columnWidth="50dp" android:stretchMode="spacingWidth" android:layout_weight="1.0" android:layout_height="0dip" android:layout_width="match_parent"/&gt;&lt;ListView android:listSelector="@android:color/transparent" android:layout_height="match_parent" android:layout_width="match_parent"/&gt;]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[greendao3 局部更新数据库字段并保存原数据]]></title>
    <url>%2F1039074019%2F</url>
    <content type="text"><![CDATA[前言greendao默认情况下是通过greendao { schemaVersion 18}中的schemaVersion 字段更新整个数据库所有表，并会删除原存储的数据。 接下来就通过修改greendao的部分代码，实现自定义控制需要更新的数据库表及保存原有数据。 进阶仅需添加2个类，分别是 GreenDaoOpenHelper 和 MigrationHelper。 GreenDaoOpenHelper.java123456789101112131415161718192021222324252627import org.greenrobot.greendao.database.Database;/** * author : Haitao * e-mail : http://blog.nhtzj.com/ * time : 2017/10/13 * desc : * version: 1.0 */public class GreenDaoOpenHelper extends DaoMaster.OpenHelper &#123; public GreenDaoOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory) &#123; super(context, name, factory); &#125; @Override public void onUpgrade(Database db, int oldVersion, int newVersion) &#123; MigrationHelper.migrate(db, new MigrationHelper.ReCreateAllTableListener() &#123; @Override public void onCreateAllTables(Database db, boolean ifNotExists) &#123; DaoMaster.createAllTables(db, ifNotExists); &#125; @Override public void onDropAllTables(Database db, boolean ifExists) &#123; DaoMaster.dropAllTables(db, ifExists); &#125; &#125;,UserDBeanDao.class); &#125;&#125; MigrationHelper.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280import android.database.Cursor;import android.database.SQLException;import android.database.sqlite.SQLiteDatabase;import android.support.annotation.NonNull;import android.text.TextUtils;import android.util.Log;import org.greenrobot.greendao.AbstractDao;import org.greenrobot.greendao.database.Database;import org.greenrobot.greendao.database.StandardDatabase;import org.greenrobot.greendao.internal.DaoConfig;import java.lang.ref.WeakReference;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.Arrays;import java.util.List; /** * author : Haitao * e-mail : http://blog.nhtzj.com/ * time : 2017/10/13 * desc : 数据库升级帮助类 please call &#123;@link #migrate(SQLiteDatabase, Class[])&#125; or &#123;@link #migrate(Database, Class[])&#125; * version: 1.0 */public final class MigrationHelper &#123; private static final String CONVERSION_CLASS_NOT_FOUND_EXCEPTION = "MigrationHelper - CLASS DOESN'T MATCH WITH THE CURRENT PARAMETERS"; public static boolean DEBUG = false; private static String TAG = "MigrationHelper"; private static final String SQLITE_MASTER = "sqlite_master"; private static final String SQLITE_TEMP_MASTER = "sqlite_temp_master"; private static WeakReference&lt;ReCreateAllTableListener&gt; weakListener; public interface ReCreateAllTableListener &#123; void onCreateAllTables(Database db, boolean ifNotExists); void onDropAllTables(Database db, boolean ifExists); &#125; public static void migrate(SQLiteDatabase db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; printLog("【The Old Database Version】" + db.getVersion()); Database database = new StandardDatabase(db); migrate(database, daoClasses); &#125; public static void migrate(SQLiteDatabase db, ReCreateAllTableListener listener, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; weakListener = new WeakReference&lt;&gt;(listener); migrate(db, daoClasses); &#125; public static void migrate(Database database, ReCreateAllTableListener listener, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; weakListener = new WeakReference&lt;&gt;(listener); migrate(database, daoClasses); &#125; public static void migrate(Database database, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; printLog("【Generate temp table】start"); generateTempTables(database, daoClasses); printLog("【Generate temp table】complete"); ReCreateAllTableListener listener = weakListener.get(); if (listener != null) &#123; listener.onDropAllTables(database, true); printLog("【Drop all table by listener】"); listener.onCreateAllTables(database, false); printLog("【Create all table by listener】"); &#125; else &#123; dropAllTables(database, true, daoClasses); createAllTables(database, false, daoClasses); &#125; printLog("【Restore data】start"); restoreData(database, daoClasses); printLog("【Restore data】complete"); &#125; private static void generateTempTables(Database db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; for (int i = 0; i &lt; daoClasses.length; i++) &#123; String tempTableName = null; DaoConfig daoConfig = new DaoConfig(db, daoClasses[i]); String tableName = daoConfig.tablename; if (!isTableExists(db, false, tableName)) &#123; printLog("【New Table】" + tableName); continue; &#125; try &#123; tempTableName = daoConfig.tablename.concat("_TEMP"); StringBuilder dropTableStringBuilder = new StringBuilder(); dropTableStringBuilder.append("DROP TABLE IF EXISTS ").append(tempTableName).append(";"); db.execSQL(dropTableStringBuilder.toString()); StringBuilder insertTableStringBuilder = new StringBuilder(); insertTableStringBuilder.append("CREATE TEMPORARY TABLE ").append(tempTableName); insertTableStringBuilder.append(" AS SELECT * FROM ").append(tableName).append(";"); db.execSQL(insertTableStringBuilder.toString()); printLog("【Table】" + tableName + "\n ---Columns--&gt;" + getColumnsStr(daoConfig)); printLog("【Generate temp table】" + tempTableName); &#125; catch (SQLException e) &#123; Log.e(TAG, "【Failed to generate temp table】" + tempTableName, e); &#125; &#125; &#125; private static boolean isTableExists(Database db, boolean isTemp, String tableName) &#123; if (db == null || TextUtils.isEmpty(tableName)) &#123; return false; &#125; String dbName = isTemp ? SQLITE_TEMP_MASTER : SQLITE_MASTER; String sql = "SELECT COUNT(*) FROM " + dbName + " WHERE type = ? AND name = ?"; Cursor cursor = null; int count = 0; try &#123; cursor = db.rawQuery(sql, new String[]&#123;"table", tableName&#125;); if (cursor == null || !cursor.moveToFirst()) &#123; return false; &#125; count = cursor.getInt(0); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (cursor != null) cursor.close(); &#125; return count &gt; 0; &#125; private static String getColumnsStr(DaoConfig daoConfig) &#123; if (daoConfig == null) &#123; return "no columns"; &#125; StringBuilder builder = new StringBuilder(); for (int i = 0; i &lt; daoConfig.allColumns.length; i++) &#123; builder.append(daoConfig.allColumns[i]); builder.append(","); &#125; if (builder.length() &gt; 0) &#123; builder.deleteCharAt(builder.length() - 1); &#125; return builder.toString(); &#125; private static void dropAllTables(Database db, boolean ifExists, @NonNull Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; reflectMethod(db, "dropTable", ifExists, daoClasses); printLog("【Drop all table by reflect】"); &#125; private static void createAllTables(Database db, boolean ifNotExists, @NonNull Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; reflectMethod(db, "createTable", ifNotExists, daoClasses); printLog("【Create all table by reflect】"); &#125; /** * dao class already define the sql exec method, so just invoke it */ private static void reflectMethod(Database db, String methodName, boolean isExists, @NonNull Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; if (daoClasses.length &lt; 1) &#123; return; &#125; try &#123; for (Class cls : daoClasses) &#123; Method method = cls.getDeclaredMethod(methodName, Database.class, boolean.class); method.invoke(null, db, isExists); &#125; &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; private static void restoreData(Database db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; for (int i = 0; i &lt; daoClasses.length; i++) &#123; DaoConfig daoConfig = new DaoConfig(db, daoClasses[i]); String tableName = daoConfig.tablename; String tempTableName = daoConfig.tablename.concat("_TEMP"); if (!isTableExists(db, true, tempTableName)) &#123; continue; &#125; try &#123; // get all columns from tempTable, take careful to use the columns list List&lt;String&gt; columnsTemp = getColumns(db, tempTableName); ArrayList&lt;String&gt; propertiesTemp = new ArrayList&lt;&gt;(columnsTemp.size() + 3); ArrayList&lt;String&gt; propertiesNew = new ArrayList&lt;&gt;(columnsTemp.size() + 3); for (int j = 0; j &lt; daoConfig.properties.length; j++) &#123; String columnName = daoConfig.properties[j].columnName; if (columnsTemp.contains(columnName)) &#123; propertiesTemp.add(columnName); propertiesNew.add(columnName); &#125; else &#123; try &#123; String aClass = getTypeByClass(daoConfig.properties[j].type); if (aClass.equals("INTEGER")) &#123; propertiesTemp.add("0 as " + columnName); propertiesNew.add(columnName); &#125; else if (aClass.equals("DOUBLE")) &#123; propertiesTemp.add("0.00 as " + columnName); propertiesNew.add(columnName); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; if (propertiesTemp.size() &gt; 0) &#123; final String columnSQLTmp = TextUtils.join(",", propertiesTemp); final String columnSQLNew = TextUtils.join(",", propertiesNew); StringBuilder insertTableStringBuilder = new StringBuilder(); insertTableStringBuilder.append("INSERT INTO ").append(tableName).append(" ("); insertTableStringBuilder.append(columnSQLNew); insertTableStringBuilder.append(") SELECT "); insertTableStringBuilder.append(columnSQLTmp); insertTableStringBuilder.append(" FROM ").append(tempTableName).append(";"); db.execSQL(insertTableStringBuilder.toString()); printLog("【Restore data】 to " + tableName); &#125; StringBuilder dropTableStringBuilder = new StringBuilder(); dropTableStringBuilder.append("DROP TABLE ").append(tempTableName); db.execSQL(dropTableStringBuilder.toString()); printLog("【Drop temp table】" + tempTableName); &#125; catch (SQLException e) &#123; Log.e(TAG, "【Failed to restore data from temp table 】" + tempTableName, e); &#125; &#125; &#125; private static List&lt;String&gt; getColumns(Database db, String tableName) &#123; List&lt;String&gt; columns = null; Cursor cursor = null; try &#123; cursor = db.rawQuery("SELECT * FROM " + tableName + " limit 0", null); if (null != cursor &amp;&amp; cursor.getColumnCount() &gt; 0) &#123; columns = Arrays.asList(cursor.getColumnNames()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (cursor != null) cursor.close(); if (null == columns) columns = new ArrayList&lt;&gt;(); &#125; return columns; &#125; private static void printLog(String info) &#123; if (DEBUG) &#123; Log.d(TAG, info); &#125; &#125; private static String getTypeByClass(Class&lt;?&gt; type) throws Exception &#123; if (type.equals(String.class)) &#123; return "TEXT"; &#125; if (type.equals(Long.class) || type.equals(Integer.class) || type.equals(long.class) || type.equals(int.class)) &#123; return "INTEGER"; &#125; if (type.equals(Boolean.class) || type.equals(boolean.class)) &#123; return "BOOLEAN"; &#125; if (type.equals(Float.class) || type.equals(Double.class) || type.equals(float.class) || type.equals(double.class)) &#123; return "DOUBLE"; &#125; Exception exception = new Exception(CONVERSION_CLASS_NOT_FOUND_EXCEPTION.concat(" - Class: ").concat(type.toString())); exception.printStackTrace(); throw exception; &#125;&#125; 之后修改greendao的默认初始化所调用的类为上面的GreenDaoOpenHelper 即可 1234567 private void initDao() &#123; SQLiteDatabase.loadLibs(this);// DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(this, ENCRYPTED ? "notes-db-encrypted" : "notes-db");//原有初始化 GreenDaoOpenHelper helper = new GreenDaoOpenHelper(this, ENCRYPTED ? "gp-db-encrypted" : "gp-db", null); Database db = ENCRYPTED ? helper.getEncryptedWritableDb("haitao_ni") : helper.getWritableDb(); daoSession = new DaoMaster(db).newSession(); &#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[EditText限制输入内容]]></title>
    <url>%2F517362219%2F</url>
    <content type="text"><![CDATA[限制输入类型代码：et.setInputType(InputType.TYPE_TEXT_VARIATION_LONG_MESSAGE);xml：android:inputType=&quot;number&quot; 限制输入长度（如限制输入最大长度10）代码：et.setFilters(new InputFilter[]{new InputFilter.LengthFilter(10)});xml：android:maxLength=&quot;10&quot; 限制输入固定的某些字符（如身份证号 123456789X）代码：et.setKeyListener(DigitsKeyListener.getInstance(“123456789X”);xml：android:digits=&quot;@string/input_num_character&quot;]]></content>
      <categories>
        <category>android</category>
        <category>view</category>
        <category>EditText</category>
      </categories>
      <tags>
        <tag>EditText</tag>
        <tag>输入内容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView 无限循环]]></title>
    <url>%2F2497511095%2F</url>
    <content type="text"><![CDATA[实现相对而言无限个Item（无限个数据）只需要在RecyclerView.Adapter的方法中1234@Overridepublic int getItemCount() &#123; return Integer.MAX_VALUE;&#125; 实现第一次显示的时候, 就可以左滑在添加完数据后调用RecyclerView.scrollToPosition（），将RecyclerView当前显示的首个Item的position设置为比较大的值。1mRecyclerView.scrollToPosition(mPersonAdapter.getItemRawCount() * 500); 滑动的时候, 一个一个的滑动(类似ViewPager的效果)1new PagerSnapHelper().attachToRecyclerView(mRecyclerView); 全篇代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185 import android.content.Context; import android.os.Build; import android.support.annotation.Nullable; import android.support.annotation.RequiresApi; import android.support.v4.content.ContextCompat; import android.support.v7.widget.DividerItemDecoration; import android.support.v7.widget.LinearLayoutManager; import android.support.v7.widget.RecyclerView; import android.util.AttributeSet; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.LinearLayout; import com.zy.policyplatform.R; import com.zy.policyplatform.bean.Policy; import java.util.ArrayList; import java.util.List; /** * &lt;pre&gt; * author : Haitao * e-mail : http://blog.nhtzj.com * time : 2018/2/25 * desc : 牛人榜单 横向无限滑动 * version: 2.0 * &lt;/pre&gt; */ public class ProfitPersonView extends LinearLayout &#123; private RecyclerView mRecyclerView; private PersonAdapter mPersonAdapter; private OnClickListener mItemClickListener; private OnItemClickListener onItemClickListener; public ProfitPersonView(Context context) &#123; super(context); init(context); &#125; public ProfitPersonView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(context); &#125; public ProfitPersonView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context); &#125; @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) public ProfitPersonView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; super(context, attrs, defStyleAttr, defStyleRes); init(context); &#125; private void init(Context context) &#123; setOrientation(LinearLayout.VERTICAL); LayoutInflater.from(context).inflate(R.layout.view_home_person, this, true); mRecyclerView = (RecyclerView) findViewById(R.id.recyclerView); mRecyclerView.setLayoutManager(new LinearLayoutManager(context, LinearLayoutManager.HORIZONTAL, false)); DividerItemDecoration itemDecoration = new DividerItemDecoration(context, DividerItemDecoration.HORIZONTAL); itemDecoration.setDrawable(ContextCompat.getDrawable(context, R.drawable.shape_recycleview_divider_vertical)); mRecyclerView.addItemDecoration(itemDecoration); mPersonAdapter = new PersonAdapter(context); mRecyclerView.setAdapter(mPersonAdapter); initListener(); &#125; private void initListener() &#123; mItemClickListener = new OnClickListener() &#123; @Override public void onClick(int position, long itemId) &#123; if (onItemClickListener != null) &#123; onItemClickListener.onItemClick(position % mPersonAdapter.getItemRawCount(), itemId); &#125; &#125; &#125;; &#125; public void setDatas(List&lt;Policy&gt; datas) &#123; if (mPersonAdapter == null) &#123; return; &#125; mPersonAdapter.clear(); if (datas != null &amp;&amp; datas.size() &gt; 0) &#123; mPersonAdapter.addAll(datas); &#125; mRecyclerView.scrollToPosition(mPersonAdapter.getItemRawCount() * 500); &#125; private class PersonAdapter extends RecyclerView.Adapter &#123; private List&lt;Policy&gt; mItems; private Context mContext; private LayoutInflater mInflater; public PersonAdapter(Context context) &#123; mContext = context; mInflater = LayoutInflater.from(context); mItems = new ArrayList&lt;&gt;(); &#125; @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; ItemViewHolder viewHolder = new ItemViewHolder(mInflater.inflate(R.layout.item_home_person, parent, false)); viewHolder.itemView.setTag(viewHolder); viewHolder.itemView.setOnClickListener(mItemClickListener); return viewHolder; &#125; @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) &#123; // onBindLoopViewHolder(holder, position % getItemRawCount()); &#125; @Override public int getItemCount() &#123; int rawCount = getItemRawCount(); if (rawCount &gt; 0) &#123; return Integer.MAX_VALUE; &#125; return 0; &#125; /** * 真实数据的大小 */ public int getItemRawCount() &#123; return mItems == null ? 0 : mItems.size(); &#125;​ public void addAll(List&lt;Policy&gt; items) &#123; if (items != null) &#123; this.mItems.addAll(items); notifyItemRangeInserted(this.mItems.size(), items.size()); &#125; &#125; public final void clear() &#123; this.mItems.clear(); notifyDataSetChanged(); &#125;​ private class ItemViewHolder extends RecyclerView.ViewHolder &#123; public ItemViewHolder(View itemView) &#123; super(itemView); &#125; &#125; &#125; /** * 可以共用同一个listener，相对高效 */ public abstract class OnClickListener implements View.OnClickListener &#123; @Override public void onClick(View v) &#123; RecyclerView.ViewHolder holder = (RecyclerView.ViewHolder) v.getTag(); onClick(holder.getAdapterPosition(), holder.getItemId()); &#125; public abstract void onClick(int position, long itemId); &#125; /** *外部调用，添加点击回调 */ public interface OnItemClickListener &#123; void onItemClick(int position, long itemId); &#125; public void setOnItemClickListener(OnItemClickListener onItemClickListener) &#123; this.onItemClickListener = onItemClickListener; &#125; &#125; RecyclerView分割线请查看RecyclerView-简单设置分割线]]></content>
      <categories>
        <category>android</category>
        <category>RecyclerView</category>
      </categories>
      <tags>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIUI 8 及以上界面截长图]]></title>
    <url>%2F608331229%2F</url>
    <content type="text"><![CDATA[普通截屏只能截取屏幕当前显示的内容，以下截长图内容操作是基于MIUI 8。 普通截图 - 快捷键：音量下键+Home键 - 下拉，通过功能菜单按钮“截屏” 普通截图后，会在屏幕右上角显示一个上下浮动的小图，点击该图片。 点击左下角“截长图”，等待截图结束。 截长图完成。 整体操作流程]]></content>
      <categories>
        <category>系统</category>
        <category>MIUI</category>
      </categories>
      <tags>
        <tag>MIUI 8，截长图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云OSS移动应用直传服务]]></title>
    <url>%2F1444340945%2F</url>
    <content type="text"><![CDATA[官方文档：快速搭建移动应用直传服务 权限管理 STS临时授权访问 访问控制 RAM Policy Editor 源码下载： Android示例程序的源码下载地址 应用服务器代码示例的下载PHP下载地址 iOS版本及其他语言的应用服务器代码示例代码，请前往快速搭建移动应用直传服务自行下载。（本人只用了Android和PHP的代码） 注：PHP下载地址解压后的 sts-server／policy/all_policy.txt,本人经过微调，否则直接使用官网下的代码，会一直报“AccessDeny”错误。若使用bucket_read_policy.txt或者bucket_read_write_policy.txt，请将 “$BUCKET_NAME”替换为您的bucket名称。自定义的策略也可以自行编辑，或通过RAM Policy Editor编写。之后替换config.json 内的PolicyFile字段值即可。 STS配置及内容说明认真看完权限管理篇章，对权限、子账号、bucket、STS临时授权有比较全面详细的了解了。 使用快速搭建移动应用直传服务，阿里云会自动生成并配置以下几项： 用户（AliyunOSSTokenGeneratorUser） 策略（AliyunOSSTokenGeneratorRolePolicy，AliyunOSSTokenGeneratorUserPolicy） 角色（AliyunOSSTokenGeneratorRole） 这些配置也可通过STS临时授权访问自己创建并配置。 用户（AliyunOSSTokenGeneratorUser）为子账号，至于为何要用子账号，请查阅不使用主账号。主要还是权限及安全因素。 AliyunOSSTokenGeneratorUser、 AliyunOSSTokenGeneratorRolePolicy、AliyunOSSTokenGeneratorUserPolicy、 AliyunOSSTokenGeneratorRole 之间的关系及主要代码如下图所示： 创建及授权流程如下所示： aliyun管理控制台配置1、2两大步，第3步 Token AK创建由应用服务器调用sdk创建。 应用服务器端配置应用服务器端的配置除了上面“注”中提到的，就是配置config.json中的7个参数123456789&#123;"AccessKeyID" : "","AccessKeySecret" : "","RoleArn" : "","BucketName" : "","Endpoint" : "","TokenExpireTime" : "900","PolicyFile": "policy/all_policy.txt"&#125; 说明： AccessKeyID：填写上述图标红的参数1的内容。 AccessKeySecret：填写上述图标红的参数2的内容。 RoleArn：填写上述图标红的参数3的内容。 BucketName：填写需要操作的bucket名称，默认值可以不修改 Endpoint：填写您的阿里云OSS服务的访问域名， 默认值可以不修改。（用户自定义域名没试过） TokenExpireTime：指Android/iOS应用取到这个Token的失效时间，注意，最少是900s，默认值可以不修改。 PolicyFile：填写的是该Token所要拥有的权限列表的文件， 默认值可以不修改。 将sts-server代码发布后，调用sts.php返回的正确结果为： 1234567&#123;StatusCode: 200,AccessKeyId: "STS.DW3ffRHD3NPNgv1qFU6ZRk7xQ",AccessKeySecret: "ZPEKVfqdbcp3oVe5sDztKCwv6gmvZk32Rhqi9dsVgyP",Expiration: "2018-02-02T13:38:22Z",SecurityToken: "CAIS+wJ1q6Ft5B2yfSjIpZSGLdzmpZsS+ZKlZVCAlUYAOtV+hPLTszz2IHBNeXNhAuAXsvs3mWFW5/wYlqJ4T55IQ1Dza8J148yMOZ58ns6T1fau5Jko1bdycAr6Umwqta2/SuH9S8ynkJ7PD3nPii50x5bjaDymRCbLGJaViJlhHNZ1Ow6jdmhpCctxLAlvo9N4UHzKLqSVLwLNiGjdB1YKwg1nkjFT5KCy3sC74BjTh0GYr+gOvNbVI4O4V8B2IIwdI9Cux75ffK3bzAtN7wRL7K5skJFc/TDOsrP6BEJKsTGHKPbz+N9iJxNiHOtYfZRJt//hj/Z1l/XOnoDssXZ3MPpSTj7USfLHoq7NE/j7Mc0iJ/SpeSaP8KjWa8Gr6FJ4OC9DZVsRJIB8EBIqV0xwEAO9A7S85VXHbj2kT6W4y6ws2fJ3tQ64pIfQdgPfEunGiXtJZM5mNVlbPhoXzHHndbQdbwtPflVoCrCYV4xvawpErqflrcgFuIfjZ889GoABa/Tnm7uQ+F/Pos+R0sBs/PN+APE4UGHDEJNqXY5ljWTl11l8Wp93FHxBB4CcsarLQ3fvOmIUXqHKLK7me8zOAVZE1/p4jLrR8zyaxFYeDTyWqqur3Ne7im4hSz0B8pYxN3Xw+eKPR6mJ+fsGxtmoQDsU+YHrRmpmtWPWOC28mhY="&#125; 错误返回格式为：12345&#123; "StatusCode":500, "ErrorCode":"InvalidAccessKeyId.NotFound", "ErrorMessage":"Specified access key is not found."&#125; 移动端配置移动端的配置以Android 端为例，iOS端请自行查阅快速搭建移动应用直传服务。 初始化OSS endpoint为 “应用服务器端配置”中提到的“您的阿里云OSS服务的访问域名”，比如我的是“oss-cn-shanghai.aliyuncs.com”，可在阿里云管理控制台-&gt;对象存储OSS中查看。 123456789101112private void initOSS(Context context, String endpoint) &#123; ClientConfiguration conf = new ClientConfiguration(); conf.setConnectionTimeout(15 * 1000); // 连接超时，默认15秒 conf.setSocketTimeout(15 * 1000); // socket超时，默认15秒 conf.setMaxConcurrentRequest(5); // 最大并发请求书，默认5个 conf.setMaxErrorRetry(2); // 失败后最大重试次数，默认2次 OSSCredentialProvider credentialProvider = new STSGetter(); oss = new OSSClient(context, endpoint, credentialProvider, conf); OssUploadUtil.oss = oss;&#125; 其中主要的是STSGetter。STSGetter代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * &lt;pre&gt; * author : Haitao * e-mail : haitao_ni@foxmail.com * time : 2018/2/1 * desc : 重载OSSFederationCredentialProvider生成自己的获取STS的功能 * version: 2.0 * &lt;/pre&gt; */public class STSGetter extends OSSFederationCredentialProvider &#123; private String stsServer; public STSGetter() &#123; stsServer = HttpInterface.UserV2.URL_IMAGE_STS; &#125; public STSGetter(String stsServer) &#123; this.stsServer = stsServer; &#125; @Override public OSSFederationToken getFederationToken() &#123; String stsJson; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder().url(stsServer).build(); try &#123; Response response = client.newCall(request).execute(); if (response.isSuccessful()) &#123; stsJson = response.body().string(); &#125; else &#123; throw new IOException("Unexpected code " + response); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); Log.e("GetSTSTokenFail", e.toString()); return null; &#125; try &#123; JSONObject jsonObjs = new JSONObject(stsJson); String ak = jsonObjs.getString("AccessKeyId"); String sk = jsonObjs.getString("AccessKeySecret"); String token = jsonObjs.getString("SecurityToken"); String expiration = jsonObjs.getString("Expiration"); return new OSSFederationToken(ak, sk, token, expiration); &#125; catch (JSONException e) &#123; Log.e("GetSTSTokenFail", e.toString()); e.printStackTrace(); return null; &#125; &#125;&#125; 之后OSS的操作就可以直接调用OSS提供的SDK内的方法了。 当需要上传文件时，oss会自动调用getFederationToken方法获取授权。当授权过期时，也会oss也会主动重新获取授权，不用开发者操心。]]></content>
      <categories>
        <category>OSS</category>
      </categories>
      <tags>
        <tag>阿里云</tag>
        <tag>OSS</tag>
        <tag>移动应用直传服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment生命周期]]></title>
    <url>%2F275913636%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>android</category>
        <category>Fragment</category>
      </categories>
      <tags>
        <tag>Fragment生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebView截图、截取整个网页]]></title>
    <url>%2F1232491147%2F</url>
    <content type="text"><![CDATA[本次需求是要实现对WebView显示所有内容的截图 网上找了一通，基本上是实现了当前显示内容的截图，并非是整个页面的截图。 最终实现效果和代码如下所示，实现了本次WebView长截图的需求。 效果如下： 代码如下，主要是使用WebView.setDrawingCacheEnabled(),WebView.buildDrawingCache(),WebView.getDrawingCache(),View.scrollBy() 实现滑动截图，再拼接合成整张图片。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137public class CaptureUtils &#123; /** * 获取 当前屏幕显示区域 v 去除PaddingBottom的Bitmap对象 * * @param v * @return */ private static Bitmap getViewBitmapWithoutBottom(View v) &#123; if (null == v) &#123; return null; &#125; v.setDrawingCacheEnabled(true); v.buildDrawingCache(); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123; v.measure(View.MeasureSpec.makeMeasureSpec(v.getWidth(), View.MeasureSpec.EXACTLY), View.MeasureSpec.makeMeasureSpec(v.getHeight(), View.MeasureSpec.EXACTLY)); v.layout((int) v.getX(), (int) v.getY(), (int) v.getX() + v.getMeasuredWidth(), (int) v.getY() + v.getMeasuredHeight()); &#125; else &#123; v.measure(View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED), View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED)); v.layout(0, 0, v.getMeasuredWidth(), v.getMeasuredHeight()); &#125; Bitmap bp = Bitmap.createBitmap(v.getDrawingCache(), 0, 0, v.getMeasuredWidth(), v.getMeasuredHeight() - v.getPaddingBottom()); v.setDrawingCacheEnabled(false); v.destroyDrawingCache(); return bp; &#125; /** * 获取 当前屏幕显示区域 v 的Bitmap对象 * * @param v * @return */ public static Bitmap getViewBitmap(View v) &#123; if (null == v) &#123; return null; &#125; v.setDrawingCacheEnabled(true); v.buildDrawingCache(); if (Build.VERSION.SDK_INT &gt;= 11) &#123; v.measure(View.MeasureSpec.makeMeasureSpec(v.getWidth(), View.MeasureSpec.EXACTLY), View.MeasureSpec.makeMeasureSpec(v.getHeight(), View.MeasureSpec.EXACTLY)); v.layout((int) v.getX(), (int) v.getY(), (int) v.getX() + v.getMeasuredWidth(), (int) v.getY() + v.getMeasuredHeight()); &#125; else &#123; v.measure(View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED), View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED)); v.layout(0, 0, v.getMeasuredWidth(), v.getMeasuredHeight()); &#125; Bitmap b = Bitmap.createBitmap(v.getDrawingCache(), 0, 0, v.getMeasuredWidth(), v.getMeasuredHeight()); v.setDrawingCacheEnabled(false); v.destroyDrawingCache(); return b; &#125; /** * 获取 WebView 视图长截图 * * @param context * @param webView * @return */ public static Bitmap getWebViewBitmap(Context context, WebView webView) &#123; if (null == webView) return null; webView.scrollTo(0, 0); webView.buildDrawingCache(true); webView.setDrawingCacheEnabled(true); webView.setVerticalScrollBarEnabled(false); Bitmap b = getViewBitmapWithoutBottom(webView); // 可见高度 int webViewHeight = webView.getHeight(); // 容器内容实际高度 int contentHeight = (int) (webView.getContentHeight() * webView.getScale()); Bitmap temp; if (contentHeight &gt; webViewHeight) &#123; int screenWidth = getScreenWidth(context); int absVh = webViewHeight - webView.getPaddingTop() - webView.getPaddingBottom(); do &#123; int restHeight = contentHeight - webViewHeight; if (restHeight &lt;= absVh) &#123; webView.scrollBy(0, restHeight); webViewHeight += restHeight; temp = getViewBitmap(webView); &#125; else &#123; webView.scrollBy(0, absVh); webViewHeight += absVh; temp = getViewBitmapWithoutBottom(webView); &#125; b = mergeBitmap(webViewHeight, screenWidth, temp, 0, webView.getScrollY(), b, 0, 0); &#125; while (webViewHeight &lt; contentHeight); &#125; // 回滚到顶部 webView.scrollTo(0, 0); webView.setVerticalScrollBarEnabled(true); webView.setDrawingCacheEnabled(false); webView.destroyDrawingCache(); return b; &#125; /** * 拼接图片 * * @param newImageH * @param newImageW * @param background * @param backX * @param backY * @param foreground * @param foreX * @param foreY * @return */ private static Bitmap mergeBitmap(int newImageH, int newImageW, Bitmap background, float backX, float backY, Bitmap foreground, float foreX, float foreY) &#123; if (null == background || null == foreground) &#123; return null; &#125; Bitmap bitmap = Bitmap.createBitmap(newImageW, newImageH, Bitmap.Config.RGB_565); Canvas cv = new Canvas(bitmap); cv.drawBitmap(background, backX, backY, null); cv.drawBitmap(foreground, foreX, foreY, null); cv.save(Canvas.ALL_SAVE_FLAG); cv.restore(); return bitmap; &#125; /** * 获取屏幕宽度 */ public static int getScreenWidth(Context ctx) &#123; int w; if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.HONEYCOMB_MR2) &#123; Point p = new Point(); ((WindowManager) ctx.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getSize(p); w = p.x; &#125; else &#123; w = ((WindowManager) ctx.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getWidth(); &#125; return w; &#125;&#125; 图片保存代码：12345678910111213141516171819202122private void takeCapture() &#123; Bitmap bitmap = webViewFragment.captureWebView(); //获取webview 长截图，内部代码是上面代码所示，调用了CaptureUtils.getWebViewBitmap(); String filePath = CachePathNew.getDCIMPath(activityInstance) + "线下支付_" + TimeUtils.getNowStringSimple() + ".jpg"; File file = new File(filePath); FileOutputStream fos = null; try &#123; fos = new FileOutputStream(file); bitmap.compress(Bitmap.CompressFormat.JPEG, 70, fos); ToastUtils.makeText("图片已保存到\n" + fileName); Intent intent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE); Uri uri = Uri.fromFile(file); intent.setData(uri); activityInstance.sendBroadcast(intent); notification(filePath); fos.flush(); fos.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); ToastUtils.makeText("保存失败"); CloseUtils.closeIO(fos); &#125;&#125; 发送notification，点击用系统图片浏览工具打开图片1234567891011121314151617181920212223242526272829private void notification(String filePath) &#123; int indexS = filePath.indexOf("DCIM"); String subFilePath; if (-1 != indexS) &#123; subFilePath = filePath.substring(indexS - 1); &#125; else &#123; subFilePath = filePath; &#125; NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); File file = new File(filePath); Intent intent = new Intent(Intent.ACTION_VIEW); intent.setDataAndType(Uri.fromFile(file), "image/* "); PendingIntent pendingIntent = PendingIntent.getActivity(activityInstance, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT); Notification.Builder builder = new Notification.Builder(activityInstance); builder.setSmallIcon(R.mipmap.ic_launcher) .setContentTitle("已保存订单截图信息") .setContentText(subFilePath) .setAutoCancel(true) .setContentIntent(pendingIntent); Notification notification; if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN) &#123; notification = builder.getNotification(); &#125; else &#123; notification = builder.build(); &#125; manager.notify((int) System.currentTimeMillis(), notification);&#125; 通知效果如下]]></content>
      <categories>
        <category>android</category>
        <category>view</category>
        <category>webview</category>
      </categories>
      <tags>
        <tag>webview</tag>
        <tag>截图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux(Mac) 站点软链接]]></title>
    <url>%2F1493916011%2F</url>
    <content type="text"><![CDATA[路径123456.├── sites-available│ ├── a.conf│ └── ecshop36.conf├── sites-enabled│ └── a.conf -&gt; ../sites-available/a.conf 在sites-enabled内建立软链接ecshop36.conf，链到sites-available内的ecshop36.conf。 进入sites-enabled文件夹内 允许命令ln -s ../sites-available/ecshop36.conf ecshop36.conf 结果1234567.├── sites-available│ ├── a.conf│ └── ecshop36.conf├── sites-enabled│ ├── a.conf -&gt; ../sites-available/a.conf│ └── ecshop36.conf -&gt; ../sites-available/ecshop36.conf]]></content>
      <categories>
        <category>系统</category>
        <category>linux</category>
        <category>命令</category>
      </categories>
      <tags>
        <tag>linux(Mac) ，站点，软链接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux(Mac)命令ll输出后各个字段的含义]]></title>
    <url>%2F3486928078%2F</url>
    <content type="text"><![CDATA[ll命令ll并不是linux下一个基本的命令，它实际上是ls -l的一个别名 Mac下推荐iTerm2终端，并配合zsh使用。非常方便。 ll命令结果字段说明示例：123456789➜ Desktop lltotal 520drwxr-xr-x@ 3 nht staff 102B Dec 22 16:48 $RECYCLE.BIN-rw-r--r--@ 1 nht staff 7.0K Jan 2 09:24 Thumbs.dbdrwxr-xr-x 5 nht staff 170B Dec 7 16:57 apk-rw-r--r--@ 1 nht staff 282B Dec 22 16:47 desktop.ini-rw-r--r--@ 2 nht staff 213K Nov 20 11:37 git.doc-rwxr-xr-x@ 1 nht staff 23K Nov 19 12:21 github-mark.png-rw-r--r--@ 1 nht staff 5.7K Jan 2 15:19 temp.txt 共7列栏目， 分别是：文件属性 文件个数 文件或目录拥有者 所属组 文件大小 最后一次修改时间 文件名 若文件类型是链接类型，文件名右边会有 “-&gt; 文件具体路径” ，不包括引号。指向链接路径文件。 第一个栏位，表示文件的属性。Linux的文件基本上分为三个属性：可读（r），可写（w），可执行（x）。 这里有十个格子可以添（具体程序实现时，实际上是十个bit位）。 第一个字母表示文件类型, ”-”,普通文件 ”d”目录,字母”d”,是dirtectory(目录)的缩写. “l”符号链接。请注意,一个目录或者说一个文件夹是一个特殊文件,这个特殊文件存放的是其他文件和文件夹的相关信息. “b”块设备文件。 “c”字符设备文件。 紧接着的3*3个字符分3组，各指示此文件的读、写、执行权限，对于owner、group、others而言。 因为Linux是多用户多任务系统，所以一个文件可能同时被许多人使用，所以我们一定要设好每个文件的权限，其文件的权限位置排列顺序是（以-rwxr-xr-x为例）： rwx(Owner)r-x(Group)r-x(Other) 这个例子表示的权限是：使用者自己可读，可写，可执行；同一组的用户可读，不可写，可执行；其它用户可读，不可写，可执行。 另外，有一些程序属性的执行部分不是X,而是S,这表示执行这个程序的使用者，临时可以有和拥有者一样权力的身份来执行该程序。一般出现在系统管理之类的指令或程序，让使用者执行时，拥有root身份。 第二个栏位，表示文件个数。如果是文件的话，那这个数目自然是1了，如果是目录的话，那它的数目就是该目录中的文件个数了。 第三个栏位，表示该文件或目录的拥有者。 第四个栏位，表示所属的组（group）。每一个使用者都可以拥有一个以上的组，不过大部分的使用者应该都只属于一个组，只有当系统管理员希望给予某使用者特殊权限时，才可能会给他另一个组。 第五栏位，表示文件大小。文件大小用byte来表示，而空目录一般都是1024byte，当然可以用其它参数使文件显示的单位不同，如使用ls –k就是用kb莱显示一个文件的大小单位，不过一般我们还是以byte为主。 第六个栏位，表示最后一次修改时间。以“月 日 时间”的格式表示，如Nov 20 11:37表示11月20日11:37分。 第七个栏位，表示文件名。我们可以用ls –a显示隐藏的文件名。]]></content>
      <categories>
        <category>系统</category>
        <category>linux</category>
        <category>命令</category>
      </categories>
      <tags>
        <tag>Linux(Mac)命令，ll，各个字段的含义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[神奇的注释]]></title>
    <url>%2F1827013075%2F</url>
    <content type="text"><![CDATA[注：使用&lt;pre/&gt;&lt;/pre&gt;标签包裹，保持原有状态；否则图像会乱掉 佛祖保佑，永无BUG12345678910111213141516171819202122232425262728/** *&lt;pre&gt; * _oo0oo_ * o8888888o * 88" . "88 * (| -_- |) * 0\ = /0 * ___/`---'\___ * .' \\| |// '. * / \\||| : |||// \ * / _||||| -:- |||||- \ * | | \\\ - /// | | * | \_| ''\---/'' |_/ | * \ .-\__ '-' ___/-. / * ___'. .' /--.--\ `. .'___ * ."" '&lt; `.___\_&lt;|&gt;_/___.' &gt;' "". * | | : `- \`.;`\ _ /`;.`/ - ` : | | * \ \ `_. \_ __\ /__ _/ .-` / / * =====`-.____`.___ \_____/___.-`___.-'===== * `=---=' * * * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ * * 佛祖保佑 永无BUG * * &lt;/pre&gt; */ 神兽保佑,代码无bug12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** *&lt;pre&gt; * code is far away from bug with the animal protecting * ┌─┐ ┌─┐ * ┌──┘ ┴───────┘ ┴──┐ * │ │ * │ ─── │ * │ ─┬┘ └┬─ │ * │ │ * │ ─┴─ │ * │ │ * └───┐ ┌───┘ * │ │ * │ │ * │ │ * │ └──────────────┐ * │ │ * │ ├─┐ * │ ┌─┘ * │ │ * └─┐ ┐ ┌───────┬──┐ ┌──┘ * │ ─┤ ─┤ │ ─┤ ─┤ * └──┴──┘ └──┴──┘ * 神兽保佑 * 代码无BUG! * * * * ___====-_ _-====___ * _--^^^#####// \\#####^^^--_ * _-^##########// ( ) \\##########^-_ * -############// |\^^/| \\############- * _/############// (@::@) \\############\_ * /#############(( \\// ))#############\ * -###############\\ (oo) //###############- * -#################\\ / VV \ //#################- * -###################\\/ \//###################- * _#/|##########/\######( /\ )######/\##########|\#_ * |/ |#/\#/\#/\/ \#/\##\ | | /##/\#/ \/\#/\#/\#| \| * ` |/ V V ` V \#\| | | |/#/ V ' V V \| ' * ` ` ` ` / | | | | \ ' ' ' ' * ( | | | | ) * __\ | | | | /__ * (vvv(VVV)(VVV)vvv) * * * __----~~~~~~~~~~~------___ * . . ~~//====...... __--~ ~~ * -. \_|// |||\\ ~~~~~~::::... /~ * ___-==_ _-~o~ \/ ||| \\ _/~~- * __---~~~.==~||\=_ -_--~/_-~|- |\\ \\ _/~ * _-~~ .=~ | \\-_ '-~7 /- / || \ / * .~ .~ | \\ -_ / /- / || \ / * / ____ / | \\ ~-_/ /|- _/ .|| \ / * |~~ ~~|--~~~~--_ \ ~==-/ | \~--===~~ .\ * ' ~-| /| |-~\~~ __--~~ * |-~~-_/ | | ~\_ _-~ /\ * / \ \__ \/~ \__ * _--~ _/ | .-~~____--~-/ ~~==. * ((-&gt;/~ '.|||' -_| ~~-/ , . _|| * -_ ~\ ~~---l__i__i__i--~~_/ * _-~-__ ~) \--______________--~~ * //.-~~~-~_--~- |-------~~~~~~~~ * //.-~~~--\ * * &lt;/pre&gt; */ PC1234567891011121314151617181920212223/** *&lt;pre&gt; * PC * ,----------------, ,---------, * ,-----------------------, ," ,"| * ," ,"| ," ," | * +-----------------------+ | ," ," | * | .-----------------. | | +---------+ | * | | | | | | -==----'| | * | | I LOVE DOS! | | | | | | * | | Bad command or | | |/----|`---= | | * | | C:\&gt;_ | | | ,/|==== ooo | ; * | | | | | // |(((( [33]| ," * | `-----------------' |," .;'| |(((( | ," * +-----------------------+ ;; | | |," * /_)______________(_/ //' | +---------+ * ___________________________/___ `, * / oooooooooooooooo .o. oooo /, \,"----------- * / ==ooooooooooooooo==.o. ooo= // ,`\--&#123;)B ," * /_==__==========__==_ooo__ooo=_/' /___________," * * &lt;/pre&gt; */ Book1234567891011121314/** *&lt;pre&gt; * .-~~~~~~~~~-._ _.-~~~~~~~~~-. * __.' ~. .~ `.__ * .'// \./ \\`. * .'// | \\`. * .'// .-~"""""""~~~~-._ | _,-~~~~"""""""~-. \\`. * .'//.-" `-. | .-' "-.\\`. * .'//______.============-.. \ | / ..-============.______\\`. * .'______________________________\|/______________________________`. * * &lt;/pre&gt; */ 美女123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * &lt;pre&gt; * .::::. * .::::::::. * ::::::::::: FUCK YOU * ..:::::::::::' * '::::::::::::' * .:::::::::: * '::::::::::::::.. * ..::::::::::::. * ``:::::::::::::::: * ::::``:::::::::' .:::. * ::::' ':::::' .::::::::. * .::::' :::: .:::::::'::::. * .:::' ::::: .:::::::::' ':::::. * .::' :::::.:::::::::' ':::::. * .::' ::::::::::::::' ``::::. * ...::: ::::::::::::' ``::. * ```` ':. ':::::::::' ::::.. * '.:::::' ':'````.. * * &lt;/pre&gt; *//** * &lt;pre&gt; * http://www.freebuf.com/ * _.._ ,------------. * ,' `. ( We want you! ) * / __) __` \ `-,----------' * ( (`-`(-') ) _.-' * /) \ = / ( * /' |--' . \ * ( ,---| `-.)__` * )( `-.,--' _`-. * '/,' ( Uu", * (_ , `/,-' ) * `.__, : `-'/ /`--' * | `--' | * ` `-._ / * \ ( * /\ . \. freebuf * / |` \ ,-\ * / \| .) / \ * ( ,'|\ ,' : * | \,`.`--"/ &#125; * `,' \ |,' / * / "-._ `-/ | * "-. "-.,'| ; * / _/["---'""] * : / |"- ' * ' | / * ` | *&lt;/pre&gt; */ 老鼠1234567891011121314151617/** * &lt;pre&gt; * .--, .--, * ( ( \.---./ ) ) * '.__/o o\__.' * &#123;= ^ =&#125; * &gt; - &lt; * / \ * // \\ * //| . |\\ * "'\ /'"_.-~^`'-. * \ _ /--' ` * ___)( )(___ * (((__) (__))) 高山仰止,景行行止.虽不能至,心向往之。 * &lt;/pre&gt; */ 骷髅123456789101112131415161718192021222324252627/** * &lt;pre&gt; * ************************************************************* * * * * * .=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-. * * * | ______ | * * * | .-" "-. | * * * | / \ | * * * | _ | | _ | * * * | ( \ |, .-. .-. ,| / ) | * * * | &gt; "=._ | )(__/ \__)( | _.=" &lt; | * * * | (_/"=._"=._ |/ /\ \| _.="_.="\_) | * * * | "=._"(_ ^^ _)"_.=" | * * * | "=\__|IIIIII|__/=" | * * * | _.="| \IIIIII/ |"=._ | * * * | _ _.="_.="\ /"=._"=._ _ | * * * | ( \_.="_.=" `--------` "=._"=._/ ) | * * * | &gt; _.=" "=._ &lt; | * * * | (_/ \_) | * * * | | * * * '-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=' * * * * * * LASCIATE OGNI SPERANZA, VOI CH'ENTRATE * * ************************************************************* * &lt;/pre&gt; */ FUCK BUG123456789101112131415/** * &lt;pre&gt; * * █████▒█ ██ ▄████▄ ██ ▄█▀ ██████╗ ██╗ ██╗ ██████╗ * ▓██ ▒ ██ ▓██▒▒██▀ ▀█ ██▄█▒ ██╔══██╗██║ ██║██╔════╝ * ▒████ ░▓██ ▒██░▒▓█ ▄ ▓███▄░ ██████╔╝██║ ██║██║ ███╗ * ░▓█▒ ░▓▓█ ░██░▒▓▓▄ ▄██▒▓██ █▄ ██╔══██╗██║ ██║██║ ██║ * ░▒█░ ▒▒█████▓ ▒ ▓███▀ ░▒██▒ █▄ ██████╔╝╚██████╔╝╚██████╔╝ * ▒ ░ ░▒▓▒ ▒ ▒ ░ ░▒ ▒ ░▒ ▒▒ ▓▒ ╚═════╝ ╚═════╝ ╚═════╝ * ░ ░░▒░ ░ ░ ░ ▒ ░ ░▒ ▒░ * ░ ░ ░░░ ░ ░ ░ ░ ░░ ░ * ░ ░ ░ ░ ░ *&lt;/pre&gt; */ unknow12345678910/** * &lt;pre&gt; * 写这段代码的时候，只有上帝和我知道它是干嘛的 * 现在，只有上帝知道 * * When I wrote this, only God and I understood what I was doing * Now, God only knows * &lt;/pre&gt; */ 参考awesome-comment]]></content>
      <categories>
        <category>android</category>
        <category>注释</category>
      </categories>
      <tags>
        <tag>注释</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML类图]]></title>
    <url>%2F305120434%2F</url>
    <content type="text"><![CDATA[前言UML,统一建模语言（英语：Unified Modeling Language，缩写 UML）是非专利的第三代建模和规约语言。UML是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。UML展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。 作用类图是软件工程的统一建模语言一种静态结构图，该图描述了系统的类集合，类的属性和类之间的关系。帮助人们简化对系统的理解，它是系统分析和设计阶段的重要产物，也是系统编码和测试的重要模型依据。学习好类图的绘制，是一位合格的软件工程师应有的技能。 Mac UML绘图工具 StartUml 百度网盘（破解版） 提取密码：mcia 本地下载 v2.8.0（破解版） 本地下载 v4.0.1（破解版） xclient.info（破解版） 官网正式版 $70 类的UML图示在UML类图中，类一般包含类名，属性，操作方法及其参数并且用分割线分隔的长方形表示上图中 类名 Person 全局变量（成员变量） name，age 方法 getName，setName，getAge，setAge 注：面向对象的语言叫方法；面向过程的语言叫函数 类名我使用的uml工具里，当类是抽象类时，类名会倾斜。 属性UML中的属性名就是Java中的成员变 表示方式如下&lt;&lt; stereotype &gt;&gt; name : type[multiplicity]=value 可见性 可以通过按钮设置，或者在name 前 手动输入 可见性有4中，分别是 +public # protected - private ~ package 操作方法表示方式如下&lt;&lt; stereotype &gt;&gt; name(param1 : type1[multiplicity]=default,param2,……) : returnType 与属性相比，多了返回类型和行参。 可见性 设置与属性一致 类图内的六大关系依赖（Dependency）、关联（Association）、聚合（Aggregation）、组合（Composition）、泛化（Generalization）、实现（Interface Realization） 其中 依赖（Dependency）、关联（Association）、聚合（Aggregation）、组合（Composition）指的是两对象间的关系。 实现（Interface Realization）一个class类实现interface接口（可以是多个）的功能；实现是类与接口之间最常见的关系；在Java中此类关系通过关键字implements明确标识，在设计时一般没有争议性 泛化（Generalization）一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系；在Java中此类关系通过关键字extends明确标识，在设计时一般没有争议性； 依赖（Dependency）依赖关系是类与类之间最弱的关系，依赖可以简单的理解一个类使用了另一个类，这种使用关系具有临时性特征，但是一个类又会由于另一个类的改变而受到影响。在Java内表现为行参（局部变量），非成员变量。在UML类中用一个带箭头的虚线表示，箭头指向被调用类 关联（Association）两个类、或者类与接口之间语义级别的一种强依赖关系。关联关系是一种包含关系，在UML中用一个带箭头的实线表示，箭头指向被包含类。这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的、关联可以是单向、双向的；在Java内表现为被关联类B以类属性的形式出现在关联类A中，也可能是关联类A引用了一个类型为被关联类B的全局变量。在UML类中用一个带箭头的实线表示，箭头指向被包含类 关联的数量关系如下 0..1 表示另一个类的一个对象没有或只与该类的一个对象有关系 1 表示另一个类的一个对象只与该类的一个对象有关系 0.. 表示另一个类的一个对象与该类的零个或多个对象有关系 1.. 表示另一个类的一个对象与该类的一个或多个对象有关系 * 任意多个对象关联 聚合（Aggregation）聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。表现在代码层面，和关联关系是一致的，只能从语义级别来区分。在UML类中聚合关系用带空心菱形的直线表示，由部分指向整体。 组合（Composition）组合也是关联关系的一种特例，部分存活周期受到整体的影响，若整体不存在则部分也将不存在。他体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合。表现在代码层面，此时部分需在整体的构造方法中创建。在UML类中组合关系用带实心菱形的直线表示，由部分指向整体。 使用的完整类图 关系之间的区别 聚合与组合 （1）聚合与组合都是一种结合关系，只是额外具有整体-部分的意涵。 （2）部件的生命周期不同 聚合关系中，整件不会拥有部件的生命周期，所以整件删除时，部件不会被删除。再者，多个整件可以共享同一个部件。 组合关系中，整件拥有部件的生命周期，所以整件删除时，部件一定会跟着删除。而且，多个整件不可以同时间共享同一个部件。 （3）聚合关系是“has-a”关系，组合关系是“contains-a”关系。 关联和聚合 （1）表现在代码层面，和关联关系是一致的，只能从语义级别来区分。 （2）关联和聚合的区别主要在语义上，关联的两个对象之间一般是平等的，例如你是我的朋友，聚合则一般不是平等的。 （3）关联是一种结构化的关系，指一种对象和另一种对象有联系。 （4）关联和聚合是视问题域而定的，例如在关心汽车的领域里，轮胎是一定要组合在汽车类中的，因为它离开了汽车就没有意义了。但是在卖轮胎的店铺业务里，就算轮胎离开了汽车，它也是有意义的，这就可以用聚合了。 关联和依赖 （1）关联关系中，体现的是两个类、或者类与接口之间语义级别的一种强依赖关系，比如我和我的朋友；这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的。 （2）依赖关系中，可以简单的理解，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是B类的变化会影响到A。 4.综合比较 这几种关系都是语义级别的，所以从代码层面并不能完全区分各种关系； 但总的来说，后几种关系所表现的强弱程度依次为： 组合&gt;聚合&gt;关联&gt;依赖； 参考UML类图关系（泛化 、继承、实现、依赖、关联、聚合、组合） Java利器之UML类图详解]]></content>
      <categories>
        <category>UML</category>
        <category>类图</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView 简单设置分割线]]></title>
    <url>%2F2918804568%2F</url>
    <content type="text"><![CDATA[先上效果 直接上代码使用默认方式1recyclerView.addItemDecoration( new DividerItemDecoration(mContext, DividerItemDecoration.VERTICAL)); 使用自定义颜色及高度（通过shape 控制颜色及高度）123DividerItemDecoration dividerItemDecoration = new DividerItemDecoration(mContext, DividerItemDecoration.VERTICAL); dividerItemDecoration.setDrawable(ContextCompat.getDrawable(mContext, R.drawable.shape_recycleview_divider)); recyclerView.addItemDecoration(dividerItemDecoration); R.drawable.shape_RecyclerView_divider123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle"&gt; &lt;solid android:color="#F3F5F7"/&gt; &lt;size android:height="2dp"/&gt;&lt;/shape&gt; DividerItemDecoration源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172/* * Copyright (C) 2016 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package android.support.v7.widget;import android.annotation.SuppressLint;import android.content.Context;import android.content.res.TypedArray;import android.graphics.Canvas;import android.graphics.Rect;import android.graphics.drawable.Drawable;import android.support.annotation.NonNull;import android.support.v4.view.ViewCompat;import android.view.View;import android.widget.LinearLayout;/** * DividerItemDecoration is a &#123;@link RecyclerView.ItemDecoration&#125; that can be used as a divider * between items of a &#123;@link LinearLayoutManager&#125;. It supports both &#123;@link #HORIZONTAL&#125; and * &#123;@link #VERTICAL&#125; orientations. * * &lt;pre&gt; * mDividerItemDecoration = new DividerItemDecoration(recyclerView.getContext(), * mLayoutManager.getOrientation()); * recyclerView.addItemDecoration(mDividerItemDecoration); * &lt;/pre&gt; */public class DividerItemDecoration extends RecyclerView.ItemDecoration &#123; public static final int HORIZONTAL = LinearLayout.HORIZONTAL; public static final int VERTICAL = LinearLayout.VERTICAL; private static final int[] ATTRS = new int[]&#123; android.R.attr.listDivider &#125;; private Drawable mDivider; /** * Current orientation. Either &#123;@link #HORIZONTAL&#125; or &#123;@link #VERTICAL&#125;. */ private int mOrientation; private final Rect mBounds = new Rect(); /** * Creates a divider &#123;@link RecyclerView.ItemDecoration&#125; that can be used with a * &#123;@link LinearLayoutManager&#125;. * * @param context Current context, it will be used to access resources. * @param orientation Divider orientation. Should be &#123;@link #HORIZONTAL&#125; or &#123;@link #VERTICAL&#125;. */ public DividerItemDecoration(Context context, int orientation) &#123; final TypedArray a = context.obtainStyledAttributes(ATTRS); mDivider = a.getDrawable(0); a.recycle(); setOrientation(orientation); &#125; /** * Sets the orientation for this divider. This should be called if * &#123;@link RecyclerView.LayoutManager&#125; changes orientation. * * @param orientation &#123;@link #HORIZONTAL&#125; or &#123;@link #VERTICAL&#125; */ public void setOrientation(int orientation) &#123; if (orientation != HORIZONTAL &amp;&amp; orientation != VERTICAL) &#123; throw new IllegalArgumentException( "Invalid orientation. It should be either HORIZONTAL or VERTICAL"); &#125; mOrientation = orientation; &#125; /** * Sets the &#123;@link Drawable&#125; for this divider. * * @param drawable Drawable that should be used as a divider. */ public void setDrawable(@NonNull Drawable drawable) &#123; if (drawable == null) &#123; throw new IllegalArgumentException("Drawable cannot be null."); &#125; mDivider = drawable; &#125; @Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; if (parent.getLayoutManager() == null) &#123; return; &#125; if (mOrientation == VERTICAL) &#123; drawVertical(c, parent); &#125; else &#123; drawHorizontal(c, parent); &#125; &#125; @SuppressLint("NewApi") private void drawVertical(Canvas canvas, RecyclerView parent) &#123; canvas.save(); final int left; final int right; if (parent.getClipToPadding()) &#123; left = parent.getPaddingLeft(); right = parent.getWidth() - parent.getPaddingRight(); canvas.clipRect(left, parent.getPaddingTop(), right, parent.getHeight() - parent.getPaddingBottom()); &#125; else &#123; left = 0; right = parent.getWidth(); &#125; final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = parent.getChildAt(i); parent.getDecoratedBoundsWithMargins(child, mBounds); final int bottom = mBounds.bottom + Math.round(ViewCompat.getTranslationY(child)); final int top = bottom - mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(canvas); &#125; canvas.restore(); &#125; @SuppressLint("NewApi") private void drawHorizontal(Canvas canvas, RecyclerView parent) &#123; canvas.save(); final int top; final int bottom; if (parent.getClipToPadding()) &#123; top = parent.getPaddingTop(); bottom = parent.getHeight() - parent.getPaddingBottom(); canvas.clipRect(parent.getPaddingLeft(), top, parent.getWidth() - parent.getPaddingRight(), bottom); &#125; else &#123; top = 0; bottom = parent.getHeight(); &#125; final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = parent.getChildAt(i); parent.getLayoutManager().getDecoratedBoundsWithMargins(child, mBounds); final int right = mBounds.right + Math.round(ViewCompat.getTranslationX(child)); final int left = right - mDivider.getIntrinsicWidth(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(canvas); &#125; canvas.restore(); &#125; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; if (mOrientation == VERTICAL) &#123; outRect.set(0, 0, 0, mDivider.getIntrinsicHeight()); &#125; else &#123; outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0); &#125; &#125;&#125;]]></content>
      <categories>
        <category>android</category>
        <category>RecyclerView</category>
      </categories>
      <tags>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7中systemctl命令详解]]></title>
    <url>%2F434086405%2F</url>
    <content type="text"><![CDATA[LinuxSystemctl是一个系统管理守护进程、工具和库的集合，用于取代System V、service和chkconfig命令，初始进程主要负责控制systemd系统和服务管理器。通过Systemctl –help可以看到该命令主要分为：查询或发送控制命令给systemd服务，管理单元服务的命令，服务文件的相关命令，任务、环境、快照相关命令，systemd服务的配置重载，系统开机关机相关的命令。 列出所有可用单元# systemctl list-unit-files 列出所有运行中单元# systemctl list-units 列出所有失败单元# systemctl –failed 检查某个单元（如 crond.service）是否启用# systemctl is-enabledcrond.service 列出所有服务# systemctl list-unit-files –type=service Linux中如何启动、重启、停止、重载服务以及检查服务（如 httpd.service）状态# systemctl start httpd.service# systemctl restart httpd.service# systemctl stop httpd.service# systemctl reload httpd.service# systemctl status httpd.service注意：当我们使用systemctl的start，restart，stop和reload命令时，终端不会输出任何内容，只有status命令可以打印输出。 如何激活服务并在开机时启用或禁用服务（即系统启动时自动启动mysql.service服务）# systemctl is-active mysql.service # systemctl enable mysql.service# systemctl disable mysql.service 如何屏蔽（让它不能启动）或显示服务（如ntpdate.service）# systemctl mask ntpdate.service ln -s ‘/dev/null”/etc/systemd/system/ntpdate.service’# systemctl unmask ntpdate.service rm ‘/etc/systemd/system/ntpdate.service’ 使用systemctl命令杀死服务# systemctl killcrond 列出所有系统挂载点# systemctl list-unit-files –type=mount 挂载、卸载、重新挂载、重载系统挂载点并检查系统中挂载点状态# systemctl start tmp.mount# systemctl stop tmp.mount# systemctl restart tmp.mount# systemctl reload tmp.mount# systemctl status tmp.mount 在启动时激活、启用或禁用挂载点（系统启动时自动挂载）# systemctl is-active tmp.mount# systemctl enable tmp.mount# systemctl disable tmp.mount 在Linux中屏蔽（让它不能启用）或可见挂载点# systemctl mask tmp.mount ln -s ‘/dev/null”/etc/systemd/system/tmp.mount’# systemctl unmask tmp.mount rm ‘/etc/systemd/system/tmp.mount’ 列出所有可用系统套接口# systemctl list-unit-files –type=socket 检查某个服务的所有配置细节# systemctl showmysql 获取某个服务（httpd）的依赖性列表# systemctl list-dependencies httpd.service 启动救援模式# systemctl rescue 进入紧急模式# systemctl emergency 列出当前使用的运行等级# systemctl get-default 启动运行等级5，即图形模式# systemctl isolate runlevel5.target 或 # systemctl isolate graphical.target 启动运行等级3，即多用户模式（命令行）# systemctl isolate runlevel3.target 或 # systemctl isolate multiuser.target 设置多用户模式或图形模式为默认运行等级# systemctl set-default runlevel3.target# systemctl set-default runlevel5.target 重启、停止、挂起、休眠系统或使系统进入混合睡眠# systemctl reboot # systemctl halt# systemctl suspend# systemctl hibernate# systemctl hybrid-sleep对于不知运行等级为何物的人，说明如下。Runlevel 0 : 关闭系统Runlevel 1 : 救援，维护模式Runlevel 3 : 多用户，无图形系统Runlevel 4 : 多用户，无图形系统Runlevel 5 : 多用户，图形化系统Runlevel 6 : 关闭并重启机器]]></content>
      <categories>
        <category>系统</category>
        <category>linux</category>
        <category>centos7</category>
      </categories>
      <tags>
        <tag>systemctl</tag>
      </tags>
  </entry>
</search>
